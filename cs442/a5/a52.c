#ifdef __cplusplus
extern "C" {
#endif
/*
ANSI C code generated by SmartEiffel The GNU Eiffel Compiler, Eiffel tools and libraries
Release 1.1 Release Candidate #2 (Wed June 11th 2003) [Charlemagne]
Copyright (C), 1994-2003 - INRIA - LORIA - UHP - Nancy 2 - FRANCE
D.COLNET, S.COLLIN, O.ZENDRA, P.RIBET, C.ADRIAN - SmartEiffel@loria.fr
http://SmartEiffel.loria.fr
C Compiler options used: -pipe
*/
#ifdef __cplusplus
}
#endif
#include "a5.h"
#ifdef __cplusplus
extern "C" {
#endif

void gc_sweep30(fsoc*c){
gc30*o1,*o2,*flt,flh;
o1=((gc30*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store30;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
}
else{
o1->header.next=gc_free30;
gc_free30=o1;
}
}
}
else{
int dead=1;
flh.header.next=NULL;
flt=&flh;
o2=o1+c->count_minus_one;
for(;o1<=o2;o2--){
if((o2->header.flag)==FSOH_MARKED){
o2->header.flag=FSOH_UNMARKED;
dead=0;}
else{
flt->header.next=o2;
flt=o2;
}
}
if (dead){
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
else if(flh.header.next!=NULL){
flt->header.next=gc_free30;
gc_free30=flh.header.next;
}
}
}

void gc_mark30(T30*o){
se_gc_check_id(o,30);
{if(((gc30*)o)->header.flag==FSOH_UNMARKED){
((gc30*)o)->header.flag=FSOH_MARKED;
if(NULL!=o->_db/*1*/)gc_mark31((T31*)(o->_db/*1*/));
}
}}

void gc_align_mark30(fsoc*c,gc30*p){
gc30*b=((gc30*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store30)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T30*o=(&(p->object));
((gc30*)o)->header.flag=FSOH_MARKED;
if(NULL!=o->_db/*1*/)gc_mark31((T31*)(o->_db/*1*/));
}
}
}
fsoc H30={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark30,
(void(*)(mch*))gc_sweep30},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc30))-1)};

T30*new30(void){
gc30*n;
fsoc*c;
if(store_left30>1){
store_left30--;
n=store30++;
}
else if(gc_free30!=NULL){
n=gc_free30;
gc_free30=n->header.next;
}
else if(store_left30==1){
store_left30=0;
store_chunk30->header.state_type=FSO_USED_CHUNK;
n=store30++;
}
else{
c=gc_fsoc_get1();
if(gc_free30!=NULL){
n=gc_free30;
gc_free30=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk30=c;
*store_chunk30=H30;
store30=((gc30*)(&(store_chunk30->first_object)));
store_left30=H30.count_minus_one;
n=store30++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M30;
return((T30*)n);
}

void gc_sweep37(fsoc*c){
gc37*o1,*o2,*flt,flh;
o1=((gc37*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store37;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
}
else{
o1->header.next=gc_free37;
gc_free37=o1;
}
}
}
else{
int dead=1;
flh.header.next=NULL;
flt=&flh;
o2=o1+c->count_minus_one;
for(;o1<=o2;o2--){
if((o2->header.flag)==FSOH_MARKED){
o2->header.flag=FSOH_UNMARKED;
dead=0;}
else{
flt->header.next=o2;
flt=o2;
}
}
if (dead){
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
else if(flh.header.next!=NULL){
flt->header.next=gc_free37;
gc_free37=flh.header.next;
}
}
}

void gc_mark37(T37*o){
se_gc_check_id(o,37);
{if(((gc37*)o)->header.flag==FSOH_UNMARKED){
((gc37*)o)->header.flag=FSOH_MARKED;
if(NULL!=o->_buffer/*5*/)gc_mark9((o->_buffer/*5*/));
}
}}

void gc_align_mark37(fsoc*c,gc37*p){
gc37*b=((gc37*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store37)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T37*o=(&(p->object));
((gc37*)o)->header.flag=FSOH_MARKED;
if(NULL!=o->_buffer/*5*/)gc_mark9((o->_buffer/*5*/));
}
}
}
fsoc H37={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark37,
(void(*)(mch*))gc_sweep37},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc37))-1)};

T37*new37(void){
gc37*n;
fsoc*c;
if(store_left37>1){
store_left37--;
n=store37++;
}
else if(gc_free37!=NULL){
n=gc_free37;
gc_free37=n->header.next;
}
else if(store_left37==1){
store_left37=0;
store_chunk37->header.state_type=FSO_USED_CHUNK;
n=store37++;
}
else{
c=gc_fsoc_get1();
if(gc_free37!=NULL){
n=gc_free37;
gc_free37=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk37=c;
*store_chunk37=H37;
store37=((gc37*)(&(store_chunk37->first_object)));
store_left37=H37.count_minus_one;
n=store37++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M37;
return((T37*)n);
}

#ifdef __cplusplus
}
#endif
