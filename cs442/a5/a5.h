#ifdef __cplusplus
extern "C" {
#endif
/*
ANSI C code generated by SmartEiffel The GNU Eiffel Compiler, Eiffel tools and libraries
Release 1.1 Release Candidate #2 (Wed June 11th 2003) [Charlemagne]
Copyright (C), 1994-2003 - INRIA - LORIA - UHP - Nancy 2 - FRANCE
D.COLNET, S.COLLIN, O.ZENDRA, P.RIBET, C.ADRIAN - SmartEiffel@loria.fr
http://SmartEiffel.loria.fr
C Compiler options used: -pipe
*/

/*
-- This file is  free  software, which  comes  along  with  SmartEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of
-- another product.
--       Copyright (C) 1994-2002 LORIA - INRIA - U.H.P. Nancy 1 - FRANCE
--          Dominique COLNET and Suzanne COLLIN - SmartEiffel@loria.fr
--                       http://SmartEiffel.loria.fr
--
*/
/*
  This file (SmartEiffel/sys/runtime/base.h) contains all basic Eiffel
  type definitions.
  This file is automatically included in the header for all modes of
  compilation: -boost, -no_check, -require_check, -ensure_check, ...
  This file is also included in the header of any cecil file (when the
  -cecil option is used).
  This file is also included in the header file of C++ wrappers (when
  using the external "C++" clause).
*/

#ifndef _BASE_H
#define _BASE_H

#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>
#include <signal.h>
#include <stddef.h>
#include <stdarg.h>
#include <limits.h>
#include <float.h>
#include <setjmp.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#if defined __USE_POSIX || defined __unix__ || defined _POSIX_C_SOURCE
#  include <unistd.h>
#endif
#if !defined(WIN32) && \
       (defined(WINVER) || defined(_WIN32_WINNT) || defined(_WIN32) || \
	defined(__WIN32__) || defined(__TOS_WIN__) || defined(_MSC_VER))
#  define WIN32 1
#endif
#ifdef WIN32
#  include <windows.h>
#else
#  ifndef O_RDONLY
#    include <sys/file.h>
#  endif
#  ifndef O_RDONLY
#    define O_RDONLY 0000
#  endif
#endif

#if defined(_MSC_VER) && (_MSC_VER < 1400) /* MSVC older than v8 */
typedef signed char int8_t;
typedef signed short int16_t;
typedef signed int int32_t;
typedef signed __int64 int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef unsigned __int64 uint64_t;
#  define PRId8 "d"
#  define PRId16 "d"
#  define PRId32 "d"
#  define PRId64 "I64d"
#  define INT8_C(c) c
#  define INT16_C(c) c
#  define INT32_C(c) c
#  define INT64_C(c) c ## i64
#elif defined(__WATCOMC__) && (__WATCOMC__ <= 1100) /* WATCOM 11 or lower */
typedef signed char int8_t;
typedef signed short int16_t;
typedef signed long int int32_t;
typedef signed __int64 int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned long int uint32_t;
typedef unsigned __int64 uint64_t;
#  define PRId8 "d"
#  define PRId16 "d"
#  define PRId32 "d"
#  define PRId64 "Ld"
#  define INT8_C(c) c
#  define INT16_C(c) c
#  define INT32_C(c) c ## L
#  define INT64_C(c) c ## i64
#elif defined(__BORLANDC__) && (__BORLANDC__ < 0x600) /* Borland before 6.0 */
typedef signed char int8_t;
typedef signed short int16_t;
typedef signed long int int32_t;
typedef signed __int64 int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned long int uint32_t;
typedef unsigned __int64 uint64_t;
#  define PRId8 "d"
#  define PRId16 "d"
#  define PRId32 "ld"
#  define PRId64 "I64Ld"
#  define INT8_C(c) c
#  define INT16_C(c) c
#  define INT32_C(c) c ## L
#  define INT64_C(c) c ## i64
#elif defined(__FreeBSD__) && (__FreeBSD__ < 5) /* FreeBSD before 5.0 */ && !defined (_SYS_INTTYPES_H_)
typedef signed char int8_t;
typedef signed short int16_t;
typedef signed long int int32_t;
typedef signed long long int int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned long int uint32_t;
typedef unsigned long long int uint64_t;
#elif defined(__CYGWIN__) && defined(__BIT_TYPES_DEFINED__) /* Cygwin defines intxx_t in sys/types.h instead of inttypes.h */
typedef unsigned char uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
#else
#  include <inttypes.h>
#  if !defined(INT8_MAX) && defined(INT16_MAX)
/* int8_t is not mandatory */
typedef int_least8_t int8_t;
#  endif
#endif

#if !defined(PRId16)
#  define PRId8 "d"
#  define PRId16 "d"
#  define PRId32 "ld"
#  define PRId64 "lld"
#elif !defined(PRId8)
#  define PRId8 "d"
#endif
#if !defined(INT16_C)
#  define INT8_C(c) c
#  define INT16_C(c) c
#  define INT32_C(c) c ## L
#  define INT64_C(c) c ## LL
#elif !defined(INT8_C)
#  define INT8_C(c) c
#endif
#if !defined(INT16_MIN)
#  define INT8_MIN (-INT8_C(127)-1)
#  define INT8_MAX (INT8_C(127))
#  define INT16_MIN (-INT16_C(32767)-1)
#  define INT16_MAX (INT16_C(32767))
#  define INT32_MIN (-INT32_C(2147483647)-1)
#  define INT32_MAX (INT32_C(2147483647))
#  define INT64_MIN (-INT64_C(9223372036854775807)-1)
#  define INT64_MAX (INT64_C(9223372036854775807))
#elif !defined(INT8_MIN)
#  define INT8_MIN (-INT8_C(127)-1)
#endif


/*
  Endian stuff
*/
#if defined(BSD) && (BSD >= 199103)
#  include <machine/endian.h>
#elif defined(__alpha__) || defined(__alpha) || defined(_M_ALPHA)
/* bi-endian processor, current mode should be find in machine/endian.h file */
#  include <machine/endian.h>
#elif defined(linux)
#  include <endian.h>
#endif



#if !defined(BYTE_ORDER) && defined(__BYTE_ORDER)
#  define BYTE_ORDER      __BYTE_ORDER
#endif

#if !defined(LITTLE_ENDIAN) && defined(__LITTLE_ENDIAN)
#  define LITTLE_ENDIAN      __LITTLE_ENDIAN
#endif

#if !defined(BIG_ENDIAN) && defined(__BIG_ENDIAN)
#  define BIG_ENDIAN      __BIG_ENDIAN
#endif

#if !defined(LITTLE_ENDIAN)
#  define LITTLE_ENDIAN   1234    /* LSB first (vax, pc) */
#endif
#if !defined(BIG_ENDIAN)
#  define BIG_ENDIAN      4321    /* MSB first (IBM, net) */
#endif
#if !defined(PDP_ENDIAN)
#  define PDP_ENDIAN      3412    /* LSB first in word, MSW first in long */
#endif

#if !defined(BYTE_ORDER) && defined(BIT_ZERO_ON_RIGHT)
#  define BYTE_ORDER      LITTLE_ENDIAN
#elif !defined(BYTE_ORDER) && defined(BIT_ZERO_ON_LEFT)
#  define BYTE_ORDER      BIG_ENDIAN
#elif !defined(BYTE_ORDER)

/* HP RISC */
#  if defined(__hppa__) || defined(__hppa) || defined(__hp9000) || \
      defined(__hp9000s300) || defined(hp9000s300) || \
      defined(__hp9000s700) || defined(hp9000s700) || \
      defined(__hp9000s800) || defined(hp9000s800) || defined(hp9000s820)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* IBM */
#  if defined(ibm032) || defined(ibm370) || defined(_IBMR2)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* Intel x86 */
#  if defined(i386) || defined(__i386__) || defined(__i386) || \
      defined(_M_IX86) || defined(_X86_) || defined(__THW_INTEL) || \
      defined(sun386)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  endif

/* Intel Itanium */
#  if defined(__ia64__) || defined(_IA64) || defined(__IA64__) || \
      defined(_M_IA64)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  endif

/* Nationnal Semiconductor 32000 serie */
#  if  defined(ns32000)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  endif

/* Motorola 68000 */
#  if defined(mc68000) || defined(is68k) || defined(macII) || defined(m68k)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* MIPS */
#  if defined(MIPSEL) || defined(_MIPSEL)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  elif defined(MIPSEB) || defined(_MIPSEB)
#    define BYTE_ORDER      BIG_ENDIAN
#  elif defined(__mips__) || defined(__mips) || defined(__MIPS__)
#    error "MIPS are bi-endian processors. Endianness is unknown for this system, please drop an e-mail to SmartEiffel@loria.fr"
#  endif

/* Power PC */
/* this processor is bi-endian, how to know if little-endian is set? */
#  if defined(__powerpc) || defined(__powerpc__) || defined(__POWERPC__) || \
      defined(__ppc__) || defined(__ppc) || defined(_M_PPC) || \
      defined(__PPC) || defined(__PPC__)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* Pyramid 9810 */
#  if defined(pyr)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* RS/6000 */
#  if defined(__THW_RS6000) || defined(_IBMR2) || defined(_POWER) || \
      defined(_ARCH_PWR) || defined(_ARCH_PWR2)
#    define BYTE_ORDER      _ENDIAN
#  endif

/* SPARC */
#  if defined(__sparc__) || defined(sparc) || defined(__sparc)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* CCI Tahoe */
#  if defined(tahoe)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* VAX */
#  if defined(vax) || defined(VAX) || defined(__vax__) || defined(_vax_) || \
      defined(__vax) || defined(__VAX)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  endif

/* ELATE is a virtual OS with a little endian Virtual Processor */
#  if defined(__ELATE__)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  endif

/* Miscellaneous little endian */
#  if defined(wrltitan)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  endif

/* Miscellaneous big endian */
#  if defined(apollo) || defined(__convex__) || defined(_CRAY) || defined(sel)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif
#endif


#if !defined(BYTE_ORDER)
#  error "Unknown byte order. Add your system in above macros once you know your system type. Please drop an e-mail to SmartEiffel@loria.fr"
#endif
#if (BYTE_ORDER != BIG_ENDIAN && BYTE_ORDER != LITTLE_ENDIAN)
#  error "Only little-endian and big-endian are valid at this time. Please drop an e-mail to SmartEiffel@loria.fr"
#endif


/*
  Byte swapping stuff
*/
extern void copy_swap_16(const uint16_t *src, uint16_t *dest, int count);


/* Because ANSI C EXIT_* are not always defined: */
#ifndef EXIT_FAILURE
#  define EXIT_FAILURE 1
#endif
#ifndef EXIT_SUCCESS
#  define EXIT_SUCCESS 0
#endif

/*
   On Linux glibc systems, we need to use sig.* versions of jmp_buf,
   setjmp and longjmp to preserve the signal handling context.
   Currently, the way I figured to detect this is if _SIGSET_H_types has
   been defined in /usr/include/setjmp.h.
*/
#ifdef _SIGSET_H_types
#  define JMP_BUF    sigjmp_buf
#  define SETJMP(x)  sigsetjmp( (x), 1)
#  define LONGJMP    siglongjmp
#else
#  define JMP_BUF    jmp_buf
#  define SETJMP(x)  setjmp( (x) )
#  define LONGJMP    longjmp
#endif

/*
   Type to store reference objects Id:
 */
typedef int Tid;
typedef struct S0 T0;
struct S0{Tid id;};

/*
   The default channel used to print runtime error messages:
*/
#define SE_ERR stderr

/*
   Eiffel type INTEGER_8 is #1:
*/
typedef int8_t T1;
#define EIF_INTEGER_8 T1
#define M1 (INT8_C(0))
#define EIF_INTEGER_8_BITS (CHAR_BIT)
#define EIF_MINIMUM_INTEGER_8 (INT8_MIN)
#define EIF_MAXIMUM_INTEGER_8 (INT8_MAX)

/*
  Eiffel type INTEGER_16 is #10:
*/
typedef int16_t T10;
#define EIF_INTEGER_16 T10
#define M10 (INT16_C(0))
#define EIF_INTEGER_16_BITS (CHAR_BIT*sizeof(T10t))
#define EIF_MINIMUM_INTEGER_16 (INT16_MIN) /*-32768*/
#define EIF_MAXIMUM_INTEGER_16 (INT16_MAX) /*+32767*/

/*
  Eiffel type INTEGER or INTEGER_32 is #2:
*/
typedef int32_t T2;
#define EIF_INTEGER T2
#define EIF_INTEGER_32 T2
#define M2 (INT32_C(0))
#define EIF_INTEGER_BITS ((T2)(CHAR_BIT*sizeof(T2)))
#define EIF_INTEGER_32_BITS EIF_INTEGER_BITS
#define EIF_MINIMUM_INTEGER (INT32_MIN)
#define EIF_MAXIMUM_INTEGER (INT32_MAX)

/*
  Eiffel type INTEGER_64 is #11:
*/
typedef int64_t T11;
#define EIF_INTEGER_64 T11
#define M11 (INT64_C(0))
#define EIF_INTEGER_64_BITS (CHAR_BIT*sizeof(T11))
#define EIF_MINIMUM_INTEGER_64 (INT64_MIN)
#define EIF_MAXIMUM_INTEGER_64 (INT64_MAX)

/*
  Eiffel type CHARACTER is #3:
*/
typedef unsigned char T3;
#define EIF_CHARACTER T3
#define M3 (0)
#define EIF_CHARACTER_BITS (CHAR_BIT)
#define EIF_MINIMUM_CHARACTER_CODE (0)
#define EIF_MAXIMUM_CHARACTER_CODE (255)
#define T3code(x) ((T10)(x))
#define T3to_integer(x) ((signed char)(x))
#define T3to_bit(x) (x)

/*
  Eiffel type REAL is #4:
*/
typedef float T4;
#define EIF_REAL T4
#define M4 (0.0)
#define EIF_REAL_BITS (CHAR_BIT*sizeof(float))
#define EIF_MINIMUM_REAL (-(FLT_MAX))
#define EIF_MAXIMUM_REAL (FLT_MAX)

/*
  Eiffel type DOUBLE is #5:
*/
typedef double T5;
#define EIF_DOUBLE T5
#define M5 (0.0)
#define EIF_DOUBLE_BITS (CHAR_BIT*sizeof(double))
#define EIF_MINIMUM_DOUBLE (-(DBL_MAX))
#define EIF_MAXIMUM_DOUBLE (DBL_MAX)

/*
  Eiffel type BOOLEAN is #6:
*/
typedef char T6;
#define EIF_BOOLEAN T6
#define M6 (0)
#define EIF_BOOLEAN_BITS (CHAR_BIT)

/*
   Eiffel type POINTER is #8:
*/
typedef void* T8;
#define EIF_POINTER T8
/* Sometimes, NULL is defined as 0 */
#define M8 ((void*)NULL)
#define EIF_POINTER_BITS (CHAR_BIT*sizeof(void*))

/*
  To use type STRING on the C side:
*/
#define EIF_STRING T7*

/*
  Some Other EIF_* defined in ETL:
*/
#define eif_access(x) ((char*)(x))
#define EIF_REFERENCE T0*
#define EIF_OBJ T0*
#define EIF_OBJECT EIF_OBJ

/*
   Wrappers for `malloc' and `calloc':
*/
void* se_malloc(size_t size);
void* se_calloc(size_t nmemb, size_t size);


#endif /* #ifndef _BASE_H */
#define SE_GC_LIB 1

/*C Header Pass 1 :*/
typedef struct S34 T34;
typedef struct S44 T44;
typedef struct S16 T16;
typedef struct S38 T38;
typedef struct S31 T31;
typedef struct S42 T42;
typedef struct S39 T39;
typedef struct S7 T7;
typedef struct S22 T22;
typedef struct S12 T12;
typedef struct S30 T30;
typedef struct S37 T37;

/*C Header Pass 2 :*/
typedef T0**T33;
#define M33 NULL
typedef T0**T29;
#define M29 NULL
typedef T3*T9;
#define M9 NULL
typedef T2*T45;
#define M45 NULL

/*C Header Pass 3 :*/

/*C Header Pass 4 :*/
struct S34{Tid id;};
extern T34 M34;
void se_prinT34(FILE* file,T34**o);
struct S44{Tid id;T45 _storage;T2 _capacity;T2 _upper;T2 _lower;};
extern T44 M44;
void se_prinT44(FILE* file,T44**o);
void se_prinT33(FILE* file,T33*o);
struct S38{Tid id;T0* _file;T0* _s;};
extern T38 M38;
void se_prinT38(FILE* file,T38**o);
struct S31{Tid id;T33 _storage;T2 _capacity;T2 _upper;T2 _lower;};
extern T31 M31;
void se_prinT31(FILE* file,T31**o);
struct S42{Tid id;T29 _storage;T2 _capacity;T2 _upper;};
extern T42 M42;
void se_prinT42(FILE* file,T42**o);
struct S39{Tid id;T0* _path;T3 _last_character;T6 _end_of_input;T6 _push_back_flag;T8 _input_stream;T9 _buffer;T6 _end_reached;T2 _buffer_position;T2 _buffer_size;T2 _capacity;};
extern T39 M39;
void se_prinT39(FILE* file,T39**o);
void se_prinT29(FILE* file,T29*o);
struct S7{Tid id;T9 _storage;T2 _count;T2 _capacity;};
extern T7 M7;
void se_prinT9(FILE* file,T9*o);
struct S16{Tid id;T0* _rules;};
extern T16 M16;
void se_prinT16(FILE* file,T16**o);
struct S22{Tid id;T29 _storage;T2 _capacity;T2 _upper;T2 _lower;};
extern T22 M22;
void se_prinT22(FILE* file,T22**o);
struct S12{Tid id;T0* _tok;T0* _db;T6 _dummy;};
extern T12 M12;
void se_prinT12(FILE* file,T12**o);
void se_prinT45(FILE* file,T45*o);
struct S30{Tid id;T0* _db;T6 _cut;T6 _dummy;};
extern T30 M30;
void se_prinT30(FILE* file,T30**o);
struct S37{Tid id;T2 _buffer_position;T9 _buffer;T2 _capacity;};
extern T37 M37;
void se_prinT37(FILE* file,T37**o);
extern char*s12_0;
extern char*s30_33;
extern char*s12_46;
extern char*s12_335;
extern char*s12_2190;
/*
-- This file is  free  software, which  comes  along  with  SmartEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of
-- another product.
--       Copyright (C) 1994-2002 LORIA - INRIA - U.H.P. Nancy 1 - FRANCE
--          Dominique COLNET and Suzanne COLLIN - SmartEiffel@loria.fr
--                       http://SmartEiffel.loria.fr
--
*/
/*
  This file (SmartEiffel/sys/runtime/no_check.h) is automatically included
  when `run_control.no_check' is true (ie. all modes except mode -boost).
*/

void se_prinT0(FILE* file,T0** o);
void se_prinT1(FILE* file,EIF_INTEGER_8* o);
void se_prinT2(FILE* file,EIF_INTEGER* o);
void se_prinT3(FILE* file,EIF_CHARACTER* o);
void se_prinT4(FILE* file,EIF_REAL* o);
void se_prinT5(FILE* file,EIF_DOUBLE* o);
void se_prinT6(FILE* file,EIF_BOOLEAN* o);
void se_prinT7(FILE* file,EIF_STRING* o);
void se_prinT8(FILE* file,EIF_POINTER* o);
void se_prinT10(FILE* file,EIF_INTEGER_16* o);
void se_prinT11(FILE* file,EIF_INTEGER_64* o);

/*
   This type is used to store a position in some Eiffel source file.
   It must be compatible with the implementation of class POSITION.
*/
typedef unsigned int se_position;

#define se_position2line(position) (((position) & 1) \
  ? ((EIF_INTEGER)(((position) >> 1) & 0x7FFF)) \
  : ((EIF_INTEGER)(((position) >> 8) & 0x1FFF)))

#define se_position2column(position) (((position) & 1) \
  ? 0 \
  : ((EIF_INTEGER)(((position) >> 1) & 0x7F)))

#define se_position2path_id(position) (((position) & 1) \
  ? ((position) >> 17) \
  : ((position) >> 21))

/*
  To be able to print a stack frame in a human readable format :
*/
typedef struct _se_frame_descriptor se_frame_descriptor;
struct _se_frame_descriptor {
  char* name; /* Eiffel name of the routine. */
  int use_current; /* Flag is 1 when this routine use Current. */
  int local_count; /* Number of C variables to print. */
  char* local_format; /* Format/type information. */
  int assertion_flag; /* 1 when assertions can be checked. */
};

/*
  To keep the track of execution in order to be able to print a
  dump when things goes wrong :
*/
typedef struct _se_dump_stack se_dump_stack;
struct _se_dump_stack {
  se_frame_descriptor* fd;
  void** current; /* NULL when not used. */
  se_position p; /* The current position. */
  se_dump_stack* caller; /* Back to the caller. */
  se_dump_stack* exception_origin; /* The exception origin if we are handling an exception. That object was malloc'ed */
  void*** locals;
};
extern se_dump_stack* se_dst;
int se_stack_size(se_dump_stack* ds);
void se_print_run_time_stack(void);
int se_print_one_frame(se_dump_stack*ds);
int se_print_one_frame_in(FILE* file, se_dump_stack*ds);

extern int se_rspf;
extern int se_require_uppermost_flag;
extern int se_require_last_result;
int se_rci(se_dump_stack*caller,void*C);
void error0(char*m,char*vv);
void error1(char*m,se_position position);
void error2(T0* o,se_position position);
T0* vc(T0* o, se_position position);
T0* ci(int id, T0* o, se_position position);
void ac_req(int v, char* vv);
void ac_ens(int v, char* vv);
void ac_inv(int v, char* vv);
void ac_liv(int v, char* vv);
void ac_insp(int v);
int ac_lvc(int lc,int lv1,int lv2);
void ac_civ(int v,char*vv);
T0* se_evobt(T0* o,se_position position);
void se_signal_handler(int sig);
void se_gc_check_id(void*o,int id);

/* The two following instructions are used by the exceptions system to keep
   the stack trace when jumping back to the retry clause */
se_dump_stack* se_new_dump_stack(se_dump_stack* copy);
void se_delete_dump_stack(se_dump_stack* ds);

#ifdef SE_SCOOP
#define set_dump_stack_top(subsystem, ds) \
  do { \
    se_subsystem_t* rst_self=(subsystem); \
    (void)(rst_self->vft.get_dst_and_lock(rst_self)); \
    rst_self->vft.set_dst_and_unlock(rst_self,(ds)); \
  } while(0)
#else
#define set_dump_stack_top(ds) se_dst=(ds)
#endif
#define FSOC_SIZE 8192
#define RSOC_SIZE 32768
/*
-- This file is  free  software, which  comes  along  with  SmartEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of
-- another product.
--       Copyright (C) 1994-2002 LORIA - INRIA - U.H.P. Nancy 1 - FRANCE
--          Dominique COLNET and Suzanne COLLIN - SmartEiffel@loria.fr
--                       http://SmartEiffel.loria.fr
--
*/
/*
   This file (SmartEiffel/sys/runtime/gc_lib.h) is automatically included
   when the Garbage Collector is used (default, unless option -no_gc has
   been selected).
*/

#define SE_GC_LIB 1

#define SE_GC_LOW_MEMORY_STRATEGY 0
#define SE_GC_HIGH_MEMORY_STRATEGY 1
#define SE_GC_DEFAULT_MEMORY_STRATEGY 2
extern int se_gc_strategy;


#define RSOH_UNMARKED 15253
#define RSOH_FREE 1
#define RSOH_MARKED 2


#define FSOH_UNMARKED ((void *) 1)
#define FSOH_MARKED   ((void *) 2)

/* To codify the state and the type of some Memory Chunk, we are
   using the following definitions :
*/
#define FSO_FREE_CHUNK  (-2)
#define RSO_FREE_CHUNK  (-1)
#define RSO_USED_CHUNK  ( 0)
#define FSO_STORE_CHUNK ( 1)
#define FSO_USED_CHUNK  ( 2)
#define FREE_CHUNK(x) ((x)<0)

/* Minimum size for a store area in a ReSizable Objects Chunk :
 */
#define RSOC_MIN_STORE 512

/* The default channel used to print -gc_info flag information :
*/
#define SE_GCINFO SE_ERR

extern int collector_counter; /* MEMORY.collector_counter */

typedef struct s_mch mch; /* Memory Chunk Header. */
typedef struct s_fsoc fsoc; /* Fixed Size Objects Chunk. */
typedef union u_rsoh rsoh; /* ReSizable Object Header. */
typedef struct s_fll_rsoh fll_rsoh;
typedef struct s_rsoc rsoc; /* ReSizable Objects Chunk. */
typedef struct s_na_env na_env; /* Native Array ENVironment. */


struct s_mch{
  unsigned int size; /* In number of bytes (actual argument of malloc).*/
  int state_type; /* One value in : RSO_USED_CHUNK,
                     FREE_CHUNK, FSO_STORE_CHUNK, FSO_USED_CHUNK */
  void(*amfp)(mch*,void*); /* Align Mark Function Pointer. */
  void(*swfp)(mch*); /* SWeep Function Pointer. */
};

struct s_fsoc{
  mch header; /* Common header for fsoc and rsoc. */
  fsoc* next; /* The next one when in free list (fsocfl). */
  int count_minus_one;
  double first_object;
};

typedef struct _rso_header rso_header;

struct _rso_header{
    unsigned int size;
    int magic_flag;     /* RSOH_MARKED when used,
			   RSOH_FREE when free,
			   else RSOH_UNMARKED */
};

union u_rsoh{
  rso_header header;
  double padding;
  };

struct s_fll_rsoh {
  rso_header rsoh_field;
  fll_rsoh* nextflol;
};

struct s_rsoc{
  mch header; /* Common header for fsoc and rsoc. */
  unsigned int isize; /* Initial size (at malloc time) to detect split chunks. */
  rsoc* next; /* The next one when in free list (rsocfl). */
  fll_rsoh*free_list_of_large; /* Intra. free list. */
  na_env*nae;
  rsoh first_header;
};

struct s_na_env{
  unsigned int store_left;
  rsoh* store;
  rsoc*store_chunk;
  rsoc*chunk_list;
  void (*gc_mark)(T0*);
};

extern void**stack_bottom;
extern mch**gcmt;
extern int gcmt_max;
extern int gcmt_used;
extern int gc_is_off;
extern fsoc* fsocfl;
extern unsigned int fsoc_count;
extern unsigned int rsoc_count;
extern void*gcmt_tail_addr;

void gc_sweep(void);
void gc_mark(void* p);
mch* gc_find_chunk(void* p);
int gc_stack_size(void);
int garbage_delayed(void);
void gc_update_ceils(void);
char*new_na(na_env*nae,unsigned int size);
unsigned int fsocfl_count(void);
unsigned int rsocfl_count(void);
void gc_dispose_before_exit(void);
void mark_stack_and_registers (void);
fsoc* gc_fsoc_get1(void);
fsoc* gc_fsoc_get2(void);

int gc_memory_used(void);
/*
-- This file is  free  software, which  comes  along  with  SmartEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of
-- another product.
--       Copyright (C) 1994-2002 LORIA - INRIA - U.H.P. Nancy 1 - FRANCE
--          Dominique COLNET and Suzanne COLLIN - SmartEiffel@loria.fr
--                       http://SmartEiffel.loria.fr
--
*/
/*
  This file (SmartEiffel/sys/runtime/basic_io.h) is automatically
  included when some external "SmartEiffel" basic_io_* feature is used.
*/

#define basic_io_stdin (stdin)
#define basic_io_stdout (stdout)
#define basic_io_stderr (stderr)
#define basic_io_eof (EOF)
#define basic_io_text_file_read_open(p) (fopen(((char*)(p)),"r"))
#define basic_io_text_file_write_open(p) (fopen(((char*)(p)),"w"))
#define basic_io_text_file_write_append(p) (fopen(((char*)(p)),"a"))
#define basic_io_text_file_read_write_open(p) (fopen(((char*)(p)),"r+"))
#define basic_io_text_file_read_write_append(p) (fopen(((char*)(p)),"a+"))
#define basic_io_binary_file_read_open(p) (fopen(((char*)(p)),"rb"))
#define basic_io_binary_file_write_open(p) (fopen(((char*)(p)),"wb"))
#define basic_io_binary_file_write_append(p) (fopen(((char*)(p)),"ab"))
#define basic_io_fclose(p) (fclose((FILE*)(p)))
#define basic_io_flush(p) (fflush((FILE*)(p)))
#define basic_io_getc(f) (getc(((FILE*)(f))))
#define basic_io_putc(b, f) (putc((b),((FILE*)(f))))
#define basic_io_fread(b, n, f) (fread((void *)(b),(size_t)(1), (size_t)(n),(FILE*)(f)))
#define basic_io_fwrite(b, n, f) (fwrite((void *)(b),(size_t)(1), (size_t)(n),(FILE*)(f)))
#define basic_io_feof(f) (feof(((FILE*)(f))))
#define basic_io_rename(o, n) (rename(((char*)(o)),((char*)(n))))
#define basic_io_remove(f) (remove(((char*)(f))))

#if defined __USE_POSIX || defined __unix__ || defined _POSIX_C_SOURCE
#  define basic_io_read_stdin(b, s) (read(STDIN_FILENO, b, s))
#else
  extern int basic_io_read_stdin(char *buffer, int size);
#endif

extern unsigned int fsoc_count_ceil;
extern unsigned int rsoc_count_ceil;
/*BOOLEAN*/
T6 r6_ix_and(se_dump_stack*caller,T6 C,T6 a1);
/*BOOLEAN*/
T6 r6_ix_xor(se_dump_stack*caller,T6 C,T6 a1);
/*BOOLEAN*/
T6 r6_px_not(se_dump_stack*caller,T6 C);
/*BOOLEAN*/
T6 r6_ix_or(se_dump_stack*caller,T6 C,T6 a1);
/*CHARACTER*/
T6 r3is_default(se_dump_stack*caller,T3 C);
/*CHARACTER*/
T6 r3is_digit(se_dump_stack*caller,T3 C);
/*CHARACTER*/
T6 r3in_range(se_dump_stack*caller,T3 C,T3 a1,T3 a2);
/*CHARACTER*/
T6 r3_ix_6061(se_dump_stack*caller,T3 C,T3 a1);
/*CHARACTER*/
T1 r3value(se_dump_stack*caller,T3 C);
/*CHARACTER*/
T6 r3_ix_6261(se_dump_stack*caller,T3 C,T3 a1);
/*CHARACTER*/
T3 r3default(se_dump_stack*caller);
/*CHARACTER*/
T6 r3_ix_60(se_dump_stack*caller,T3 C,T3 a1);
/*INTEGER_8*/
T6 r1is_equal(se_dump_stack*caller,T1 C,T1 a1);
/*INTEGER_8*/
T6 r1in_range(se_dump_stack*caller,T1 C,T1 a1,T1 a2);
/*INTEGER_8*/
T1 r1_ix_45(se_dump_stack*caller,T1 C,T1 a1);
/*INTEGER_8*/
T11 r1to_integer_64(se_dump_stack*caller,T1 C);
/*INTEGER*/
T6 r2is_default(se_dump_stack*caller,T2 C);
/*INTEGER*/
T6 r2is_equal(se_dump_stack*caller,T2 C,T2 a1);
/*INTEGER*/
T2 r2max(se_dump_stack*caller,T2 C,T2 a1);
/*INTEGER*/
T6 r2divisible(se_dump_stack*caller,T2 a1);
/*INTEGER*/
T2 r2min(se_dump_stack*caller,T2 C,T2 a1);
/*INTEGER*/
T2 r2compare(se_dump_stack*caller,T2 C,T2 a1);
/*INTEGER*/
T2 r2_ix_42(se_dump_stack*caller,T2 C,T2 a1);
/*INTEGER*/
T2 r2_ix_43(se_dump_stack*caller,T2 C,T2 a1);
/*INTEGER*/
T2 r2_ix_45(se_dump_stack*caller,T2 C,T2 a1);
/*INTEGER*/
T2 r2default(se_dump_stack*caller);
/*INTEGER*/
T11 r2to_integer_64(se_dump_stack*caller,T2 C);
/*INTEGER_64*/
T6 r11is_equal(se_dump_stack*caller,T11 C,T11 a1);
/*INTEGER_64*/
T6 r11in_range(se_dump_stack*caller,T11 C,T11 a1,T11 a2);
/*INTEGER_64*/
T3 r11digit(se_dump_stack*caller,T11 C);
/*INTEGER_64*/
void r11append_in(se_dump_stack*caller,T11 C,T0* a1);
/*INTEGER_64*/
T11 r11_ix_43(se_dump_stack*caller,T11 C,T11 a1);
/*INTEGER_64*/
T11 r11to_integer_64(se_dump_stack*caller,T11 C);
/*INTEGER_16*/
T6 r10is_equal(se_dump_stack*caller,T10 C,T10 a1);
/*INTEGER_16*/
T6 r10in_range(se_dump_stack*caller,T10 C,T10 a1,T10 a2);
/*INTEGER_16*/
T1 r10to_integer_8(se_dump_stack*caller,T10 C);
/*INTEGER_16*/
T6 r10fit_integer_8(se_dump_stack*caller,T10 C);
/*INTEGER_16*/
T11 r10to_integer_64(se_dump_stack*caller,T10 C);
/*NATIVE_ARRAY[RULE]*/
T33 r33realloc(se_dump_stack*caller,T33 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[RULE]*/
void r33set_all_with(se_dump_stack*caller,T33 C,T0* a1,T2 a2);
/*NATIVE_ARRAY[RULE]*/
T6 r33is_not_null(se_dump_stack*caller,T33 C);
/*NATIVE_ARRAY[RULE]*/
T6 r33all_default(se_dump_stack*caller,T33 C,T2 a1);
/*NATIVE_ARRAY[RULE]*/
void r33copy_from(se_dump_stack*caller,T33 C,T33 a1,T2 a2);
/*NATIVE_ARRAY[STRING]*/
void r29clear_all(se_dump_stack*caller,T29 C,T2 a1);
/*NATIVE_ARRAY[STRING]*/
T29 r29realloc(se_dump_stack*caller,T29 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[STRING]*/
void r29remove_first(se_dump_stack*caller,T29 C,T2 a1);
/*NATIVE_ARRAY[STRING]*/
void r29set_all_with(se_dump_stack*caller,T29 C,T0* a1,T2 a2);
/*NATIVE_ARRAY[STRING]*/
T6 r29fast_memcmp(se_dump_stack*caller,T29 C,T29 a1,T2 a2);
/*NATIVE_ARRAY[STRING]*/
T6 r29is_not_null(se_dump_stack*caller,T29 C);
/*NATIVE_ARRAY[STRING]*/
T6 r29all_default(se_dump_stack*caller,T29 C,T2 a1);
/*NATIVE_ARRAY[STRING]*/
void r29copy_from(se_dump_stack*caller,T29 C,T29 a1,T2 a2);
/*NATIVE_ARRAY[CHARACTER]*/
T9 r9realloc(se_dump_stack*caller,T9 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[CHARACTER]*/
T6 r9fast_memcmp(se_dump_stack*caller,T9 C,T9 a1,T2 a2);
/*NATIVE_ARRAY[CHARACTER]*/
T6 r9fast_has(se_dump_stack*caller,T9 C,T3 a1,T2 a2);
/*NATIVE_ARRAY[CHARACTER]*/
T6 r9is_not_null(se_dump_stack*caller,T9 C);
/*NATIVE_ARRAY[CHARACTER]*/
T6 r9all_default(se_dump_stack*caller,T9 C,T2 a1);
/*NATIVE_ARRAY[CHARACTER]*/
void r9copy_from(se_dump_stack*caller,T9 C,T9 a1,T2 a2);
/*NATIVE_ARRAY[INTEGER]*/
T45 r45realloc(se_dump_stack*caller,T45 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[INTEGER]*/
void r45set_all_with(se_dump_stack*caller,T45 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[INTEGER]*/
T6 r45fast_memcmp(se_dump_stack*caller,T45 C,T45 a1,T2 a2);
/*NATIVE_ARRAY[INTEGER]*/
T6 r45is_not_null(se_dump_stack*caller,T45 C);
/*NATIVE_ARRAY[INTEGER]*/
T6 r45all_default(se_dump_stack*caller,T45 C,T2 a1);
/*NATIVE_ARRAY[INTEGER]*/
void r45copy_from(se_dump_stack*caller,T45 C,T45 a1,T2 a2);
/*STRING*/
T6 r7is_default(se_dump_stack*caller,T7* C);
/*STRING*/
void r7put(se_dump_stack*caller,T7* C,T3 a1,T2 a2);
/*STRING*/
T6 r7is_equal(se_dump_stack*caller,T7* C,T0* a1);
/*STRING*/
T3 r7item(se_dump_stack*caller,T7* C,T2 a1);
/*STRING*/
T6 r7valid_index(se_dump_stack*caller,T7* C,T2 a1);
/*STRING*/
void r7make(se_dump_stack*caller,T7* C,T2 a1);
/*STRING*/
T6 r7is_empty(se_dump_stack*caller,T7* C);
/*STRING*/
void r7extend(se_dump_stack*caller,T7* C,T3 a1);
/*STRING*/
T6 r7has(se_dump_stack*caller,T7* C,T3 a1);
/*STRING*/
void r7append_character(se_dump_stack*caller,T7* C,T3 a1);
/*STRING*/
void r7clear(se_dump_stack*caller,T7* C);
/*STRING*/
T8 r7to_external(se_dump_stack*caller,T7* C);
/*STRING*/
T0* r7default(se_dump_stack*caller,T7* C);
/*STRING*/
T6 r7_ix_60(se_dump_stack*caller,T7* C,T0* a1);
/*STRING*/
void r7swap(se_dump_stack*caller,T7* C,T2 a1,T2 a2);
extern se_frame_descriptor se_ifd7;
T7*se_i7(se_dump_stack*caller,T7*C);
/*ARRAY[INTEGER]*/
void r44copy(se_dump_stack*caller,T44* C,T0* a1);
/*ARRAY[INTEGER]*/
void r44clear_all(se_dump_stack*caller,T44* C);
/*ARRAY[INTEGER]*/
T2 r44last(se_dump_stack*caller,T44* C);
/*ARRAY[INTEGER]*/
T2 r44count(se_dump_stack*caller,T44* C);
/*ARRAY[INTEGER]*/
void r44put(se_dump_stack*caller,T44* C,T2 a1,T2 a2);
/*ARRAY[INTEGER]*/
T6 r44is_equal(se_dump_stack*caller,T44* C,T0* a1);
/*ARRAY[INTEGER]*/
T2 r44item(se_dump_stack*caller,T44* C,T2 a1);
/*ARRAY[INTEGER]*/
T6 r44valid_index(se_dump_stack*caller,T44* C,T2 a1);
/*ARRAY[INTEGER]*/
void r44make(se_dump_stack*caller,T44* C,T2 a1,T2 a2);
/*ARRAY[INTEGER]*/
T6 r44is_empty(se_dump_stack*caller,T44* C);
/*ARRAY[INTEGER]*/
void r44set_all_with(se_dump_stack*caller,T44* C,T2 a1);
/*ARRAY[INTEGER]*/
void r44add_last(se_dump_stack*caller,T44* C,T2 a1);
/*ARRAY[INTEGER]*/
T6 r44all_default(se_dump_stack*caller,T44* C);
/*ARRAY[INTEGER]*/
T0* r44twin(se_dump_stack*caller,T44* C);
extern se_frame_descriptor se_ifd44;
T44*se_i44(se_dump_stack*caller,T44*C);
/*ARRAY[RULE]*/
void r31clear_all(se_dump_stack*caller,T31* C);
/*ARRAY[RULE]*/
T0* r31last(se_dump_stack*caller,T31* C);
/*ARRAY[RULE]*/
T2 r31count(se_dump_stack*caller,T31* C);
/*ARRAY[RULE]*/
void r31put(se_dump_stack*caller,T31* C,T0* a1,T2 a2);
/*ARRAY[RULE]*/
T0* r31item(se_dump_stack*caller,T31* C,T2 a1);
/*ARRAY[RULE]*/
T6 r31valid_index(se_dump_stack*caller,T31* C,T2 a1);
/*ARRAY[RULE]*/
void r31make(se_dump_stack*caller,T31* C,T2 a1,T2 a2);
/*ARRAY[RULE]*/
T6 r31is_empty(se_dump_stack*caller,T31* C);
/*ARRAY[RULE]*/
void r31set_all_with(se_dump_stack*caller,T31* C,T0* a1);
/*ARRAY[RULE]*/
void r31add_last(se_dump_stack*caller,T31* C,T0* a1);
/*ARRAY[RULE]*/
T6 r31all_default(se_dump_stack*caller,T31* C);
extern se_frame_descriptor se_ifd31;
T31*se_i31(se_dump_stack*caller,T31*C);
/*FIXED_ARRAY[STRING]*/
T2 r42count(se_dump_stack*caller,T42* C);
/*FIXED_ARRAY[STRING]*/
void r42put(se_dump_stack*caller,T42* C,T0* a1,T2 a2);
/*FIXED_ARRAY[STRING]*/
T0* r42item(se_dump_stack*caller,T42* C,T2 a1);
/*FIXED_ARRAY[STRING]*/
T6 r42valid_index(se_dump_stack*caller,T42* C,T2 a1);
/*FIXED_ARRAY[STRING]*/
void r42make(se_dump_stack*caller,T42* C,T2 a1);
/*FIXED_ARRAY[STRING]*/
T6 r42is_empty(se_dump_stack*caller,T42* C);
/*FIXED_ARRAY[STRING]*/
T6 r42all_default(se_dump_stack*caller,T42* C);
extern se_frame_descriptor se_ifd42;
T42*se_i42(se_dump_stack*caller,T42*C);
/*ARRAY[STRING]*/
void r22copy(se_dump_stack*caller,T22* C,T0* a1);
/*ARRAY[STRING]*/
void r22clear_all(se_dump_stack*caller,T22* C);
/*ARRAY[STRING]*/
void r22remove_first(se_dump_stack*caller,T22* C);
/*ARRAY[STRING]*/
T0* r22last(se_dump_stack*caller,T22* C);
/*ARRAY[STRING]*/
T2 r22count(se_dump_stack*caller,T22* C);
/*ARRAY[STRING]*/
void r22put(se_dump_stack*caller,T22* C,T0* a1,T2 a2);
/*ARRAY[STRING]*/
T6 r22is_equal(se_dump_stack*caller,T22* C,T0* a1);
/*ARRAY[STRING]*/
T0* r22item(se_dump_stack*caller,T22* C,T2 a1);
/*ARRAY[STRING]*/
T6 r22valid_index(se_dump_stack*caller,T22* C,T2 a1);
/*ARRAY[STRING]*/
void r22make(se_dump_stack*caller,T22* C,T2 a1,T2 a2);
/*ARRAY[STRING]*/
void r22add_first(se_dump_stack*caller,T22* C,T0* a1);
/*ARRAY[STRING]*/
T6 r22is_empty(se_dump_stack*caller,T22* C);
/*ARRAY[STRING]*/
void r22move(se_dump_stack*caller,T22* C,T2 a1,T2 a2,T2 a3);
/*ARRAY[STRING]*/
void r22set_all_with(se_dump_stack*caller,T22* C,T0* a1);
/*ARRAY[STRING]*/
void r22add_last(se_dump_stack*caller,T22* C,T0* a1);
/*ARRAY[STRING]*/
T0* r22first(se_dump_stack*caller,T22* C);
/*ARRAY[STRING]*/
T6 r22all_default(se_dump_stack*caller,T22* C);
/*ARRAY[STRING]*/
T0* r22twin(se_dump_stack*caller,T22* C);
extern se_frame_descriptor se_ifd22;
T22*se_i22(se_dump_stack*caller,T22*C);
/*STD_INPUT_OUTPUT*/
void r34put_new_line(se_dump_stack*caller,T34* C);
extern T0*oBC35tmp_string;
/*STD_INPUT_OUTPUT*/
void r34make(se_dump_stack*caller,T34* C);
/*STD_INPUT_OUTPUT*/
void r34put_integer(se_dump_stack*caller,T34* C,T11 a1);
extern T0*oBC15std_output;
/*STD_INPUT_OUTPUT*/
void r34put_character(se_dump_stack*caller,T34* C,T3 a1);
/*STD_INPUT_OUTPUT*/
void r34put_string(se_dump_stack*caller,T34* C,T0* a1);
/*TOKENIZER*/
void r38make(se_dump_stack*caller,T38* C,T0* a1);
/*TOKENIZER*/
T0* r38next_token(se_dump_stack*caller,T38* C);
/*TEXT_FILE_READ*/
void r39disconnect(se_dump_stack*caller,T39* C);
/*TEXT_FILE_READ*/
T6 r39is_connected(se_dump_stack*caller,T39* C);
/*TEXT_FILE_READ*/
void r39read_character(se_dump_stack*caller,T39* C);
/*TEXT_FILE_READ*/
void r39fill_buffer(se_dump_stack*caller,T39* C);
/*TEXT_FILE_READ*/
void r39connect_to(se_dump_stack*caller,T39* C,T0* a1);
/*RULE*/
T6 r16is_default(se_dump_stack*caller,T16* C);
/*RULE*/
T2 r16upper(se_dump_stack*caller,T16* C);
/*RULE*/
T2 r16lower(se_dump_stack*caller,T16* C);
/*RULE*/
T0* r16rule(se_dump_stack*caller,T16* C,T2 a1);
/*RULE*/
void r16make(se_dump_stack*caller,T16* C,T0* a1);
/*RULE*/
T0* r16default(se_dump_stack*caller,T16* C);
/*DATABASE*/
T6 r30qquery(se_dump_stack*caller,T30* C,T0* a1,T0* a2);
/*DATABASE*/
void r30addrule(se_dump_stack*caller,T30* C,T0* a1);
extern T0*oBC15io;
/*DATABASE*/
T6 r30query(se_dump_stack*caller,T30* C,T0* a1,T0* a2);
/*DATABASE*/
void r30make(se_dump_stack*caller,T30* C);
/*STD_OUTPUT*/
void r37make(se_dump_stack*caller,T37* C);
/*STD_OUTPUT*/
void r37flush(se_dump_stack*caller,T37* C);
/*STD_OUTPUT*/
void r37write_buffer(se_dump_stack*caller,T37* C);
/*STD_OUTPUT*/
void r37put_character(se_dump_stack*caller,T37* C,T3 a1);
extern T0*oBC15command_arguments;
extern int fBC15command_arguments;
/*A5*/
T0* r12command_arguments(se_dump_stack*caller);
/*A5*/
T2 r12argument_count(se_dump_stack*caller,T12* C);
/*A5*/
void r12make(se_dump_stack*caller,T12* C);
/*A5*/
T0* r12argument(se_dump_stack*caller,T12* C,T2 a1);
extern T12*eiffel_root_object;
extern int se_argc;
extern char**se_argv;
#define SE_MAXID 47
extern T7*g[];
extern T7*t[];
extern char*p[];
extern void(*se_prinT[47])(FILE*,void**);
extern int se_strucT[47];
void se_atexit(void);
void initialize_eiffel_runtime(int argc,char*argv[]);
extern T0*ms25_117797837;
T0*se_ms(int c,char*e);
T0*se_string(char*e);
void se_msi1(void);
void manifest_string_mark1(void);
void once_function_mark(void);
void gc_start(void);
typedef struct B34 gc34;
struct B34{T34 object;union {void*flag;gc34*next;} header;};
extern gc34*store34;
extern int store_left34;
extern fsoc*store_chunk34;
extern gc34*gc_free34;
typedef struct B44 gc44;
struct B44{T44 object;union {void*flag;gc44*next;} header;};
extern gc44*store44;
extern int store_left44;
extern fsoc*store_chunk44;
extern gc44*gc_free44;
extern na_env na_env33;
typedef struct B38 gc38;
struct B38{T38 object;union {void*flag;gc38*next;} header;};
extern gc38*store38;
extern int store_left38;
extern fsoc*store_chunk38;
extern gc38*gc_free38;
typedef struct B31 gc31;
struct B31{T31 object;union {void*flag;gc31*next;} header;};
extern gc31*store31;
extern int store_left31;
extern fsoc*store_chunk31;
extern gc31*gc_free31;
typedef struct B42 gc42;
struct B42{T42 object;union {void*flag;gc42*next;} header;};
extern gc42*store42;
extern int store_left42;
extern fsoc*store_chunk42;
extern gc42*gc_free42;
typedef struct B39 gc39;
struct B39{T39 object;union {void*flag;gc39*next;} header;};
extern gc39*store39;
extern int store_left39;
extern fsoc*store_chunk39;
extern gc39*gc_free39;
extern na_env na_env29;
typedef struct B7 gc7;
struct B7{T7 object;union {void*flag;gc7*next;} header;};
extern gc7*store7;
extern int store_left7;
extern fsoc*store_chunk7;
extern gc7*gc_free7;
extern na_env na_env9;
typedef struct B16 gc16;
struct B16{T16 object;union {void*flag;gc16*next;} header;};
extern gc16*store16;
extern int store_left16;
extern fsoc*store_chunk16;
extern gc16*gc_free16;
typedef struct B22 gc22;
struct B22{T22 object;union {void*flag;gc22*next;} header;};
extern gc22*store22;
extern int store_left22;
extern fsoc*store_chunk22;
extern gc22*gc_free22;
typedef struct B12 gc12;
struct B12{T12 object;union {void*flag;gc12*next;} header;};
extern gc12*store12;
extern int store_left12;
extern fsoc*store_chunk12;
extern gc12*gc_free12;
extern na_env na_env45;
typedef struct B30 gc30;
struct B30{T30 object;union {void*flag;gc30*next;} header;};
extern gc30*store30;
extern int store_left30;
extern fsoc*store_chunk30;
extern gc30*gc_free30;
typedef struct B37 gc37;
struct B37{T37 object;union {void*flag;gc37*next;} header;};
extern gc37*store37;
extern int store_left37;
extern fsoc*store_chunk37;
extern gc37*gc_free37;
void gc_sweep34(fsoc*c);
void gc_mark34(T34*o);
void gc_align_mark34(fsoc*c,gc34*p);
extern fsoc H34;
T34*new34(void);
void gc_sweep44(fsoc*c);
void gc_mark44(T44*o);
void gc_align_mark44(fsoc*c,gc44*p);
extern fsoc H44;
T44*new44(void);
void gc_mark33(T33 o);
T33 new33(unsigned int size);
void gc_sweep38(fsoc*c);
void gc_mark38(T38*o);
void gc_align_mark38(fsoc*c,gc38*p);
extern fsoc H38;
T38*new38(void);
void gc_sweep31(fsoc*c);
void gc_mark31(T31*o);
void gc_align_mark31(fsoc*c,gc31*p);
extern fsoc H31;
T31*new31(void);
void gc_sweep42(fsoc*c);
void gc_mark42(T42*o);
void gc_align_mark42(fsoc*c,gc42*p);
extern fsoc H42;
T42*new42(void);
void gc_sweep39(fsoc*c);
void gc_mark39(T39*o);
void gc_align_mark39(fsoc*c,gc39*p);
extern fsoc H39;
T39*new39(void);
void gc_mark29(T29 o);
T29 new29(unsigned int size);
void gc_sweep7(fsoc*c);
void gc_mark7(T7*o);
void gc_align_mark7(fsoc*c,gc7*p);
extern fsoc H7;
T7*new7(void);
void gc_mark9(T9 o);
T9 new9(unsigned int size);
void gc_sweep16(fsoc*c);
void gc_mark16(T16*o);
void gc_align_mark16(fsoc*c,gc16*p);
extern fsoc H16;
T16*new16(void);
void gc_sweep22(fsoc*c);
void gc_mark22(T22*o);
void gc_align_mark22(fsoc*c,gc22*p);
extern fsoc H22;
T22*new22(void);
void gc_sweep12(fsoc*c);
void gc_mark12(T12*o);
void gc_align_mark12(fsoc*c,gc12*p);
extern fsoc H12;
T12*new12(void);
void gc_mark45(T45 o);
T45 new45(unsigned int size);
void gc_sweep30(fsoc*c);
void gc_mark30(T30*o);
void gc_align_mark30(fsoc*c,gc30*p);
extern fsoc H30;
T30*new30(void);
void gc_sweep37(fsoc*c);
void gc_mark37(T37*o);
void gc_align_mark37(fsoc*c,gc37*p);
extern fsoc H37;
T37*new37(void);

#ifdef __cplusplus
}
#endif
