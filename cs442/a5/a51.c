#ifdef __cplusplus
extern "C" {
#endif
/*
ANSI C code generated by SmartEiffel The GNU Eiffel Compiler, Eiffel tools and libraries
Release 1.1 Release Candidate #2 (Wed June 11th 2003) [Charlemagne]
Copyright (C), 1994-2003 - INRIA - LORIA - UHP - Nancy 2 - FRANCE
D.COLNET, S.COLLIN, O.ZENDRA, P.RIBET, C.ADRIAN - SmartEiffel@loria.fr
http://SmartEiffel.loria.fr
C Compiler options used: -pipe
*/
#ifdef __cplusplus
}
#endif
#include "a5.h"
#ifdef __cplusplus
extern "C" {
#endif
/*
-- This file is  free  software, which  comes  along  with  SmartEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of
-- another product.
--       Copyright (C) 1994-2002 LORIA - INRIA - U.H.P. Nancy 1 - FRANCE
--          Dominique COLNET and Suzanne COLLIN - SmartEiffel@loria.fr
--                       http://SmartEiffel.loria.fr
--
*/
/*
  This file (SmartEiffel/sys/runtime/base.c) is included for _all_ modes of
  compilation (-boost, -no_check, ... -all_check, -debug_check).
*/

/*
  Byte swapping function
*/
void copy_swap_16(const uint16_t *src, uint16_t *dest, int count){
  while (count--) {
    *dest++ = (*src << 8) | (*src >> 8);
    src++;
  }
}


/*
  The wrapper for `malloc' (generated C code is supposed to use
  only `se_malloc' instead of direct `malloc').
*/
void* se_malloc(size_t size) {
  void *result = malloc(size);
  if (result == NULL) {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(No_more_memory);
#elif !defined(SE_BOOST)
    error0("No more memory.", NULL);
#else
  fprintf(SE_ERR,"No more memory.\n");
  se_print_run_time_stack();
  exit(EXIT_FAILURE);
#endif
  }
  return result;
}

/*
  The wrapper for `calloc' (generated C code is supposed to use
  only `se_calloc' instead of direct `calloc').
*/
void* se_calloc(size_t nmemb, size_t size) {
  void *result = calloc(nmemb,size);
  if (result == NULL) {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(No_more_memory);
#elif !defined(SE_BOOST)
    error0("No more memory.", NULL);
#else
  fprintf(SE_ERR,"No more memory.\n");
  se_print_run_time_stack();
  exit(EXIT_FAILURE);
#endif
  }
  return result;
}

/*
  The wrapper for `realloc' (generated C code is supposed to use
  only `se_realloc' instead of direct `realloc').
*/
void* se_realloc(void* src, size_t size) {
  void *result = realloc(src, size);
  if (result == NULL) {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(No_more_memory);
#elif !defined(SE_BOOST)
    error0("No more memory.", NULL);
#else
  fprintf(SE_ERR,"No more memory.\n");
  se_print_run_time_stack();
  exit(EXIT_FAILURE);
#endif
  }
  return result;
}
T34 M34={34};

void se_prinT34(FILE* file,T34**o){
if(*o==NULL){
   fprintf(file,"Void");
   return;}
fprintf(file,"STD_INPUT_OUTPUT");
fprintf(file,"#%p",(void*)*o);
}
T44 M44={44,NULL,0,0,0};

void se_prinT44(FILE* file,T44**o){
if(*o==NULL){
   fprintf(file,"Void");
   return;}
fprintf(file,"ARRAY[INTEGER]");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"storage = ");
se_prinT45(file,(&((*o)->_storage)));
fprintf(file,"\n\t  ");
fprintf(file,"capacity = ");
se_prinT2(file,(&((*o)->_capacity)));
fprintf(file,"\n\t  ");
fprintf(file,"upper = ");
se_prinT2(file,(&((*o)->_upper)));
fprintf(file,"\n\t  ");
fprintf(file,"lower = ");
se_prinT2(file,(&((*o)->_lower)));
fprintf(file,"\n\t]");
}

void se_prinT33(FILE* file,T33*o){
fprintf(file,"NATIVE_ARRAY[RULE]");
fprintf(file,"#%p",(void*)*o);
}
T38 M38={38,NULL,NULL};

void se_prinT38(FILE* file,T38**o){
if(*o==NULL){
   fprintf(file,"Void");
   return;}
fprintf(file,"TOKENIZER");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"file = ");
se_prinT0(file,(T0**)(&((*o)->_file)));
fprintf(file,"\n\t  ");
fprintf(file,"s = ");
se_prinT7(file,(EIF_STRING*)(&((*o)->_s)));
fprintf(file,"\n\t]");
}
T31 M31={31,NULL,0,0,0};

void se_prinT31(FILE* file,T31**o){
if(*o==NULL){
   fprintf(file,"Void");
   return;}
fprintf(file,"ARRAY[RULE]");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"storage = ");
se_prinT33(file,(&((*o)->_storage)));
fprintf(file,"\n\t  ");
fprintf(file,"capacity = ");
se_prinT2(file,(&((*o)->_capacity)));
fprintf(file,"\n\t  ");
fprintf(file,"upper = ");
se_prinT2(file,(&((*o)->_upper)));
fprintf(file,"\n\t  ");
fprintf(file,"lower = ");
se_prinT2(file,(&((*o)->_lower)));
fprintf(file,"\n\t]");
}
T42 M42={42,NULL,0,0};

void se_prinT42(FILE* file,T42**o){
if(*o==NULL){
   fprintf(file,"Void");
   return;}
fprintf(file,"FIXED_ARRAY[STRING]");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"storage = ");
se_prinT29(file,(&((*o)->_storage)));
fprintf(file,"\n\t  ");
fprintf(file,"capacity = ");
se_prinT2(file,(&((*o)->_capacity)));
fprintf(file,"\n\t  ");
fprintf(file,"upper = ");
se_prinT2(file,(&((*o)->_upper)));
fprintf(file,"\n\t]");
}
T39 M39={39,NULL,0,0,0,NULL,NULL,0,0,0,0};

void se_prinT39(FILE* file,T39**o){
if(*o==NULL){
   fprintf(file,"Void");
   return;}
fprintf(file,"TEXT_FILE_READ");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"path = ");
se_prinT7(file,(EIF_STRING*)(&((*o)->_path)));
fprintf(file,"\n\t  ");
fprintf(file,"last_character = ");
se_prinT3(file,(&((*o)->_last_character)));
fprintf(file,"\n\t  ");
fprintf(file,"end_of_input = ");
se_prinT6(file,(&((*o)->_end_of_input)));
fprintf(file,"\n\t  ");
fprintf(file,"push_back_flag = ");
se_prinT6(file,(&((*o)->_push_back_flag)));
fprintf(file,"\n\t  ");
fprintf(file,"input_stream = ");
se_prinT8(file,(&((*o)->_input_stream)));
fprintf(file,"\n\t  ");
fprintf(file,"buffer = ");
se_prinT9(file,(&((*o)->_buffer)));
fprintf(file,"\n\t  ");
fprintf(file,"end_reached = ");
se_prinT6(file,(&((*o)->_end_reached)));
fprintf(file,"\n\t  ");
fprintf(file,"buffer_position = ");
se_prinT2(file,(&((*o)->_buffer_position)));
fprintf(file,"\n\t  ");
fprintf(file,"buffer_size = ");
se_prinT2(file,(&((*o)->_buffer_size)));
fprintf(file,"\n\t  ");
fprintf(file,"capacity = ");
se_prinT2(file,(&((*o)->_capacity)));
fprintf(file,"\n\t]");
}

void se_prinT29(FILE* file,T29*o){
fprintf(file,"NATIVE_ARRAY[STRING]");
fprintf(file,"#%p",(void*)*o);
}
T7 M7={7,NULL,0,0};

void se_prinT9(FILE* file,T9*o){
fprintf(file,"NATIVE_ARRAY[CHARACTER]");
fprintf(file,"#%p",(void*)*o);
}
T16 M16={16,NULL};

void se_prinT16(FILE* file,T16**o){
if(*o==NULL){
   fprintf(file,"Void");
   return;}
fprintf(file,"RULE");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"rules = ");
se_prinT0(file,(T0**)(&((*o)->_rules)));
fprintf(file,"\n\t]");
}
T22 M22={22,NULL,0,0,0};

void se_prinT22(FILE* file,T22**o){
if(*o==NULL){
   fprintf(file,"Void");
   return;}
fprintf(file,"ARRAY[STRING]");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"storage = ");
se_prinT29(file,(&((*o)->_storage)));
fprintf(file,"\n\t  ");
fprintf(file,"capacity = ");
se_prinT2(file,(&((*o)->_capacity)));
fprintf(file,"\n\t  ");
fprintf(file,"upper = ");
se_prinT2(file,(&((*o)->_upper)));
fprintf(file,"\n\t  ");
fprintf(file,"lower = ");
se_prinT2(file,(&((*o)->_lower)));
fprintf(file,"\n\t]");
}
T12 M12={12,NULL,NULL,0};

void se_prinT12(FILE* file,T12**o){
if(*o==NULL){
   fprintf(file,"Void");
   return;}
fprintf(file,"A5");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"tok = ");
se_prinT0(file,(T0**)(&((*o)->_tok)));
fprintf(file,"\n\t  ");
fprintf(file,"db = ");
se_prinT0(file,(T0**)(&((*o)->_db)));
fprintf(file,"\n\t  ");
fprintf(file,"dummy = ");
se_prinT6(file,(&((*o)->_dummy)));
fprintf(file,"\n\t]");
}

void se_prinT45(FILE* file,T45*o){
fprintf(file,"NATIVE_ARRAY[INTEGER]");
fprintf(file,"#%p",(void*)*o);
}
T30 M30={30,NULL,0,0};

void se_prinT30(FILE* file,T30**o){
if(*o==NULL){
   fprintf(file,"Void");
   return;}
fprintf(file,"DATABASE");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"db = ");
se_prinT0(file,(T0**)(&((*o)->_db)));
fprintf(file,"\n\t  ");
fprintf(file,"cut = ");
se_prinT6(file,(&((*o)->_cut)));
fprintf(file,"\n\t  ");
fprintf(file,"dummy = ");
se_prinT6(file,(&((*o)->_dummy)));
fprintf(file,"\n\t]");
}
T37 M37={37,0,NULL,0};

void se_prinT37(FILE* file,T37**o){
if(*o==NULL){
   fprintf(file,"Void");
   return;}
fprintf(file,"STD_OUTPUT");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"buffer_position = ");
se_prinT2(file,(&((*o)->_buffer_position)));
fprintf(file,"\n\t  ");
fprintf(file,"buffer = ");
se_prinT9(file,(&((*o)->_buffer)));
fprintf(file,"\n\t  ");
fprintf(file,"capacity = ");
se_prinT2(file,(&((*o)->_capacity)));
fprintf(file,"\n\t]");
}
/*Aliased storage area or unicode storage.*/
char*s12_0="";
char*s30_33="!";
char*s12_46=".";
char*s12_335=":-";
char*s12_2190="EOF";
/*
-- This file is  free  software, which  comes  along  with  SmartEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of
-- another product.
--       Copyright (C) 1994-2002 LORIA - INRIA - U.H.P. Nancy 1 - FRANCE
--          Dominique COLNET and Suzanne COLLIN - SmartEiffel@loria.fr
--                       http://SmartEiffel.loria.fr
--
*/
/*
  This file (SmartEiffel/sys/runtime/no_check.c) is automatically included
  when `run_control.no_check' is true (ie. all modes except -boost).
*/

/*
   To print object into the trace-stack :
*/
void se_prinT0(FILE* file, T0** o) {
    if (*o == NULL) {
	fprintf(file,"Void");
    }
    else {
	fprintf(file,"#%p",(void*)*o);
    }
}

void se_prinT1(FILE* file, EIF_INTEGER_8* o) {
    fprintf(file,"%"PRId8,*o);
}

void se_prinT2(FILE* file, EIF_INTEGER* o) {
    fprintf(file,"%"PRId32,*o);
}

void se_prinT10(FILE* file, EIF_INTEGER_16* o) {
    fprintf(file,"%"PRId16,*o);
}

void se_prinT11(FILE* file,EIF_INTEGER_64* o) {
    fprintf(file,"%"PRId64,*o);
}

static void se_print_character(FILE* file, char c) {
    /* Produce a visible output of `c' using an Eiffelish notation.
     */
    if ((' ' <= c)&&(c <= '~')&&(c != '\'')&&(c != '\"')&&(c != '%')) {
	putc(c,file);
    }
    else {
	switch (c) {
	    case '\b': fprintf(file,"%%B"); break;
	    case '\f': fprintf(file,"%%F"); break;
	    case '\n': fprintf(file,"%%N"); break;
	    case '\r': fprintf(file,"%%R"); break;
	    case '\t': fprintf(file,"%%T"); break;
	    case '\0': fprintf(file,"%%U"); break;
	    case '\'': fprintf(file,"%%\'"); break;
	    case '\"': fprintf(file,"%%\""); break;
	    case '%':  fprintf(file,"%%%%"); break;
	    default:
		fprintf(file,"%%/%d/", (int) ((unsigned char) c));
	}
    }
}

void se_prinT3(FILE* file,EIF_CHARACTER* o) {
    putc('\'',file);
    se_print_character(file, *o);
    putc('\'',file);
}

void se_prinT4(FILE* file, EIF_REAL* o) {
    fprintf(file,"%f",((double)*o));
}

void se_prinT5(FILE* file, EIF_DOUBLE* o) {
    fprintf(file,"%f",*o);
}

void se_prinT6(FILE* file, EIF_BOOLEAN* o) {
    if (*o) {
	fprintf(file,"True");
    }
    else {
	fprintf(file,"False");
    }
}

void se_prinT7(FILE* file, EIF_STRING* o) {
    if (*o == NULL) {
	fprintf(file,"Void");
    }
    else {
	T3* storage = (*o)->_storage;
	int count = (*o)->_count;
	int i = 0;
	putc('\"',file);
	while (i < count) {
	    se_print_character(file, storage[i++]);
	}
	putc('\"',file);
    }
}

void se_prinT8(FILE* file, EIF_POINTER* o) {
    if (*o == NULL) {
	fprintf(file,"NULL");
    }
    else {
	fprintf(file,"POINTER#%p",(void*)*o);
    }
}


#ifndef SCOOP
/*
  The upper most context (SmartEiffel Dump stack Top) :
*/
se_dump_stack* se_dst=NULL;
#endif


int se_stack_size(se_dump_stack* ds) {
  int result = 0;
  while (ds != NULL) {
    ds = ds->caller;
    result ++;
  }
  return result;
}

void se_print_run_time_stack(void) {
  /* GENERAL.print_run_time_stack */

#ifdef SE_SCOOP
  se_subsystem_t* self = se_current_subsystem_thread();
  self->vft.print_run_time_stack(self);
#else
  se_dump_stack* origin;
  se_dump_stack* ds;
  se_dump_stack* ds2;
  int frame_count = 1;
  int rescue = 0;

  origin = se_dst;
  if (origin == NULL) {
    fprintf(SE_ERR,"Empty stack.\n");
    return ;
  }
  else {
    while (origin->exception_origin != NULL) {
      origin = origin->exception_origin;
    }

    ds = origin;
    while (ds->caller != NULL) {
      ds = ds->caller;
      frame_count++;
    }
  }
  fprintf(SE_ERR,"%d frames in current stack.\n",frame_count);
  fprintf(SE_ERR,"=====  Bottom of run-time stack  =====\n");
  while (ds != NULL) {
    se_print_one_frame(ds);
    /* Next frame : */
    if (ds == origin) {
      ds = NULL;
    }
    else if (ds->exception_origin != NULL) {
      rescue = 1;
      ds = ds->exception_origin;
    }
    else {
      ds2 = se_dst;
      while (ds2->caller != ds) {
	ds2 = ds2->caller;
      }
      ds = ds2;
    }
    if (--frame_count) {
      if (!rescue) {
        fprintf(SE_ERR,"======================================\n");
      }
      else {
        fprintf(SE_ERR,"====   Rescue stack  =================\n");
      }
    }
  }
  fprintf(SE_ERR,"=====   Top of run-time stack    =====\n");
#endif /* SE_SCOOP */
}

int se_print_one_frame(se_dump_stack* ds) {
  return se_print_one_frame_in(SE_ERR, ds);
}

int se_print_one_frame_in(FILE* file, se_dump_stack* ds) {
  /* Return 1 for an ordinary frame (not a cecil frame or some dynamic
     dispatch extra frame). */
  se_frame_descriptor* fd = ds->fd;
  int i = 0;
  int local_count = 0;
  char* local_format;
  int expanded;
  int id;
  void** var;

  if (fd == NULL) {
    fprintf(file,"External CECIL call.\n");
    return 0;
  }
  fprintf(file,"%s\n",fd->name);
  if (ds->p == 0) return 0;
  local_format = fd->local_format;
  if (fd->use_current) {
    fprintf(file,"Current = ");
    i = 2;
    id = 0;
    while (local_format[i] != '%') {
      id = (id * 10) + (local_format[i] - '0');
      i++;
    }
    i++;
    (se_prinT[id])(file, ds->current);
    fprintf(file,"\n");
  }
  while (local_count < fd->local_count) {
    while (local_format[i] != '%') {
      fprintf(file,"%c",local_format[i]);
      i++;
    }
    i++;
    expanded = ((local_format[i++] == 'E')?1:0);
    fprintf(file," = ");
    id = 0;
    while (local_format[i] != '%') {
      id = (id * 10) + (local_format[i] - '0');
      i++;
    }
    i++;
    if (ds->locals == NULL) {
      fprintf(file,"<unavailable>");
    }
    else {
      var = (ds->locals)[local_count];
      if (expanded) {
        (se_prinT[id])(file, (void**)(var));
      }
      else if (*var == NULL) {
        fprintf(file,"Void");
      }
      else {
        (se_prinT[((T0*)(*var))->id])(file, (void**)(var));
      }
    }
    fprintf(file,"\n");
    local_count++;
  }
  fprintf(file,"line %d ",se_position2line(ds->p));
  fflush(file);
  fprintf(file,"column %d ",se_position2column(ds->p));
  fflush(file);
  fprintf(file,"file %s \n",p[se_position2path_id(ds->p)]);
  fflush(file);
  return 1;
}

int se_require_uppermost_flag;

/*
  Require Last Result :
*/
int se_require_last_result;

int se_rci(se_dump_stack*caller,void*C) {
  /* Where `caller' is supposed to be reference type non Void Current
     object. This function return 1 if the class invariant must be
     checked for `C' before leaving the routine.
  */
  if (caller != NULL) {
    se_frame_descriptor* fd = caller->fd;
    if (fd == NULL) {
      /* As for example when coming via CECIL. */
      return 0;
    }
    else {
      if (fd->use_current) {
	if (fd->local_format[1] == 'R') {
	  if (((void*)*(caller->current)) == C) {
	    return 0;
	  }
	}
      }
    }
  }
  return 1;
}

void error0(char* m, char* vv) {
  /* When there is nothing more to do than to exit or to go back
     into the debugger.
  */
  static char*f="*** Error at Run Time ***: %s\n";

  fprintf(SE_ERR,f,m);
  if (vv!=NULL) fprintf(SE_ERR,f,vv);
#ifdef SE_EXCEPTIONS
  print_exception();
#endif
#ifdef SE_SEDB
  sedb_break(se_dst,0);
#else
  se_print_run_time_stack();
  fprintf(SE_ERR,f,m);
  if (vv!=NULL)
    fprintf(SE_ERR,f,vv);
  exit(EXIT_FAILURE);
#endif
}

void error1(char*m,se_position position) {
  /* When there is nothing more to do than to exit or to go back
     into the debugger.
  */
  int l = se_position2line(position);
  int c = se_position2column(position);
  int f = se_position2path_id(position);
  char* f1 = "Line : %d column %d in %s.\n";
  char* f2 = "*** Error at Run Time ***: %s\n";

  fprintf(SE_ERR,f1,l,c,p[f]);
  fprintf(SE_ERR,f2,m);
#ifdef SE_EXCEPTIONS
  print_exception();
#endif
#ifdef SE_SEDB
  sedb_break(se_dst,position);
#else
  se_print_run_time_stack();
  fprintf(SE_ERR,f1,l,c,p[f]);
  fprintf(SE_ERR,f2,m);
  exit(EXIT_FAILURE);
#endif
}

void se_print_string(FILE*stream, EIF_STRING s) {
  /* To print some Eiffel STRING. */
  if (s == NULL) {
    fprintf(stream,"Void");
  }
  else {
    int count = s->_count;
    EIF_CHARACTER* storage = s->_storage;
    int i = 0;
    fprintf(stream,"\"");
    while (count != 0) {
      fprintf(stream,"%c",storage[i]);
      i++;
      count--;
    }
    fprintf(stream,"\"");
  }
}

void se_print_bad_target(FILE*stream, int id, T0* o, int l, int c, int f) {
  /* Print Bad Target Type Error Message. */
  if (l != 0) {
    fprintf(stream,"Line : %d column %d in %s.\n",l,c,p[f]);
  }
  fprintf(stream,"*** Error at Run Time *** :\n");
  fprintf(stream,"   Target is not valid (not the good type).\n");
  fprintf(stream,"   Expected: ");
  se_print_string(stream,t[id]);
  fprintf(stream,", Actual: ");
  se_print_string(stream,t[o->id]);
  fprintf(stream,".\n");
}

void error2(T0*o, se_position position) {
  fprintf(SE_ERR,"Target Type ");
  se_print_string(SE_ERR,t[o->id]);
  fprintf(SE_ERR," is not valid.\n");
  error1("Bad target.",position);
}

T0* vc(T0* o, se_position position) {
  /*
    Void check for reference target.
  */
  if (o != NULL) {
    return o;
  }
  else {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(Void_call_target);
#else
    error1("Call with a Void target.",position);
#endif
    return NULL;
  }
}

T0* ci(int id, T0* o, se_position position) {
  /*
    Check Id for reference target.
  */
  if ( vc(o,position) != NULL) {
    if ( id == (o->id) ) {
      return o;
    }
    else {
#ifdef SE_EXCEPTIONS
      internal_exception_handler(System_level_type_error);
#else
      int l = se_position2line(position);
      int c = se_position2column(position);
      int f = se_position2path_id(position);

      se_print_bad_target(SE_ERR,id,o,l,c,f);
      se_print_run_time_stack();
      se_print_bad_target(SE_ERR,id,o,l,c,f);
#ifdef SE_SEDB
      sedb_break(se_dst,0);
#else
      exit(EXIT_FAILURE);
#endif
#endif
    }
  }
  return o;
}

void ac_req(int v,char*vv) {
  if (!v && se_require_uppermost_flag) {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(Precondition);
#else
    error0("Require Assertion Violated.",vv);
#endif
  }
  se_require_last_result=se_require_last_result&&v;
}

void ac_ens(int v,char*vv) {
  if (!v) {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(Postcondition);
#else
    error0("Ensure Assertion Violated.",vv);
#endif
  }
}

void ac_inv(int v,char*vv) {
  if (!v) {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(Class_invariant);
#else
    error0("Class Invariant Violation.",vv);
#endif
  }
}

void ac_liv(int v,char*vv) {
  /* Assertion Check : Loop Invariant check. */
  if (!v) {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(Loop_invariant);
#else
    error0("Loop Invariant Violation.",vv);
#endif
  }
}

int ac_lvc(int lc,int lv1,int lv2) {
  /* Assertion Check : Loop Variant check. */
  if (lc == 0) {
    if (lv2 < 0) {
#ifdef SE_EXCEPTIONS
      internal_exception_handler(Loop_variant);
#else
      {
	char msg [64];
	sprintf(msg,"Bad First Variant Value = %d\n",lv2);
	error0(msg,NULL);
      }
#endif
    }
    else {
      return lv2;
    }
  }
  else if ((lv2 < 0) || (lv2 >= lv1)) {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(Loop_variant);
#else
    {
      char msg [512];
      sprintf(msg,
	      "Bad loop variant.\nLoop body counter = %d (done)\n"
	      "Previous Variant = %d\nNew Variant = %d\n",
	      lc,lv1,lv2);
      error0(msg,NULL);
    }
#endif
  }
  return lv2;
}

void ac_civ(int v,char*vv) {
  if (!v) {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(Check_instruction);
#else
    error0("Check Assertion Violated.",vv);
#endif
  }
}

T0* se_evobt(T0* o, se_position position) {
    /*
      Error Void Or Bad Type.
    */
    if (!o) {
#ifdef SE_EXCEPTIONS
	internal_exception_handler(Void_call_target);
#else
	error1("Target is Void.",position);
#endif
    }
    else {
#ifdef SE_EXCEPTIONS
	internal_exception_handler(System_level_type_error);
#else
	error2(o,position);
#endif
    }
    return o; /* Dummy return to avoid C warnings. */
}

void se_signal_handler(int sig) {
  printf("Received signal %d.\n",sig);
#ifdef SE_SEDB
  signal(sig,se_signal_handler);
  sedb_signal_handler(sig);
#else
  se_print_run_time_stack();
  exit(EXIT_FAILURE);
#endif
}

void se_gc_check_id(void*o,int id) {
  if (id != (((T0*)o)->id)) {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(Routine_failure);
#else
    fprintf(SE_ERR,"System-validity error detected during GC cycle.\n");
    se_print_bad_target(SE_ERR,id,(T0*)o,0,0,0);
    se_print_run_time_stack();
    fprintf(SE_ERR,"System-validity error detected during GC cycle.\n");
    se_print_bad_target(SE_ERR,id,(T0*)o,0,0,0);
    exit(EXIT_FAILURE);
#endif
  }
}

se_dump_stack* se_new_dump_stack(se_dump_stack* copy) {
  se_dump_stack* result;
  se_frame_descriptor* fd = copy->fd;
  int i, j, o, p, n;
  int local_count;
  char* local_format;
  int id;
  void** var;
  int local_size;
  int expanded;

  void*** _i;
  void** _ref;
  char*  _exp;

  result = (se_dump_stack*)malloc(sizeof(se_dump_stack));
  if (result != NULL) {
    result->fd               = fd;
    result->p                = copy->p;
    result->caller           = copy->caller;
    result->current          = NULL;
    result->locals           = NULL;
    result->exception_origin = NULL;

    if (fd != NULL) {
      local_format = fd->local_format;
      i = 0;
      if (fd->use_current) {
        result->current = copy->current;
        /* Place i after the Current definition: */
        i = 2;
        id = 0;
        while (local_format[i] != '%') {
          id = (id * 10) + (local_format[i++] - '0');
        }
        i++;
      }

      /*
       *
       * p: sum of the number of pointers ("indirections") per local
       *    -> 1 for an expanded
       *    -> 2 for a reference
       *
       * o: total malloc'ed size
       *
       * _i: access to the first indirection pointer
       *
       * _ref: access to the second indirection pointer of a reference object
       *       _ref == (T0*)(*_i)
       *
       * _exp: access to a copy of the expanded object
       *       _exp == *((char*)_i)
       *
       *
       *
       * For instance, if "0" is the first local, a reference and "4" is the
       * second local, a expanded type (say, a 6-byte structure noted
       * "XXXXXXXXXXX", with 64-bit padding "/"):
       *
       *
       *
       * result->locals
       *       |                ------------
       *       |               |            |
       *       |    -----------|------------v--------------
       *        -->| | | | |===+===|===+===|XXXXXXXXXXX|/|/|
       *           |0|1|2|3|4|5|6|7|8|9|A|B|C|D|E|F|0|1|2|3|
       *           |===+===| | | | |===+===| | | | | | | | |
       *            ---|------------^--|-------------------
       *               |            |  |
       *                ------------    --------------------------> object
       *
       *           |-> _i          |-> _ref         _exp <-|
       *
       *
       *
       * Note: Those "|->" denote the start value and way of
       *       progression of the pointers
       *
       *
       * result->locals is defined as a (void***) but its real "type" depends on
       * which element is accessed (as in the live stack; but in the live stack,
       * only the first indirection is in the stack).
       *
       */

      if (copy->locals != NULL) {
        j = i;

        local_count = local_size = p = o = 0;

        while (local_count < fd->local_count) {
          while (local_format[i++] != '%');
          expanded = ((local_format[i++] == 'E')?1:0);
          id = 0;
          while (local_format[i] != '%') {
            id = (id * 10) + (local_format[i++] - '0');
          }
          i++;
          if (expanded) {
            p++;
            o = se_strucT[id];
            o = (o + 7) & ~7; /* 64-bit align: should be fine for most systems */
            local_size += o;
          }
          else {
            p+=2;
          }
          local_count++;
        }

        o = p * sizeof(void*) + local_size;
        result->locals = (void***)se_malloc(o);
        _i   = result->locals;
        _exp = (char*)_i + o;
        _ref = (void**)_i + local_count;

        i = j;
        local_count = 0;
        while (local_count < fd->local_count) {
          while (local_format[i++] != '%');
          expanded = ((local_format[i++] == 'E')?1:0);
          id = 0;
          while (local_format[i] != '%') {
            id = (id * 10) + (local_format[i++] - '0');
          }
          i++;
          var = (copy->locals)[local_count];
          if (expanded) {
            o = n = se_strucT[id];
            o = (o + 7) & ~7; /* 64-bit align: should be fine for most systems */
            _exp -= o;
            *(char**)_i = _exp;
            memcpy(_exp, var, n);
          }
          else {
            *_i = _ref;
            *_ref = *var;
            _ref++;
          }
          local_count++;
          _i++;
        }
      }
    }
  }
  return result;
}

void se_delete_dump_stack(se_dump_stack* ds) {
  if (ds != NULL) {
    if (ds->locals != NULL) free(ds->locals);
    free(ds);
  }
}
/*
-- This file is  free  software, which  comes  along  with  SmartEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of
-- another product.
--       Copyright (C) 1994-2002 LORIA - INRIA - U.H.P. Nancy 1 - FRANCE
--          Dominique COLNET and Suzanne COLLIN - SmartEiffel@loria.fr
--                       http://SmartEiffel.loria.fr
--
*/

/*
   This file (SmartEiffel/sys/runtime/gc_lib.c) is automatically included
   when the Garbage Collector is used (default, unless option -no_gc has been
   selected).
*/
/*
   The `mark_stack_and_registers' C function is called by the Garbage
   Collector (GC) of SmartEiffel. It has to be customized for some systems,
   but also for some C compilers. This file provides some definitions in the
   end and has to be completed for systems which need specific work.

   On some architectures, addresses increase as the stack grows; or,
   conversely, addresses decrease as the stack grows. A C compiler may be
   clever enough to hide some root object inside registers. Unfortunately all
   registers are not always accessible via the C `setjmp' function!

   Thus, in order to be able to use the GC on your architecture/C-compiler,
   you have to provide the correct `mark_stack_and_registers' function.

   What is the `mark_stack_and_registers' function supposed to do?  The
   `mark_stack_and_registers' function is supposed to notify the GC with all
   the possible roots one can find in the C stack and registers by calling the
   `gc_mark' function. A root is an object which must not be collected.  The
   SmartEiffel GC already knows about some root objects like once function
   results or manifest strings. The `mark_stack_and_registers' function has to
   notify the other possible roots. Obviously, one can find in the C stack any
   kind of adresses, but the `gc_mark' function is clever enough to determine
   if the passed pointer is an Eiffel object or not.  When the passed pointer
   reaches some Eiffel object, this object as well as its descendant(s) are
   automatically marked as un-collectable.

   In order to provide the most appropriate `mark_stack_and_registers'
   function, the very first question is to know about the way the C stack is
   managed (addresses of the stack may increase or decrease as the C stack
   grows). The DEFAULT BEHAVIOUR FOR UNKNOWN SYSTEMS is to consider ADDRESSES
   DECREASE AS THE STACK GROWS, as it's the most common case.  The global C
   variable `stack_bottom' is set with some pointer which is supposed to be
   the bottom of the stack (this variable is automatically initialized in the
   C main function).  Note: using the current stack pointer inside
   `mark_stack_and_registers', it is quite obvious to determine if addresses
   increase or not as the C stack grows.  Note2: on some systems, the stack is
   not in contiguous addresses. In such case, `mark_stack_and_registers' has
   to go through all the stack fragments.

   Some roots may be stored only in registers and not in the C stack.  In
   order to reach the registers as well, the first attempt is to use setjmp,
   in the hope that setjmp will save registers in the stack!  Note: this
   technique do not work on processors using windows registers (such as sparc
   processors).

*/


int se_gc_strategy = SE_GC_DEFAULT_MEMORY_STRATEGY;

int collector_counter = 0;

static void gcna_align_mark(rsoc*c,void*o);
static rsoc*rsocfl=NULL; /* ReSizable Object Chunk Free List. */

void**stack_bottom=NULL;
mch**gcmt=NULL; /* Garbage Collector Main Table. */
int gcmt_max=2048;
int gcmt_used=0;
fsoc*fsocfl=NULL; /* Fixed Size Object Chunk Free List. */
int gc_is_off=1;
unsigned int fsoc_count=0;
unsigned int rsoc_count=0;
void*gcmt_tail_addr=NULL;

static int chunk_rounded(int size) {
  int rounded_size = size;
  int diff = rounded_size%RSOC_SIZE;

  if (diff != 0) rounded_size += (RSOC_SIZE-diff);
  return rounded_size;
}

static void free_and_remove_from_gcmt(mch* c) {
  /* Remove and free the chunk `c' from the
   * gcmt (Garbage Collector Main Table).
   */
  mch**p=(gcmt+gcmt_used-1);
  mch*save=*p;
  mch*save2;
  p--;
  while(save != c) {
    save2 = save;
    save = *p;
    *p = save2;
    p--;
  }
  free(c);
  gcmt_used--;
}

static void may_free_rsocfl(void) {
  /* May free all chunks of `rsocfl' (ReSizable Object Chunk Free List)
     in some circumstances.
  */
  rsoc* next, *current;
  unsigned int count = rsocfl_count();
  if ((count > 50) && (count > (rsoc_count >> 1))) { 
    current=rsocfl;
    rsocfl=NULL;
    while (current != NULL) {
      next=current->next;
      if (current->isize == current->header.size) {
	free_and_remove_from_gcmt(((mch*)current)); 
	rsoc_count--;
      }
      else {
	current->next=rsocfl;
	rsocfl=current;
      }
      current = next;
    }
  }
}

int gc_memory_used(void) {
  int i;
  int result = 0;
  mch* mch;
  for (i = gcmt_used; i --> 0; ) {
    mch = gcmt[i];
    switch(mch->state_type) {
    case RSO_USED_CHUNK:
    case FSO_USED_CHUNK:
    case FSO_STORE_CHUNK:
      result += mch->size;
      break;
    default:
      break;
    }
  }
  return result;
}

void gc_sweep(void) {
  mch** p2 = gcmt;
  mch** p1 = gcmt+1;
  mch**eogcmt=gcmt+gcmt_used;
  if (FREE_CHUNK((*p2)->state_type)) {
    if (RSO_FREE_CHUNK == ((*p2)->state_type)) {
      ((rsoc*)(*p2))->next=NULL;
      rsocfl=((rsoc*)(*p2));
    }
    else {
      rsocfl=NULL;
    }
  }
  else {
    ((*gcmt)->swfp)(*p2);
    if (RSO_FREE_CHUNK==((*p2)->state_type)) {
      ((rsoc*)(*p2))->next=NULL;
      rsocfl=((rsoc*)(*p2));
    }
    else {
      rsocfl=NULL;
    }
  }
  while (p1 < eogcmt) {
    if (FREE_CHUNK((*p1)->state_type)) {
      if (RSO_FREE_CHUNK == ((*p1)->state_type)) {
	if (RSO_FREE_CHUNK == ((*p2)->state_type)) {
	  if (((char*)(*p2))+(*p2)->size == ((char*)(*p1))) {
	    ((*p2)->size)+=((*p1)->size);
	    p1++;
	  }
	  else {
	    ((rsoc*)(*p1))->next=rsocfl;
	    rsocfl=((rsoc*)(*p1));
	    *(p2+1)=*p1; p2++; p1++;
	  }
	}
	else {
	  ((rsoc*)(*p1))->next=rsocfl;
	  rsocfl=((rsoc*)(*p1));
	  *(p2+1)=*p1; p2++; p1++;
	}
      }
      else {
	*(p2+1)=*p1; p2++; p1++;
      }
    }
    else {
      ((*p1)->swfp)(*p1);
      if (RSO_FREE_CHUNK == ((*p1)->state_type)) {
	if (RSO_FREE_CHUNK == ((*p2)->state_type)) {
	  if (((char*)(*p2))+(*p2)->size == ((char*)(*p1))) {
	    ((*p2)->size)+=((*p1)->size);
	    p1++;
	  }
	  else {
	    ((rsoc*)(*p1))->next=rsocfl;
	    rsocfl=((rsoc*)(*p1));
	    *(p2+1)=*p1; p2++; p1++;
	  }
	}
	else {
	  ((rsoc*)(*p1))->next=rsocfl;
	  rsocfl=((rsoc*)(*p1));
	  *(p2+1)=*p1; p2++; p1++;
	}
      }
      else {
	*(p2+1)=*p1; p2++; p1++;
      }
    }
  }
  gcmt_used=(p2-gcmt)+1;
  may_free_rsocfl();
}

/* return the mch containing p or NULL if p is not 
 * a valid address or was externally allocated 
 */
mch * gc_find_chunk(void * p){
  if ((p>((void*)*gcmt))&&(p<=gcmt_tail_addr)) {
    int i1=0;
    int i2=gcmt_used-1;
    int m=i2>>1;
    mch*c;
    for (;i2>i1;m=((i1+i2)>>1)) {
      if (p<=((void*)gcmt[m+1])) {
	i2=m;
      }
      else {
	i1=m+1;
      }
    }
    c=gcmt[i2];
    if((char*)p<(char*)c+c->size)   /* check for upper bound */
      if (!(FREE_CHUNK(c->state_type)))
	return c;
  }
  return NULL;
}

void gc_mark(void*p) {
  mch * c = gc_find_chunk(p);
  if(NULL != c) 
    (c->amfp)(c,p);
}

int gc_stack_size(void) {
  void*stack_top[2]={NULL,NULL};
  if (stack_top > stack_bottom) {
    return ((void**)stack_top)-((void**)stack_bottom);
  }
  else {
    return ((void**)stack_bottom)-((void**)stack_top);
  }
}

/*
  To delay Garbage Collection when the stack is too large.
  To allow fast increase of ceils.
*/
#define FSOC_LIMIT (10240/((FSOC_SIZE)>>10))
#define RSOC_LIMIT (10240/((RSOC_SIZE)>>10))

/*
  When stack is too large, collection may be delayed.
*/
#define GCLARGESTACK 50000

int garbage_delayed(void) {
  /*
    To delay the first GC call.
  */
  if (gc_stack_size() > GCLARGESTACK) {
    if (fsoc_count_ceil <= fsoc_count) {
      if (rsoc_count_ceil <= rsoc_count) {
	if ((fsoc_count<FSOC_LIMIT)&&(rsoc_count<RSOC_LIMIT)) {
	  fsoc_count_ceil++;
	  rsoc_count_ceil++;
	  return 1;
	}
	else return 0;
      }
      else {
	if (fsoc_count<FSOC_LIMIT) {
	  fsoc_count_ceil++;
	  return 1;
	}
	else return 0;
      }
    }
    else {
      if (rsoc_count_ceil <= rsoc_count) {
	if (rsoc_count<RSOC_LIMIT) {
	  rsoc_count_ceil++;
	  return 1;
	}
	else return 0;
      }
      else return 0;
    }
  }
  else {
    return 0;
  }
}

void gc_update_ceils(void) {
  /* This function is automatically called after each collection
     cycle.
  */
  if (se_gc_strategy == SE_GC_LOW_MEMORY_STRATEGY) {
    fsoc_count_ceil = fsoc_count;
    rsoc_count_ceil = rsoc_count;
    /* Todo: we should also consider to free unused chunks here. */
    return;
  }
  if (se_gc_strategy == SE_GC_HIGH_MEMORY_STRATEGY) {
    fsoc_count_ceil = (256 + fsoc_count) << 2;
    rsoc_count_ceil = (256 + rsoc_count) << 2;
    return;
  }
  /* The SE_GC_DEFAULT_MEMORY_STRATEGY. */
  /* Compute fsoc_count_ceil: */
  if (fsocfl == NULL) {
    if (fsoc_count >= fsoc_count_ceil) {
      if (fsoc_count_ceil < FSOC_LIMIT) {
	fsoc_count_ceil <<= 1;
      }
      else {
	unsigned int c = fsoc_count + (fsoc_count/3);
	if (fsoc_count_ceil < c)
	  fsoc_count_ceil = c;
      }
    }
  }
  else {
    if (fsoc_count_ceil < fsoc_count) {
      fsoc_count_ceil = fsoc_count;
    }
  }
  /* Compute rsoc_count_ceil: */
  if (rsocfl == NULL) {
    if (rsoc_count >= rsoc_count_ceil) {
      if (rsoc_count_ceil < RSOC_LIMIT) {
	rsoc_count_ceil <<= 1;
      }
      else {
	unsigned int c = rsoc_count + (rsoc_count / 3);
	if (rsoc_count_ceil < c) {
	  rsoc_count_ceil = c;
	}
      }
    }
  }
  else {
    if (rsoc_count_ceil < rsoc_count) {
      rsoc_count_ceil = rsoc_count;
    }
  }
}

static void gc_add_into_gcmt(mch*c) {
  /* Update the `gcmt' (Garbage Collector Main Table) by adding the
     new `mch' (Memory Chunk Header).
  */
  mch** p;
  if (gcmt_used == gcmt_max) {
    gcmt_max <<= 1;
    gcmt = ((mch**)(se_realloc(gcmt,(gcmt_max+1)*sizeof(void*))));
  }
  for (p=gcmt+(gcmt_used++ -1) ; (p>=gcmt)&&(*p>c) ; p--) {
    *(p+1) = *p;
  }
  *(p+1) = c;
}

static char*rso_from_store(na_env*nae,unsigned int size) {
  rsoh*r=(nae->store);
  nae->store_left-=size;
  if ((nae->store_left) > sizeof(rsoh)) {
    r->header.size=size;
    nae->store=((rsoh*)(((char*)(nae->store))+size));
  }
  else {
    r->header.size=size+nae->store_left;
    nae->store_left=0;
  }
  (r->header.magic_flag)=RSOH_UNMARKED;
  ((void)memset((r+1),0,r->header.size-sizeof(rsoh)));
  return (char*)(r+1);
}

static void rsoc_sweep(rsoc*c) {
  na_env*nae=c->nae;
  rsoh*gp=(rsoh*)&(c->first_header);
  rsoh*pp;
  rsoh*eoc=((rsoh*)(((char*)c)+c->header.size));
  c->free_list_of_large=NULL;
  if (c->header.size > RSOC_SIZE) {
    if (gp->header.magic_flag == RSOH_MARKED) {
      gp->header.magic_flag=RSOH_UNMARKED;
      c->next=nae->chunk_list;
      nae->chunk_list=c;
    }
    else {
      c->header.state_type=RSO_FREE_CHUNK;
    }
    return;
  }
  while (gp<eoc) {
    while (gp->header.magic_flag == RSOH_MARKED) {
      gp->header.magic_flag=RSOH_UNMARKED;
      gp=((rsoh*)(((char*)gp)+gp->header.size));
      if(gp>=eoc) {
	c->next=nae->chunk_list;
	nae->chunk_list=c;
	return;
      }
    }
    gp->header.magic_flag=RSOH_FREE;
    pp=(rsoh*)(((char*)gp)+gp->header.size);
    while ((pp<eoc)&&(pp->header.magic_flag != RSOH_MARKED)) {
      pp->header.magic_flag=RSOH_FREE;
      gp->header.size+=pp->header.size;
      pp=((rsoh*)(((char*)pp)+pp->header.size));
    }
    if (gp->header.size >= RSOC_MIN_STORE) {
      if (nae->store_left==0) {
	nae->store_left=gp->header.size;
	nae->store=gp;
	nae->store_chunk=c;
      }
      else if (nae->store->header.size < gp->header.size) {
	((fll_rsoh*)nae->store)->nextflol=nae->store_chunk->free_list_of_large;
	nae->store_chunk->free_list_of_large=((fll_rsoh*)nae->store);
	nae->store_left=gp->header.size;
	nae->store=gp;
	nae->store_chunk=c;
      }
      else {
	((fll_rsoh*)gp)->nextflol=c->free_list_of_large;
	c->free_list_of_large=((fll_rsoh*)gp);
      }
    }
    gp=pp;
  }
  if (((rsoh*)(&c->first_header))->header.size >=
      (c->header.size-sizeof(rsoc)+sizeof(rsoh))){
    c->header.state_type=RSO_FREE_CHUNK;
    nae->store_chunk=NULL;
    nae->store_left=0;
  }
  else{
    c->next=nae->chunk_list;
    nae->chunk_list=c;
  }
}

static const rsoc MRSOC = {
    {
	RSOC_SIZE,
	RSO_USED_CHUNK,
	((void(*)(mch*,void*))gcna_align_mark),
	((void(*)(mch*))rsoc_sweep)
    },
    0,
    NULL,
    NULL,
    NULL,
    {
      {
	0,
	RSOH_MARKED
      }
    }
};

static void rsoc_malloc(na_env*nae) {
  rsoc* r = ((rsoc*)(se_malloc(RSOC_SIZE)));
  rsoc_count++;
  *r=MRSOC;
  r->nae=nae;
  r->isize=RSOC_SIZE;
  nae->store=(&(r->first_header));
  nae->store_left=RSOC_SIZE-sizeof(rsoc)+sizeof(rsoh);
  nae->store_chunk=r;
  r->next=nae->chunk_list;
  nae->chunk_list=r;
  gc_add_into_gcmt((mch*)r);
}

static rsoc* rsocfl_best_fit(unsigned int size) {
  unsigned int best_size = 0;
  rsoc *pc,*best_pc,*best_c, *c;
  if (rsocfl==NULL)
    return NULL;
  pc=NULL;
  best_pc=NULL;
  best_c=NULL;
  c=rsocfl;
  while ((NULL!=c)&&(NULL==best_c)){
    if (c->header.size>=size){
      best_c=c;
      best_pc=pc;
      best_size=c->header.size;
    }
    pc=c;
    c=c->next;
  }
  if (NULL==c){
    if (best_pc != NULL)
      best_pc->next=best_c->next;
    else if (best_c==rsocfl)
      rsocfl=best_c->next;
    return best_c;
  }
  do {
    if ((c->header.size >= size) && (c->header.size < best_size)) {
      best_c = c;
      best_pc = pc;
      best_size = c->header.size;
    }
    pc=c;
    c=c->next;
  }
  while(c!=NULL);
  if (NULL==best_pc) {
    rsocfl = best_c->next;
  }
  else {
    best_pc->next=best_c->next;
  }
  return best_c;
}

static int get_store_in(rsoc*c,unsigned int size) {
  na_env*nae=c->nae;
  fll_rsoh*pf=NULL;
  fll_rsoh*f=c->free_list_of_large;
  while (f != NULL) {
    if (f->rsoh_field.size >= size) {
      nae->store_left=f->rsoh_field.size;
      nae->store=(rsoh*)f;
      nae->store_chunk=c;
      if (pf == NULL) {
	c->free_list_of_large=f->nextflol;
      }
      else {
	pf->nextflol=f->nextflol;
      }
      return 1;
    }
    pf = f;
    f = f->nextflol;
  }
  return 0;
}

char*new_na_from_chunk_list(na_env*nae,unsigned int size) {
  rsoc*c=nae->chunk_list;
  unsigned int csize;
  while (c != NULL) {
    if (get_store_in(c,size)) {
      return rso_from_store(nae,size);
    }
    c = c->next;
  }
  csize=size+(sizeof(rsoc)-sizeof(rsoh));
  c=rsocfl_best_fit(csize);
  if (c != NULL){
    if ((c->header.size > RSOC_SIZE)
	&&
	(c->header.size-csize > RSOC_MIN_STORE*4)) {
      int csize_left=c->header.size-csize;
      if ((csize_left%sizeof(double))!=0) {
	csize_left-=(csize_left%sizeof(double));
	csize=c->header.size-csize_left;
      }
      c->header.size=csize_left;
      c->next=rsocfl;
      rsocfl=c;
      c=(rsoc*)(((char*)c)+csize_left);
      gc_add_into_gcmt((mch*)c);
      c->header.amfp=(void(*)(mch*,void*))gcna_align_mark;
      c->header.swfp=(void(*)(mch*))rsoc_sweep;
    }
    else {
      csize=c->header.size;
    }
    c->header.size=csize;
    c->header.state_type=RSO_USED_CHUNK;
    c->free_list_of_large=NULL;
    c->nae=nae;
    nae->store=(&(c->first_header));
    nae->store_left=csize-sizeof(rsoc)+sizeof(rsoh);
    nae->store_chunk=c;
    c->next=nae->chunk_list;
    nae->chunk_list=c;
    return rso_from_store(nae,size);
  }
  return NULL;
}

char*new_na(na_env*nae,unsigned int size) {
  if (nae->store_left>0) {
    nae->store->header.size=nae->store_left;
    nae->store->header.magic_flag=RSOH_FREE;
    if (nae->store_left >= RSOC_MIN_STORE) {
      ((fll_rsoh*)(nae->store))->nextflol=nae->store_chunk->free_list_of_large;
      nae->store_chunk->free_list_of_large=((fll_rsoh*)nae->store);
    }
    nae->store_left=0;
  }
  if ((nae->store_chunk!=NULL)&&(get_store_in(nae->store_chunk,size))) {
    return rso_from_store(nae,size);
  }
  {
    char*r=new_na_from_chunk_list(nae,size);
    if (r!=NULL)
      return r;
  }
  if (rsoc_count<rsoc_count_ceil) {
    if((size+sizeof(rsoc)-sizeof(rsoh))>RSOC_SIZE){
      rsoc*c;
      rsoh*r;
      unsigned int rounded_size= chunk_rounded(size+sizeof(rsoc)-sizeof(rsoh));
      c=((rsoc*)(se_malloc(rounded_size)));
      r=(&(c->first_header));
      rsoc_count++;
      *c=MRSOC;
      c->isize = rounded_size;
      c->header.size=rounded_size;
      c->nae=nae;
      c->next=nae->chunk_list;
      nae->chunk_list=c;
      gc_add_into_gcmt((mch*)c);
      r->header.size=size;
      (r->header.magic_flag)=RSOH_UNMARKED;
      ((void)memset((r+1),0,size-sizeof(rsoh)));
      return (char*)(r+1);
    }
    else {
      rsoc_malloc(nae);
      return rso_from_store(nae,size);
    }
  }
  gc_start();
  if (size<=(nae->store_left)) {
    return rso_from_store(nae,size);
  }
  {
    char*r=new_na_from_chunk_list(nae,size);
    if (r!=NULL) {
      return r;
    }
  }
  if((size+sizeof(rsoc)-sizeof(rsoh))>RSOC_SIZE){
    rsoc*c;
    rsoh*r;
    unsigned int rounded_size = chunk_rounded(size+sizeof(rsoc)-sizeof(rsoh));
    c=((rsoc*)(se_malloc(rounded_size)));
    r=(&(c->first_header));
    rsoc_count++;
    *c=MRSOC;
    c->isize = rounded_size;
    c->header.size=rounded_size;
    c->nae=nae;
    c->next=nae->chunk_list;
    nae->chunk_list=c;
    gc_add_into_gcmt((mch*)c);
    r->header.size=size;
    (r->header.magic_flag)=RSOH_UNMARKED;
    ((void)memset((r+1),0,size-sizeof(rsoh)));
    gc_update_ceils();
    return (char*)(r+1);
  }
  else {
    rsoc_malloc(nae);
    gc_update_ceils();
    return rso_from_store(nae,size);
  }
}

static void gcna_align_mark(rsoc*c,void*o) {
  na_env* nae = c->nae;
  fll_rsoh* f;
  fll_rsoh* pf;
  char* b = (char*)&(c->first_header);

  /* properly aligned ? */
  if (((((char*)o)-((char*)c))%sizeof(int)) != 0) {
      return;
  }
  /* already marked ? */
  if ((((rsoh*)o)-1)->header.magic_flag != RSOH_UNMARKED) {
      return;
  }
  if (((char*)o) < ((char*)(c+1))) {
      return;
  }
  /* a large chunck ? */
  if (c->header.size > RSOC_SIZE) {
      if (o == (c+1)) {
	nae->gc_mark((T0*)o);
      }
      return;
  }
  pf=NULL;
  f=c->free_list_of_large;
  while ((f != NULL) && (f < ((fll_rsoh*)o))) {
      pf=f;
      f=f->nextflol;
  }
  if (pf == NULL) {
      pf=(fll_rsoh*)b;
  }
  while ((((rsoh*)pf)+1) < (rsoh*)o) {
      pf = ((fll_rsoh*)(((char*)pf)+pf->rsoh_field.size));
  }
  if (o == (((rsoh*)pf)+1)) {
    nae->gc_mark((T0*)o);
  }
}

unsigned int rsocfl_count(void) {
  /* Returns the number of items in the ReSizable Object Free List.
  */
  unsigned int r=0;
  rsoc*p=rsocfl;
  while (p!=NULL) {
    r++;
    p=p->next;
  }
  return r;
}

unsigned int fsocfl_count(void) {
  unsigned int r=0;
  fsoc*p=fsocfl;
  while (p!=NULL) {
    r++;
    p=p->next;
  }
  return r;
}

void gc_dispose_before_exit(void) {
  mch** p = gcmt;
  mch**eogcmt=gcmt+gcmt_used;

  while (p < eogcmt) {
    if (((*p)->state_type == FSO_STORE_CHUNK) ||
	((*p)->state_type == FSO_USED_CHUNK)) {
      ((*p)->swfp)(*p);
    }
    p++;
  }
}

fsoc* gc_fsoc_get1(void) {
  /* Get a `fsoc' (Fixed Size Object Chunk) from the free fsoc list or
     allocate a new one (using `se_malloc') only when the ceil is not
     yet reached. Otherwise, call the `gc_start()' function and
     return NULL.
  */
  fsoc* result;
  if (fsocfl != NULL) {
    result = fsocfl;
    fsocfl = fsocfl->next;
    return result;
  }
  else if (fsoc_count_ceil > fsoc_count) {
    result = ((fsoc*)se_malloc(FSOC_SIZE));
    fsoc_count++;
    gc_add_into_gcmt((mch*)result);
    return result;
  }
  else {
    gc_start();
    return NULL;
  }
}

fsoc* gc_fsoc_get2(void) {
  /* Get a `fsoc' (Fixed Size Object Chunk) or force the allocation of a
     new `fsoc' (using the `se_malloc' function). Update various ceils
     accordingly.
  */
  fsoc* result;
  if (fsocfl != NULL) {
    result = fsocfl;
    fsocfl=fsocfl->next;
    return result;
  }
  else {
    result = ((fsoc*)(se_malloc(FSOC_SIZE)));
    fsoc_count++;
    gc_update_ceils();
    gc_add_into_gcmt((mch*)result);
    return result;
  }
}

#if defined(__sparc__) || defined(sparc) || defined(__sparc)
/* For SPARC architecture.
   As this part contains assembly code (asm), you must not use
   the flag -ansi of gcc compiler.
*/

void mark_loop(void) {
  void** max = stack_bottom;
  void** stack_pointer;
  void* stack_top[2]={NULL,NULL};
  stack_pointer = stack_top;
  /* Addresses decrease as the stack grows. */
  while (stack_pointer <= max) {
    gc_mark(*(stack_pointer++));
  }
}

void mark_stack_and_registers(void) {
#  if defined(__sparcv9)
  asm(" flushw");
#  else
  asm(" ta      0x3   ! ST_FLUSH_WINDOWS");
#  endif
  mark_loop();
}

#elif defined(__ELATE__) || defined(ELATE)
/* GNU Eiffel's VP (Virtual Processor) garbage collector for Elate.
   (c) 2000 Rudi Chiarito <rudi@amiga.com>

   Thanks to Andy Stout and Kevin Croombs at Tao Group for their
   precious help!

   ChangeLog:
   - 2000-06-12 Rudi Chiarito <rudi@amiga.com>
     * Version 1.0
   - 2001-01-01 Joseph Kiniry <kiniry@acm.org>
     * Integrated with new SE 0.75b
   - 2001-08-10 Rudi Chiarito <rudi@amiga.com>
     * Inlined and optimised range marking
     * Added some more comments
     * Added conditional breakpoint in mark_stack_and_registers
   - 2002-09-21 Rudi Chiarito <rudi@amiga.com>
     * Removed redundant 'ret'
*/

__inline__ void mark_stack_and_registers(void)
{

  void *pointer_to_gc_mark = &gc_mark;

  __asm__ __volatile__
  (
    /*
      WARNING: funky code ahead!
      \t and \n are needed to make the final output easier to read
      while debugging. Hopefully you'll never have to bother with all
      of this.

      Registers:
        p0  pointer to stack block
        p1  pointer to gc_mark()
        p2  scratch pointer
        i0  length of current stack block
        i1  scratch register
    */

#  ifdef __ELATE_SE_DEBUG_GC
   "\tqcall sys/cii/breakpt,(-:-)\n"
#  endif

   "\tsync\n"                          /* spill all the registers */
   "\tsyncreg\n"                       /* to the stack */

   "\tcpy.p %0,p1\n"                   /* pointer to gc_mark() */

   /* pointer to the current stack block */
   "\tcpy.p [gp+PROC_STACK],p0\n"

   /* point to last location in the block, before the descriptor */
   "\tcpy.p p0 + ([(p0 - STK_SIZE) + STK_LENGTH] - STK_SIZE - 4),p2\n"

   /* mark the contents of the current stack block */
   "\twhile p2>=sp\n"
      "\t\tgos p1,(p2 : -)\n"
      "\t\tsub.p 4,p2\n"
   "\tendwhile\n"

   /* now scan other blocks (if any) */

   "\tloop\n"
      "\t\tcpy.p [p0 - STK_SIZE + STK_LINK],p0\n" /* get next block */
      "\t\tbreakif p0=NULL\n"

      /* point to last location in the block, before the descriptor */
      "\t\tcpy.p p0 + ([(p0 - STK_SIZE) + STK_LENGTH] - STK_SIZE - 4),p2\n"

      /* mark this block */
      "\t\twhile p2>=p0\n"

         "\t\t\tgos p1,(p2 : -)\n"
         "\t\t\tsub.p 4,p2\n"
      "\t\tendwhile\n"
   "\tendloop\n"

   : /* no output */
   : "p" (pointer_to_gc_mark)
   : "p0", "p1", "p2", "i0" 
   );
}

#elif defined(__hppa__) || defined(__hppa) || defined(__hp9000) || \
      defined(__hp9000s300) || defined(hp9000s300) || \
      defined(__hp9000s700) || defined(hp9000s700) || \
      defined(__hp9000s800) || defined(hp9000s800) || defined(hp9000s820)

/****************************************************************************
 * Generic code for architectures where addresses increase as the stack grows.
 ****************************************************************************/

void mark_stack_and_registers(void){
  void** max = stack_bottom;
  JMP_BUF registers;   /* The jmp_buf buffer is in the C stack. */
  void**stack_pointer; /* Used to traverse the stack and registers assuming
			  that `setjmp' will save registers in the C stack.
		       */

  (void)SETJMP(registers);  /* To fill the C stack with registers. */
  stack_pointer = (void**)(&registers) + ((sizeof(JMP_BUF)/sizeof(void*))-1);
  /* stack_pointer will traverse the JMP_BUF as well (jmp_buf size is added, 
     otherwise stack_pointer would be below the registers structure). */

#  if !defined(SE_BOOST)
  if (stack_pointer < max) {
    fprintf(stderr, "Wrong stack direction: your stack decrease as the stack grows (or complex stack management). Please drop an e-mail to SmartEiffel@loria.fr\n");
    exit(1); }
#  endif

  while (stack_pointer >= max) {
    gc_mark(*(stack_pointer--));
  }
}
#else

/****************************************************************************
 * Generic code for architectures where addresses decrease as the stack grows.
 ****************************************************************************/

void mark_stack_and_registers(void){
  void** max = stack_bottom;
  JMP_BUF registers;   /* The jmp_buf buffer is in the C stack. */
  void**stack_pointer; /* Used to traverse the stack and registers assuming
			  that `setjmp' will save registers in the C stack.
		       */

  (void)SETJMP(registers);  /* To fill the C stack with registers. */
  stack_pointer = (void**)(&registers);

#  if !defined(SE_BOOST)
  if (stack_pointer > max) {
    fprintf(stderr, "Wrong stack direction: the stack addresses increase as the stack grows (or complex stack management). Please drop an e-mail to SmartEiffel@loria.fr\n");
    exit(1); }
#  endif

  while (stack_pointer <= max) {
    gc_mark(*(stack_pointer++));
  }
}
#endif

/*
-- This file is  free  software, which  comes  along  with  SmartEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of
-- another product.
--       Copyright (C) 1994-2002 LORIA - INRIA - U.H.P. Nancy 1 - FRANCE
--          Dominique COLNET and Suzanne COLLIN - SmartEiffel@loria.fr
--                       http://SmartEiffel.loria.fr
--
*/
/*
  This file (SmartEiffel/sys/runtime/basic_io.c) is automatically
  included when some external "SmartEiffel" basic_io_* feature is used.
*/

#if defined __USE_POSIX || defined __unix__ || defined _POSIX_C_SOURCE
/* macro read is used of basic_io_read_stdin */
#else
int basic_io_read_stdin(char *buffer, int size) {
  int c;
  c = getc(stdin);
  if (c==EOF)
    return 0;
  *buffer = (char)c;
  return 1;
}
#endif

unsigned int fsoc_count_ceil=76;
unsigned int rsoc_count_ceil=12;

/*BOOLEAN*/
T6 r6_ix_and(se_dump_stack*caller,T6 C,T6 a1){
T6 R=0;
void**locals[2];
static se_frame_descriptor fd={"infix and BOOLEAN",1,2,"%E6%other%E6%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x00C02008/*l32c4/boolean.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x00C02714/*l39c10/boolean.e*/);
R=((T6)((T6)((C)&&((T6)(a1)))));
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*BOOLEAN*/
T6 r6_ix_xor(se_dump_stack*caller,T6 C,T6 a1){
T6 R=0;
void**locals[2];
static se_frame_descriptor fd={"infix xor BOOLEAN",1,2,"%E6%other%E6%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x00C04308/*l67c4/boolean.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x00C04606/*l70c3/boolean.e*/);
R=((T6)((C)!=(a1)));
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*BOOLEAN*/
T6 r6_px_not(se_dump_stack*caller,T6 C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"prefix not BOOLEAN",1,1,"%E6%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x00C04918/*l73c12/boolean.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x00C04C06/*l76c3/boolean.e*/);
R=((T6)((C)==(0)));
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*BOOLEAN*/
T6 r6_ix_or(se_dump_stack*caller,T6 C,T6 a1){
T6 R=0;
void**locals[2];
static se_frame_descriptor fd={"infix or BOOLEAN",1,2,"%E6%other%E6%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x00C03408/*l52c4/boolean.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x00C03B14/*l59c10/boolean.e*/);
R=((T6)((T6)((C)||((T6)(a1)))));
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*CHARACTER*/
T6 r3is_default(se_dump_stack*caller,T3 C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"is_default GENERAL",1,1,"%E3%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x01E10F08/*l271c4/general.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x01E11806/*l280c3/general.e*/);
R=((T6)((C)==(r3default(&ds))));
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*CHARACTER*/
T6 r3is_digit(se_dump_stack*caller,T3 C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"is_digit CHARACTER",1,1,"%E3%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x0060B208/*l178c4/character.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
/*[IF*/
if(((ds.p=0x0060B524/*l181c18/character.e*/),r3_ix_6261(&ds,(/*RF2*/C),((T3)'0')))){
(ds.p=0x0060B61A/*l182c13/character.e*/);
R=((T6)(r3_ix_6061(&ds,(/*RF2*/C),((T3)'9'))));
}
/*FI]*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x0060B920/*l185c16/character.e*/);
ac_ens((R)==(r3in_range(&ds,C,((T3)'0'),((T3)'9'))),NULL);
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*CHARACTER*/
T6 r3in_range(se_dump_stack*caller,T3 C,T3 a1,T3 a2){
T6 R=0;
void**locals[3];
static se_frame_descriptor fd={"in_range COMPARABLE",1,3,"%E3%lower%E3%upper%E3%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x02E04B08/*l75c4/comparable.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x02E04E14/*l78c10/comparable.e*/);
R=((T6)((T6)((r3_ix_6261(&ds,C,a1))&&((T6)(r3_ix_6061(&ds,C,a2))))));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02E05022/*l80c17/comparable.e*/);
ac_ens((R)==(r6_ix_and(&ds,(T6)(r3_ix_6261(&ds,C,a1)),(T6)(r3_ix_6061(&ds,C,a2)))),NULL);
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*CHARACTER*/
T6 r3_ix_6061(se_dump_stack*caller,T3 C,T3 a1){
T6 R=0;
void**locals[2];
static se_frame_descriptor fd={"infix <= CHARACTER",1,2,"%E3%other%E3%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x00603908/*l57c4/character.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02E0303C/*l48c30/comparable.e*/);
ac_req((/*exp-void-cmp*/1),"other_exists");
fd.assertion_flag=1;
}
(ds.p=0x00603C14/*l60c10/character.e*/);
R=((T6)((int16_t)((T3code(C))<=(T3code(a1)))));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02E0343A/*l52c29/comparable.e*/);
ac_ens((R)==(r6_ix_or(&ds,(T6)(r3_ix_60(&ds,C,a1)),(T6)((C)==(a1)))),"definition");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*CHARACTER*/
T1 r3value(se_dump_stack*caller,T3 C){
T1 R=0;
void**locals[1];
static se_frame_descriptor fd={"value CHARACTER",1,1,"%E3%Result%E1%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x00604B08/*l75c4/character.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x00604E14/*l78c10/character.e*/);
ac_req(r3is_digit(&ds,C),NULL);
fd.assertion_flag=1;
}
(ds.p=0x00605014/*l80c10/character.e*/);
R=r1_ix_45(&ds,r10to_integer_8(&ds,T3code(C)),INT8_C(48));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x00605222/*l82c17/character.e*/);
ac_ens(r1in_range(&ds,R,INT8_C(0),INT8_C(9)),NULL);
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*CHARACTER*/
T6 r3_ix_6261(se_dump_stack*caller,T3 C,T3 a1){
T6 R=0;
void**locals[2];
static se_frame_descriptor fd={"infix >= CHARACTER",1,2,"%E3%other%E3%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x00604508/*l69c4/character.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02E0443C/*l68c30/comparable.e*/);
ac_req((/*exp-void-cmp*/1),"other_exists");
fd.assertion_flag=1;
}
(ds.p=0x00604814/*l72c10/character.e*/);
R=((T6)((int16_t)((T3code(C))>=(T3code(a1)))));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02E0483A/*l72c29/comparable.e*/);
ac_ens((R)==(r3_ix_6061(&ds,a1,C)),"definition");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*CHARACTER*/
T3 r3default(se_dump_stack*caller){
T3 R=0;
void**locals[1];
static se_frame_descriptor fd={"default GENERAL",0,1,"Result%E3%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=NULL;
ds.p=0x01E10816/*l264c11/general.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*CHARACTER*/
T6 r3_ix_60(se_dump_stack*caller,T3 C,T3 a1){
T6 R=0;
void**locals[2];
static se_frame_descriptor fd={"infix < CHARACTER",1,2,"%E3%other%E3%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x00603308/*l51c4/character.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02E0273C/*l39c30/comparable.e*/);
ac_req((/*exp-void-cmp*/1),"other_exists");
fd.assertion_flag=1;
}
(ds.p=0x00603614/*l54c10/character.e*/);
R=((T6)((int16_t)((T3code(C))<(T3code(a1)))));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02E02A3A/*l42c29/comparable.e*/);
ac_ens((T6)((!(R))||((T6)(r6_px_not(&ds,(T6)(r3_ix_60(&ds,a1,C)))))),"asymmetric");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*INTEGER_8*/
T6 r1is_equal(se_dump_stack*caller,T1 C,T1 a1){
T6 R=0;
void**locals[2];
static se_frame_descriptor fd={"is_equal INTEGER_GENERAL",1,2,"%E1%other%E1%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x03232A08/*l810c4/integer_general.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x01E07720/*l119c16/general.e*/);
ac_req((/*exp-void-cmp*/1),NULL);
fd.assertion_flag=1;
}
(ds.p=0x03232C06/*l812c3/integer_general.e*/);
R=((T6)((r1to_integer_64(&ds,(/*RF2*/a1)))==(r1to_integer_64(&ds,(/*RF2*/C)))));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x01E07A64/*l122c50/general.e*/);
ac_ens((T6)((!(((T0*)(t[1]))==((void*)((T0*)(t[1])))))||((T6)((R)==(r1is_equal(&ds,a1,C))))),NULL);
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*INTEGER_8*/
T6 r1in_range(se_dump_stack*caller,T1 C,T1 a1,T1 a2){
T6 R=0;
void**locals[3];
static se_frame_descriptor fd={"in_range COMPARABLE",1,3,"%E1%lower%E1%upper%E1%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x02E04B08/*l75c4/comparable.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x02E04E14/*l78c10/comparable.e*/);
R=((T6)((T6)(((int8_t)((C)>=(a1)))&&((T6)((int8_t)((C)<=(a2)))))));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02E05022/*l80c17/comparable.e*/);
ac_ens((R)==(r6_ix_and(&ds,(T6)((int8_t)((C)>=(a1))),(T6)((int8_t)((C)<=(a2))))),NULL);
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*INTEGER_8*/
T1 r1_ix_45(se_dump_stack*caller,T1 C,T1 a1){
T1 R=0;
void**locals[2];
static se_frame_descriptor fd={"infix - INTEGER_GENERAL",1,2,"%E1%other%E1%Result%E1%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x03203C08/*l60c4/integer_general.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03203E5A/*l62c45/integer_general.e*/);
ac_req((T6)((!(((int8_t)(((/*RF2*/C))>(INT8_C(0))))!=((int8_t)(((/*RF2*/a1))>(INT8_C(0))))))||((T6)(((int8_t)(((int8_t)((C)-(a1)))>(INT8_C(0))))==((int8_t)(((/*RF2*/C))>(INT8_C(0))))))),"no_overflow");
fd.assertion_flag=1;
}
(ds.p=0x03204206/*l66c3/integer_general.e*/);
R=(int8_t)(((/*RF2*/C))-(a1));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03204430/*l68c24/integer_general.e*/);
ac_ens(((int8_t)((R)+((/*RF2*/a1))))==((/*RF2*/C)),NULL);
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*INTEGER_8*/
T11 r1to_integer_64(se_dump_stack*caller,T1 C){
T11 R=0;
void**locals[1];
static se_frame_descriptor fd={"to_integer_64 INTEGER_GENERAL",1,1,"%E1%Result%E11%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x03213708/*l311c4/integer_general.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x03213A06/*l314c3/integer_general.e*/);
R=/*IC*/(T11)(C);
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03213C16/*l316c11/integer_general.e*/);
ac_ens(r11is_equal(&ds,/*IC*/(T11)(C),R),NULL);
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*INTEGER*/
T6 r2is_default(se_dump_stack*caller,T2 C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"is_default GENERAL",1,1,"%E2%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x01E10F08/*l271c4/general.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x01E11806/*l280c3/general.e*/);
R=((T6)((C)==(r2default(&ds))));
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*INTEGER*/
T6 r2is_equal(se_dump_stack*caller,T2 C,T2 a1){
T6 R=0;
void**locals[2];
static se_frame_descriptor fd={"is_equal INTEGER_GENERAL",1,2,"%E2%other%E2%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x03232A08/*l810c4/integer_general.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x01E07720/*l119c16/general.e*/);
ac_req((/*exp-void-cmp*/1),NULL);
fd.assertion_flag=1;
}
(ds.p=0x03232C06/*l812c3/integer_general.e*/);
R=((T6)((r2to_integer_64(&ds,(/*RF2*/a1)))==(r2to_integer_64(&ds,(/*RF2*/C)))));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x01E07A64/*l122c50/general.e*/);
ac_ens((T6)((!(((T0*)(t[2]))==((void*)((T0*)(t[2])))))||((T6)((R)==(r2is_equal(&ds,a1,C))))),NULL);
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*INTEGER*/
T2 r2max(se_dump_stack*caller,T2 C,T2 a1){
T2 R=0;
void**locals[2];
static se_frame_descriptor fd={"max COMPARABLE",1,2,"%E2%other%E2%Result%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x02E07308/*l115c4/comparable.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02E07620/*l118c16/comparable.e*/);
ac_req((/*exp-void-cmp*/1),NULL);
fd.assertion_flag=1;
}
/*[IF*/
if(((ds.p=0x02E0782A/*l120c21/comparable.e*/),(int32_t)((C)>=(a1)))){
(ds.p=0x02E0791A/*l121c13/comparable.e*/);
R=C;
}
else{
(ds.p=0x02E07B1A/*l123c13/comparable.e*/);
R=a1;
}
/*FI]*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02E07E38/*l126c28/comparable.e*/);
ac_ens((T6)(((int32_t)((R)>=(C)))&&((T6)((int32_t)((R)>=(a1))))),NULL);
(ds.p=0x02E07F3C/*l127c30/comparable.e*/);
ac_ens((T6)(((r2compare(&ds,C,R))==(INT8_C(0)))||((T6)((r2compare(&ds,a1,R))==(INT8_C(0))))),NULL);
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*INTEGER*/
T6 r2divisible(se_dump_stack*caller,T2 a1){
T6 R=0;
void**locals[2];
static se_frame_descriptor fd={"divisible INTEGER_GENERAL",0,2,"other%E2%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=NULL;
ds.p=0x03232508/*l805c4/integer_general.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03404620/*l70c16/numeric.e*/);
ac_req((/*exp-void-cmp*/1),NULL);
fd.assertion_flag=1;
}
(ds.p=0x03232714/*l807c10/integer_general.e*/);
R=((T6)(((/*RF2*/a1))!=(INT8_C(0))));
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*INTEGER*/
T2 r2min(se_dump_stack*caller,T2 C,T2 a1){
T2 R=0;
void**locals[2];
static se_frame_descriptor fd={"min COMPARABLE",1,2,"%E2%other%E2%Result%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x02E06408/*l100c4/comparable.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02E06720/*l103c16/comparable.e*/);
ac_req((/*exp-void-cmp*/1),NULL);
fd.assertion_flag=1;
}
/*[IF*/
if(((ds.p=0x02E0692A/*l105c21/comparable.e*/),(int32_t)((C)<=(a1)))){
(ds.p=0x02E06A1A/*l106c13/comparable.e*/);
R=C;
}
else{
(ds.p=0x02E06C1A/*l108c13/comparable.e*/);
R=a1;
}
/*FI]*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02E06F38/*l111c28/comparable.e*/);
ac_ens((T6)(((int32_t)((R)<=(C)))&&((T6)((int32_t)((R)<=(a1))))),NULL);
(ds.p=0x02E0703C/*l112c30/comparable.e*/);
ac_ens((T6)(((r2compare(&ds,C,R))==(INT8_C(0)))||((T6)((r2compare(&ds,a1,R))==(INT8_C(0))))),NULL);
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*INTEGER*/
T2 r2compare(se_dump_stack*caller,T2 C,T2 a1){
T2 R=0;
void**locals[2];
static se_frame_descriptor fd={"compare COMPARABLE",1,2,"%E2%other%E2%Result%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x02E05308/*l83c4/comparable.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02E0573C/*l87c30/comparable.e*/);
ac_req((/*exp-void-cmp*/1),"other_exists");
fd.assertion_flag=1;
}
/*[IF*/
if(((ds.p=0x02E0592A/*l89c21/comparable.e*/),(int32_t)((C)<(a1)))){
(ds.p=0x02E05A1A/*l90c13/comparable.e*/);
R=INT8_C(-1);
}
 else if(((ds.p=0x02E05B2E/*l91c23/comparable.e*/),(int32_t)((a1)<(C)))){
(ds.p=0x02E05C1A/*l92c13/comparable.e*/);
R=INT8_C(1);
}
/*FI]*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02E05F54/*l95c42/comparable.e*/);
ac_ens(((R)==(INT8_C(0)))==(r2is_equal(&ds,C,a1)),"equal_zero");
(ds.p=0x02E06054/*l96c42/comparable.e*/);
ac_ens(((R)==(INT8_C(-1)))==((int32_t)((C)<(a1))),"smaller_negative");
(ds.p=0x02E06154/*l97c42/comparable.e*/);
ac_ens(((R)==(INT8_C(1)))==((int32_t)((C)>(a1))),"greater_positive");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*INTEGER*/
T2 r2_ix_42(se_dump_stack*caller,T2 C,T2 a1){
T2 R=0;
void**locals[2];
static se_frame_descriptor fd={"infix * INTEGER_GENERAL",1,2,"%E2%other%E2%Result%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x03204708/*l71c4/integer_general.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03204942/*l73c33/integer_general.e*/);
ac_req((T6)((!(r2divisible(&ds,a1)))||((T6)(((int32_t)(((int32_t)(((/*RF2*/C))*((/*RF2*/a1))))/((/*RF2*/a1))))==((/*RF2*/C))))),"no_overflow");
fd.assertion_flag=1;
}
(ds.p=0x03204B06/*l75c3/integer_general.e*/);
R=(int32_t)(((/*RF2*/C))*(a1));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03204D42/*l77c33/integer_general.e*/);
ac_ens((T6)((!(r6_ix_and(&ds,(T6)(((/*RF2*/C))!=(INT8_C(0))),(T6)(((/*RF2*/a1))!=(INT8_C(0))))))||((T6)((R)!=(INT8_C(0))))),NULL);
(ds.p=0x03204E1E/*l78c15/integer_general.e*/);
ac_ens((T6)((!((R)!=(INT8_C(0))))||((T6)(((int32_t)((R)/((/*RF2*/a1))))==((/*RF2*/C))))),NULL);
(ds.p=0x03204F1E/*l79c15/integer_general.e*/);
ac_ens((T6)((!((R)!=(INT8_C(0))))||((T6)(((int32_t)((R)%((/*RF2*/a1))))==(INT8_C(0))))),NULL);
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*INTEGER*/
T2 r2_ix_43(se_dump_stack*caller,T2 C,T2 a1){
T2 R=0;
void**locals[2];
static se_frame_descriptor fd={"infix + INTEGER_GENERAL",1,2,"%E2%other%E2%Result%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x03203108/*l49c4/integer_general.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03203358/*l51c44/integer_general.e*/);
ac_req((T6)((!(((int32_t)(((/*RF2*/C))>(/*IC*/(T2)(INT8_C(0)))))==((int32_t)(((/*RF2*/a1))>(/*IC*/(T2)(INT8_C(0)))))))||((T6)(((int32_t)(((int32_t)((C)+(a1)))>(/*IC*/(T2)(INT8_C(0)))))==((int32_t)(((/*RF2*/C))>(/*IC*/(T2)(INT8_C(0)))))))),"no_overflow");
fd.assertion_flag=1;
}
(ds.p=0x03203706/*l55c3/integer_general.e*/);
R=(int32_t)(((/*RF2*/C))+(a1));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03203930/*l57c24/integer_general.e*/);
ac_ens(((int32_t)((R)-((/*RF2*/a1))))==((/*RF2*/C)),NULL);
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*INTEGER*/
T2 r2_ix_45(se_dump_stack*caller,T2 C,T2 a1){
T2 R=0;
void**locals[2];
static se_frame_descriptor fd={"infix - INTEGER_GENERAL",1,2,"%E2%other%E2%Result%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x03203C08/*l60c4/integer_general.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03203E5A/*l62c45/integer_general.e*/);
ac_req((T6)((!(((int32_t)(((/*RF2*/C))>(/*IC*/(T2)(INT8_C(0)))))!=((int32_t)(((/*RF2*/a1))>(/*IC*/(T2)(INT8_C(0)))))))||((T6)(((int32_t)(((int32_t)((C)-(a1)))>(/*IC*/(T2)(INT8_C(0)))))==((int32_t)(((/*RF2*/C))>(/*IC*/(T2)(INT8_C(0)))))))),"no_overflow");
fd.assertion_flag=1;
}
(ds.p=0x03204206/*l66c3/integer_general.e*/);
R=(int32_t)(((/*RF2*/C))-(a1));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03204430/*l68c24/integer_general.e*/);
ac_ens(((int32_t)((R)+((/*RF2*/a1))))==((/*RF2*/C)),NULL);
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*INTEGER*/
T2 r2default(se_dump_stack*caller){
T2 R=0;
void**locals[1];
static se_frame_descriptor fd={"default GENERAL",0,1,"Result%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=NULL;
ds.p=0x01E10816/*l264c11/general.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*INTEGER*/
T11 r2to_integer_64(se_dump_stack*caller,T2 C){
T11 R=0;
void**locals[1];
static se_frame_descriptor fd={"to_integer_64 INTEGER_GENERAL",1,1,"%E2%Result%E11%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x03213708/*l311c4/integer_general.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x03213A06/*l314c3/integer_general.e*/);
R=/*IC*/(T11)(C);
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03213C16/*l316c11/integer_general.e*/);
ac_ens(r11is_equal(&ds,/*IC*/(T11)(C),R),NULL);
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*INTEGER_64*/
T6 r11is_equal(se_dump_stack*caller,T11 C,T11 a1){
T6 R=0;
void**locals[2];
static se_frame_descriptor fd={"is_equal INTEGER_GENERAL",1,2,"%E11%other%E11%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x03232A08/*l810c4/integer_general.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x01E07720/*l119c16/general.e*/);
ac_req((/*exp-void-cmp*/1),NULL);
fd.assertion_flag=1;
}
(ds.p=0x03232C06/*l812c3/integer_general.e*/);
R=((T6)((r11to_integer_64(&ds,(/*RF2*/a1)))==(r11to_integer_64(&ds,(/*RF2*/C)))));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x01E07A64/*l122c50/general.e*/);
ac_ens((T6)((!(((T0*)(t[11]))==((void*)((T0*)(t[11])))))||((T6)((R)==(r11is_equal(&ds,a1,C))))),NULL);
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*INTEGER_64*/
T6 r11in_range(se_dump_stack*caller,T11 C,T11 a1,T11 a2){
T6 R=0;
void**locals[3];
static se_frame_descriptor fd={"in_range COMPARABLE",1,3,"%E11%lower%E11%upper%E11%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x02E04B08/*l75c4/comparable.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x02E04E14/*l78c10/comparable.e*/);
R=((T6)((T6)(((int64_t)((C)>=(a1)))&&((T6)((int64_t)((C)<=(a2)))))));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02E05022/*l80c17/comparable.e*/);
ac_ens((R)==(r6_ix_and(&ds,(T6)((int64_t)((C)>=(a1))),(T6)((int64_t)((C)<=(a2))))),NULL);
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*INTEGER_64*/
T3 r11digit(se_dump_stack*caller,T11 C){
T3 R=0;
void**locals[1];
static se_frame_descriptor fd={"digit (decimal_digit INTEGER_GENERAL)",1,1,"%E11%Result%E3%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x03220908/*l521c4/integer_general.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03220C14/*l524c10/integer_general.e*/);
ac_req(r11in_range(&ds,C,/*IC*/(T11)(INT8_C(0)),/*IC*/(T11)(INT8_C(9))),NULL);
fd.assertion_flag=1;
}
(ds.p=0x03220E14/*l526c10/integer_general.e*/);
R=((T3)(r11_ix_43(&ds,(/*RF2*/C),/*IC*/(T11)(T3code(((T3)'0'))))));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x0322103C/*l528c30/integer_general.e*/);
ac_ens(r7has(&ds,((T7*)ms25_117797837),R),NULL);
(ds.p=0x03221124/*l529c18/integer_general.e*/);
ac_ens(r11is_equal(&ds,C,/*IC*/(T11)(r3value(&ds,R))),NULL);
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*INTEGER_64*/
void r11append_in(se_dump_stack*caller,T11 C,T0* a1){
T11 _val=0;
T2 _i=0;
T2 _idx=0;
void**locals[4];
static se_frame_descriptor fd={"append_in INTEGER_GENERAL",1,4,"%E11%buffer%R7%val%E11%i%E2%idx%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x03214D08/*l333c4/integer_general.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&_val;
locals[2]=(void**)&_i;
locals[3]=(void**)&_idx;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03215122/*l337c17/integer_general.e*/);
ac_req((a1)!=((void*)(NULL)),NULL);
fd.assertion_flag=1;
}
/*[IF*/
if(((/*RF2*/C))==(INT8_C(0))){
(ds.p=0x03215628/*l342c20/integer_general.e*/);
r7extend(&ds,se_i7(&ds,((T7*)ci(7,a1,0x0321561A/*l342c13/integer_general.e*/))),((T3)'0'));
}
else{
/*[IF*/
if(((ds.p=0x0321582A/*l344c21/integer_general.e*/),(int64_t)(((/*RF2*/C))>(INT8_C(0))))){
(ds.p=0x03215A26/*l346c19/integer_general.e*/);
_i=r2_ix_43(&ds,(/*RF2*/(se_i7(&ds,((T7*)ci(7,a1,0x03215A30/*l346c24/integer_general.e*/))))->_count/*5*/),INT8_C(1));
(ds.p=0x03215B26/*l347c19/integer_general.e*/);
_val=(/*RF2*/C);
while (!(((ds.p=0x03215D2E/*l349c23/integer_general.e*/),(_val)==(INT8_C(0)))))
{
(ds.p=0x03215F34/*l351c26/integer_general.e*/);
r7extend(&ds,se_i7(&ds,((T7*)ci(7,a1,0x03215F26/*l351c19/integer_general.e*/))),r11digit(&ds,(int64_t)((_val)%(/*IC*/(T11)(INT8_C(10))))));
(ds.p=0x03216026/*l352c19/integer_general.e*/);
_val=(int64_t)((_val)/(INT8_C(10)));
}
}
else{
(ds.p=0x0321632E/*l355c23/integer_general.e*/);
r7extend(&ds,se_i7(&ds,((T7*)ci(7,a1,0x03216320/*l355c16/integer_general.e*/))),((T3)'\055'));
(ds.p=0x03216526/*l357c19/integer_general.e*/);
_i=r2_ix_43(&ds,(/*RF2*/(se_i7(&ds,((T7*)ci(7,a1,0x03216530/*l357c24/integer_general.e*/))))->_count/*5*/),INT8_C(1));
(ds.p=0x03216626/*l358c19/integer_general.e*/);
_val=(/*RF2*/C);
while (!(((ds.p=0x0321682E/*l360c23/integer_general.e*/),(_val)==(INT8_C(0)))))
{
(ds.p=0x03216A34/*l362c26/integer_general.e*/);
r7extend(&ds,se_i7(&ds,((T7*)ci(7,a1,0x03216A26/*l362c19/integer_general.e*/))),r11digit(&ds,-((int64_t)((_val)%(/*IC*/(T11)(INT8_C(10)))))));
(ds.p=0x03216B26/*l363c19/integer_general.e*/);
_val=(int64_t)((_val)/(INT8_C(10)));
}
}
/*FI]*/
(ds.p=0x03216F20/*l367c16/integer_general.e*/);
_idx=(/*RF2*/(se_i7(&ds,((T7*)ci(7,a1,0x03216F2E/*l367c23/integer_general.e*/))))->_count/*5*/);
while (!(((ds.p=0x03217124/*l369c18/integer_general.e*/),(int32_t)((_i)>=(_idx)))))
{
(ds.p=0x0321732E/*l371c23/integer_general.e*/);
r7swap(&ds,se_i7(&ds,((T7*)ci(7,a1,0x03217320/*l371c16/integer_general.e*/))),_i,_idx);
(ds.p=0x03217420/*l372c16/integer_general.e*/);
_idx=r2_ix_45(&ds,_idx,INT8_C(1));
(ds.p=0x03217520/*l373c16/integer_general.e*/);
_i=r2_ix_43(&ds,_i,INT8_C(1));
}
}
/*FI]*/
set_dump_stack_top(caller);/*unlink*/
}

/*INTEGER_64*/
T11 r11_ix_43(se_dump_stack*caller,T11 C,T11 a1){
T11 R=0;
void**locals[2];
static se_frame_descriptor fd={"infix + INTEGER_GENERAL",1,2,"%E11%other%E11%Result%E11%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x03203108/*l49c4/integer_general.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03203358/*l51c44/integer_general.e*/);
ac_req((T6)((!(((int64_t)(((/*RF2*/C))>(/*IC*/(T11)(INT8_C(0)))))==((int64_t)(((/*RF2*/a1))>(/*IC*/(T11)(INT8_C(0)))))))||((T6)(((int64_t)(((int64_t)((C)+(a1)))>(/*IC*/(T11)(INT8_C(0)))))==((int64_t)(((/*RF2*/C))>(/*IC*/(T11)(INT8_C(0)))))))),"no_overflow");
fd.assertion_flag=1;
}
(ds.p=0x03203706/*l55c3/integer_general.e*/);
R=(int64_t)(((/*RF2*/C))+(a1));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03203930/*l57c24/integer_general.e*/);
ac_ens(((int64_t)((R)-((/*RF2*/a1))))==((/*RF2*/C)),NULL);
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*INTEGER_64*/
T11 r11to_integer_64(se_dump_stack*caller,T11 C){
T11 R=0;
void**locals[1];
static se_frame_descriptor fd={"to_integer_64 INTEGER_GENERAL",1,1,"%E11%Result%E11%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x03213708/*l311c4/integer_general.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x03213A06/*l314c3/integer_general.e*/);
R=C;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03213C16/*l316c11/integer_general.e*/);
ac_ens(r11is_equal(&ds,C,R),NULL);
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*INTEGER_16*/
T6 r10is_equal(se_dump_stack*caller,T10 C,T10 a1){
T6 R=0;
void**locals[2];
static se_frame_descriptor fd={"is_equal INTEGER_GENERAL",1,2,"%E10%other%E10%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x03232A08/*l810c4/integer_general.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x01E07720/*l119c16/general.e*/);
ac_req((/*exp-void-cmp*/1),NULL);
fd.assertion_flag=1;
}
(ds.p=0x03232C06/*l812c3/integer_general.e*/);
R=((T6)((r10to_integer_64(&ds,(/*RF2*/a1)))==(r10to_integer_64(&ds,(/*RF2*/C)))));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x01E07A64/*l122c50/general.e*/);
ac_ens((T6)((!(((T0*)(t[10]))==((void*)((T0*)(t[10])))))||((T6)((R)==(r10is_equal(&ds,a1,C))))),NULL);
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*INTEGER_16*/
T6 r10in_range(se_dump_stack*caller,T10 C,T10 a1,T10 a2){
T6 R=0;
void**locals[3];
static se_frame_descriptor fd={"in_range COMPARABLE",1,3,"%E10%lower%E10%upper%E10%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x02E04B08/*l75c4/comparable.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x02E04E14/*l78c10/comparable.e*/);
R=((T6)((T6)(((int16_t)((C)>=(a1)))&&((T6)((int16_t)((C)<=(a2)))))));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02E05022/*l80c17/comparable.e*/);
ac_ens((R)==(r6_ix_and(&ds,(T6)((int16_t)((C)>=(a1))),(T6)((int16_t)((C)<=(a2))))),NULL);
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*INTEGER_16*/
T1 r10to_integer_8(se_dump_stack*caller,T10 C){
T1 R=0;
void**locals[1];
static se_frame_descriptor fd={"to_integer_8 INTEGER_GENERAL",1,1,"%E10%Result%E1%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x03210808/*l264c4/integer_general.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03210B06/*l267c3/integer_general.e*/);
ac_req(r10fit_integer_8(&ds,C),NULL);
fd.assertion_flag=1;
}
R=((EIF_INTEGER_8)C);
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03210E16/*l270c11/integer_general.e*/);
ac_ens(r10is_equal(&ds,C,/*IC*/(T10)(R)),NULL);
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*INTEGER_16*/
T6 r10fit_integer_8(se_dump_stack*caller,T10 C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"fit_integer_8 INTEGER_GENERAL",1,1,"%E10%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x0320FE08/*l254c4/integer_general.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
/*[IF*/
if(((ds.p=0x03210116/*l257c11/integer_general.e*/),(int16_t)(((/*RF2*/C))>=(INT8_MIN)))){
(ds.p=0x0321020C/*l258c6/integer_general.e*/);
R=((T6)((int16_t)(((/*RF2*/C))<=(INT8_C(127)))));
}
/*FI]*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03210514/*l261c10/integer_general.e*/);
ac_ens((R)==(r10in_range(&ds,C,/*IC*/(T10)(INT8_MIN),/*IC*/(T10)(INT8_C(127)))),NULL);
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*INTEGER_16*/
T11 r10to_integer_64(se_dump_stack*caller,T10 C){
T11 R=0;
void**locals[1];
static se_frame_descriptor fd={"to_integer_64 INTEGER_GENERAL",1,1,"%E10%Result%E11%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x03213708/*l311c4/integer_general.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x03213A06/*l314c3/integer_general.e*/);
R=/*IC*/(T11)(C);
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03213C16/*l316c11/integer_general.e*/);
ac_ens(r11is_equal(&ds,/*IC*/(T11)(C),R),NULL);
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*NATIVE_ARRAY[RULE]*/
T33 r33realloc(se_dump_stack*caller,T33 C,T2 a1,T2 a2){
T33 R=NULL;
void**locals[3];
static se_frame_descriptor fd={"realloc NATIVE_ARRAY",1,3,"%E33%old_nb_elts%E2%new_nb_elts%E2%Result%E33%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x03604308/*l67c4/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03604A14/*l74c10/native_array.e*/);
ac_req(r33is_not_null(&ds,C),NULL);
(ds.p=0x03604B2C/*l75c22/native_array.e*/);
ac_req((int32_t)((a1)>(/*IC*/(T2)(INT8_C(0)))),NULL);
(ds.p=0x03604C2C/*l76c22/native_array.e*/);
ac_req((int32_t)((a1)<(a2)),NULL);
fd.assertion_flag=1;
}
(ds.p=0x03604E14/*l78c10/native_array.e*/);
R=new33(a2);
(ds.p=0x03604F22/*l79c17/native_array.e*/);
r33copy_from(&ds,R,C,r2_ix_45(&ds,a1,/*IC*/(T2)(INT8_C(1))));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03605122/*l81c17/native_array.e*/);
ac_ens(r33is_not_null(&ds,R),NULL);
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*NATIVE_ARRAY[RULE]*/
void r33set_all_with(se_dump_stack*caller,T33 C,T0* a1,T2 a2){
T2 _i=0;
void**locals[3];
static se_frame_descriptor fd={"set_all_with NATIVE_ARRAY",1,3,"%E33%v%R16%upper%E2%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x03614F08/*l335c4/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&_i;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03615312/*l339c9/native_array.e*/);
ac_req((int32_t)((a2)>=(/*IC*/(T2)(INT8_C(-1)))),NULL);
fd.assertion_flag=1;
}
(ds.p=0x0361571E/*l343c15/native_array.e*/);
_i=a2;
while (!(((ds.p=0x03615744/*l343c34/native_array.e*/),(int32_t)((_i)<(INT8_C(0))))))
{
(ds.p=0x0361591A/*l345c13/native_array.e*/);
(C)[_i]=(a1);
(ds.p=0x03615A1A/*l346c13/native_array.e*/);
_i=r2_ix_45(&ds,_i,INT8_C(1));
}
set_dump_stack_top(caller);/*unlink*/
}

/*NATIVE_ARRAY[RULE]*/
T6 r33is_not_null(se_dump_stack*caller,T33 C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"is_not_null NATIVE_ARRAY",1,1,"%E33%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x03620B08/*l523c4/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x03620D14/*l525c10/native_array.e*/);
R=((T6)((NULL!=((void*)(C)))));
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*NATIVE_ARRAY[RULE]*/
T6 r33all_default(se_dump_stack*caller,T33 C,T2 a1){
T6 R=0;
T2 _i=0;
T0* _v=NULL;
void**locals[4];
static se_frame_descriptor fd={"all_default NATIVE_ARRAY",1,4,"%E33%upper%E2%Result%E6%i%E2%v%R16%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x0361E608/*l486c4/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
locals[2]=(void**)&_i;
locals[3]=(void**)&_v;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x0361EC20/*l492c16/native_array.e*/);
ac_req((int32_t)((a1)>=(/*IC*/(T2)(INT8_C(-1)))),NULL);
fd.assertion_flag=1;
}
(ds.p=0x0361F11A/*l497c13/native_array.e*/);
R=((T6)(1));
(ds.p=0x0361F21A/*l498c13/native_array.e*/);
_i=a1;
while (!(((ds.p=0x0361F426/*l500c19/native_array.e*/),(T6)(((int32_t)((_i)<(INT8_C(0))))||((T6)(r6_px_not(&ds,(T6)(R))))))))
{
(ds.p=0x0361F60C/*l502c6/native_array.e*/);
_v=(C)[_i];
/*[IF*/
if((_v)!=((void*)(NULL))){
(ds.p=0x0361F812/*l504c9/native_array.e*/);
R=((T6)(r16is_default(&ds,((T16*)ci(16,_v,0x0361F826/*l504c19/native_array.e*/)))));
}
/*FI]*/
(ds.p=0x0361FA1A/*l506c13/native_array.e*/);
_i=r2_ix_45(&ds,_i,INT8_C(1));
}
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*NATIVE_ARRAY[RULE]*/
void r33copy_from(se_dump_stack*caller,T33 C,T33 a1,T2 a2){
T2 _i=0;
void**locals[3];
static se_frame_descriptor fd={"copy_from NATIVE_ARRAY",1,3,"%E33%model%E33%upper%E2%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x03617F08/*l383c4/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&_i;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03618212/*l386c9/native_array.e*/);
ac_req((int32_t)((a2)>=(/*IC*/(T2)(INT8_C(-1)))),NULL);
fd.assertion_flag=1;
}
(ds.p=0x0361861E/*l390c15/native_array.e*/);
_i=a2;
while (!(((ds.p=0x03618644/*l390c34/native_array.e*/),(int32_t)((_i)<(INT8_C(0))))))
{
(ds.p=0x0361881A/*l392c13/native_array.e*/);
(C)[_i]=((a1)[_i]);
(ds.p=0x0361891A/*l393c13/native_array.e*/);
_i=r2_ix_45(&ds,_i,INT8_C(1));
}
set_dump_stack_top(caller);/*unlink*/
}

/*NATIVE_ARRAY[STRING]*/
void r29clear_all(se_dump_stack*caller,T29 C,T2 a1){
T0* _v=NULL;
T2 _i=0;
void**locals[3];
static se_frame_descriptor fd={"clear_all NATIVE_ARRAY",1,3,"%E29%upper%E2%v%R7%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x03615E08/*l350c4/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&_v;
locals[2]=(void**)&_i;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03616212/*l354c9/native_array.e*/);
ac_req((int32_t)((a1)>=(/*IC*/(T2)(INT8_C(-1)))),NULL);
fd.assertion_flag=1;
}
(ds.p=0x0361661E/*l358c15/native_array.e*/);
_i=a1;
while (!(((ds.p=0x03616644/*l358c34/native_array.e*/),(int32_t)((_i)<(INT8_C(0))))))
{
(ds.p=0x0361681A/*l360c13/native_array.e*/);
(C)[_i]=(_v);
(ds.p=0x0361691A/*l361c13/native_array.e*/);
_i=r2_ix_45(&ds,_i,INT8_C(1));
}
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03616C06/*l364c3/native_array.e*/);
ac_ens(r29all_default(&ds,C,a1),NULL);
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
}

/*NATIVE_ARRAY[STRING]*/
T29 r29realloc(se_dump_stack*caller,T29 C,T2 a1,T2 a2){
T29 R=NULL;
void**locals[3];
static se_frame_descriptor fd={"realloc NATIVE_ARRAY",1,3,"%E29%old_nb_elts%E2%new_nb_elts%E2%Result%E29%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x03604308/*l67c4/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03604A14/*l74c10/native_array.e*/);
ac_req(r29is_not_null(&ds,C),NULL);
(ds.p=0x03604B2C/*l75c22/native_array.e*/);
ac_req((int32_t)((a1)>(/*IC*/(T2)(INT8_C(0)))),NULL);
(ds.p=0x03604C2C/*l76c22/native_array.e*/);
ac_req((int32_t)((a1)<(a2)),NULL);
fd.assertion_flag=1;
}
(ds.p=0x03604E14/*l78c10/native_array.e*/);
R=new29(a2);
(ds.p=0x03604F22/*l79c17/native_array.e*/);
r29copy_from(&ds,R,C,r2_ix_45(&ds,a1,/*IC*/(T2)(INT8_C(1))));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03605122/*l81c17/native_array.e*/);
ac_ens(r29is_not_null(&ds,R),NULL);
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*NATIVE_ARRAY[STRING]*/
void r29remove_first(se_dump_stack*caller,T29 C,T2 a1){
T2 _i=0;
void**locals[2];
static se_frame_descriptor fd={"remove_first NATIVE_ARRAY",1,2,"%E29%upper%E2%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x0360DB08/*l219c4/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&_i;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x0360DF20/*l223c16/native_array.e*/);
ac_req((int32_t)((a1)>=(/*IC*/(T2)(INT8_C(0)))),NULL);
fd.assertion_flag=1;
}
while (!(((ds.p=0x0360E32E/*l227c23/native_array.e*/),(_i)==(a1))))
{
(ds.p=0x0360E51A/*l229c13/native_array.e*/);
(C)[_i]=((C)[r2_ix_43(&ds,_i,/*IC*/(T2)(INT8_C(1)))]);
(ds.p=0x0360E61A/*l230c13/native_array.e*/);
_i=r2_ix_43(&ds,_i,INT8_C(1));
}
set_dump_stack_top(caller);/*unlink*/
}

/*NATIVE_ARRAY[STRING]*/
void r29set_all_with(se_dump_stack*caller,T29 C,T0* a1,T2 a2){
T2 _i=0;
void**locals[3];
static se_frame_descriptor fd={"set_all_with NATIVE_ARRAY",1,3,"%E29%v%R7%upper%E2%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x03614F08/*l335c4/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&_i;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03615312/*l339c9/native_array.e*/);
ac_req((int32_t)((a2)>=(/*IC*/(T2)(INT8_C(-1)))),NULL);
fd.assertion_flag=1;
}
(ds.p=0x0361571E/*l343c15/native_array.e*/);
_i=a2;
while (!(((ds.p=0x03615744/*l343c34/native_array.e*/),(int32_t)((_i)<(INT8_C(0))))))
{
(ds.p=0x0361591A/*l345c13/native_array.e*/);
(C)[_i]=(a1);
(ds.p=0x03615A1A/*l346c13/native_array.e*/);
_i=r2_ix_45(&ds,_i,INT8_C(1));
}
set_dump_stack_top(caller);/*unlink*/
}

/*NATIVE_ARRAY[STRING]*/
T6 r29fast_memcmp(se_dump_stack*caller,T29 C,T29 a1,T2 a2){
T6 R=0;
T2 _i=0;
void**locals[4];
static se_frame_descriptor fd={"fast_memcmp NATIVE_ARRAY",1,4,"%E29%other%E29%capacity%E2%Result%E6%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x03606A08/*l106c4/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&R;
locals[3]=(void**)&_i;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03606D2E/*l109c23/native_array.e*/);
ac_req((T6)((!((int32_t)((a2)>(/*IC*/(T2)(INT8_C(0))))))||((T6)(r29is_not_null(&ds,a1)))),NULL);
fd.assertion_flag=1;
}
(ds.p=0x0360721A/*l114c13/native_array.e*/);
_i=r2_ix_45(&ds,a2,INT8_C(1));
while (!(((ds.p=0x03607426/*l116c19/native_array.e*/),(T6)(((int32_t)((_i)<(INT8_C(0))))||((T6)(((C)[_i])!=((void*)((a1)[_i]))))))))
{
(ds.p=0x0360761A/*l118c13/native_array.e*/);
_i=r2_ix_45(&ds,_i,INT8_C(1));
}
(ds.p=0x03607814/*l120c10/native_array.e*/);
R=((T6)((int32_t)((_i)<(INT8_C(0)))));
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*NATIVE_ARRAY[STRING]*/
T6 r29is_not_null(se_dump_stack*caller,T29 C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"is_not_null NATIVE_ARRAY",1,1,"%E29%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x03620B08/*l523c4/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x03620D14/*l525c10/native_array.e*/);
R=((T6)((NULL!=((void*)(C)))));
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*NATIVE_ARRAY[STRING]*/
T6 r29all_default(se_dump_stack*caller,T29 C,T2 a1){
T6 R=0;
T2 _i=0;
T0* _v=NULL;
void**locals[4];
static se_frame_descriptor fd={"all_default NATIVE_ARRAY",1,4,"%E29%upper%E2%Result%E6%i%E2%v%R7%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x0361E608/*l486c4/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
locals[2]=(void**)&_i;
locals[3]=(void**)&_v;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x0361EC20/*l492c16/native_array.e*/);
ac_req((int32_t)((a1)>=(/*IC*/(T2)(INT8_C(-1)))),NULL);
fd.assertion_flag=1;
}
(ds.p=0x0361F11A/*l497c13/native_array.e*/);
R=((T6)(1));
(ds.p=0x0361F21A/*l498c13/native_array.e*/);
_i=a1;
while (!(((ds.p=0x0361F426/*l500c19/native_array.e*/),(T6)(((int32_t)((_i)<(INT8_C(0))))||((T6)(r6_px_not(&ds,(T6)(R))))))))
{
(ds.p=0x0361F60C/*l502c6/native_array.e*/);
_v=(C)[_i];
/*[IF*/
if((_v)!=((void*)(NULL))){
(ds.p=0x0361F812/*l504c9/native_array.e*/);
R=((T6)(r7is_default(&ds,se_i7(&ds,((T7*)ci(7,_v,0x0361F826/*l504c19/native_array.e*/))))));
}
/*FI]*/
(ds.p=0x0361FA1A/*l506c13/native_array.e*/);
_i=r2_ix_45(&ds,_i,INT8_C(1));
}
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*NATIVE_ARRAY[STRING]*/
void r29copy_from(se_dump_stack*caller,T29 C,T29 a1,T2 a2){
T2 _i=0;
void**locals[3];
static se_frame_descriptor fd={"copy_from NATIVE_ARRAY",1,3,"%E29%model%E29%upper%E2%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x03617F08/*l383c4/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&_i;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03618212/*l386c9/native_array.e*/);
ac_req((int32_t)((a2)>=(/*IC*/(T2)(INT8_C(-1)))),NULL);
fd.assertion_flag=1;
}
(ds.p=0x0361861E/*l390c15/native_array.e*/);
_i=a2;
while (!(((ds.p=0x03618644/*l390c34/native_array.e*/),(int32_t)((_i)<(INT8_C(0))))))
{
(ds.p=0x0361881A/*l392c13/native_array.e*/);
(C)[_i]=((a1)[_i]);
(ds.p=0x0361891A/*l393c13/native_array.e*/);
_i=r2_ix_45(&ds,_i,INT8_C(1));
}
set_dump_stack_top(caller);/*unlink*/
}

/*NATIVE_ARRAY[CHARACTER]*/
T9 r9realloc(se_dump_stack*caller,T9 C,T2 a1,T2 a2){
T9 R=NULL;
void**locals[3];
static se_frame_descriptor fd={"realloc NATIVE_ARRAY",1,3,"%E9%old_nb_elts%E2%new_nb_elts%E2%Result%E9%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x03604308/*l67c4/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03604A14/*l74c10/native_array.e*/);
ac_req(r9is_not_null(&ds,C),NULL);
(ds.p=0x03604B2C/*l75c22/native_array.e*/);
ac_req((int32_t)((a1)>(/*IC*/(T2)(INT8_C(0)))),NULL);
(ds.p=0x03604C2C/*l76c22/native_array.e*/);
ac_req((int32_t)((a1)<(a2)),NULL);
fd.assertion_flag=1;
}
(ds.p=0x03604E14/*l78c10/native_array.e*/);
R=new9(a2);
(ds.p=0x03604F22/*l79c17/native_array.e*/);
r9copy_from(&ds,R,C,r2_ix_45(&ds,a1,/*IC*/(T2)(INT8_C(1))));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03605122/*l81c17/native_array.e*/);
ac_ens(r9is_not_null(&ds,R),NULL);
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*NATIVE_ARRAY[CHARACTER]*/
T6 r9fast_memcmp(se_dump_stack*caller,T9 C,T9 a1,T2 a2){
T6 R=0;
T2 _i=0;
void**locals[4];
static se_frame_descriptor fd={"fast_memcmp NATIVE_ARRAY",1,4,"%E9%other%E9%capacity%E2%Result%E6%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x03606A08/*l106c4/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&R;
locals[3]=(void**)&_i;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03606D2E/*l109c23/native_array.e*/);
ac_req((T6)((!((int32_t)((a2)>(/*IC*/(T2)(INT8_C(0))))))||((T6)(r9is_not_null(&ds,a1)))),NULL);
fd.assertion_flag=1;
}
(ds.p=0x0360721A/*l114c13/native_array.e*/);
_i=r2_ix_45(&ds,a2,INT8_C(1));
while (!(((ds.p=0x03607426/*l116c19/native_array.e*/),(T6)(((int32_t)((_i)<(INT8_C(0))))||((T6)(((C)[_i])!=((a1)[_i])))))))
{
(ds.p=0x0360761A/*l118c13/native_array.e*/);
_i=r2_ix_45(&ds,_i,INT8_C(1));
}
(ds.p=0x03607814/*l120c10/native_array.e*/);
R=((T6)((int32_t)((_i)<(INT8_C(0)))));
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*NATIVE_ARRAY[CHARACTER]*/
T6 r9fast_has(se_dump_stack*caller,T9 C,T3 a1,T2 a2){
T6 R=0;
T2 _i=0;
void**locals[4];
static se_frame_descriptor fd={"fast_has NATIVE_ARRAY",1,4,"%E9%element%E3%upper%E2%Result%E6%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x0360C708/*l199c4/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&R;
locals[3]=(void**)&_i;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x0360CB20/*l203c16/native_array.e*/);
ac_req((int32_t)((a2)>=(/*IC*/(T2)(INT8_C(-1)))),NULL);
fd.assertion_flag=1;
}
(ds.p=0x0360D01A/*l208c13/native_array.e*/);
_i=a2;
while (!(((ds.p=0x0360D226/*l210c19/native_array.e*/),(T6)(((int32_t)((_i)<(INT8_C(0))))||((T6)((a1)==((C)[_i])))))))
{
(ds.p=0x0360D41A/*l212c13/native_array.e*/);
_i=r2_ix_45(&ds,_i,INT8_C(1));
}
(ds.p=0x0360D614/*l214c10/native_array.e*/);
R=((T6)((int32_t)((_i)>=(INT8_C(0)))));
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*NATIVE_ARRAY[CHARACTER]*/
T6 r9is_not_null(se_dump_stack*caller,T9 C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"is_not_null NATIVE_ARRAY",1,1,"%E9%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x03620B08/*l523c4/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x03620D14/*l525c10/native_array.e*/);
R=((T6)((NULL!=((void*)(C)))));
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*NATIVE_ARRAY[CHARACTER]*/
T6 r9all_default(se_dump_stack*caller,T9 C,T2 a1){
T6 R=0;
T2 _i=0;
T3 _v=0;
void**locals[4];
static se_frame_descriptor fd={"all_default NATIVE_ARRAY",1,4,"%E9%upper%E2%Result%E6%i%E2%v%E3%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x0361E608/*l486c4/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
locals[2]=(void**)&_i;
locals[3]=(void**)&_v;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x0361EC20/*l492c16/native_array.e*/);
ac_req((int32_t)((a1)>=(/*IC*/(T2)(INT8_C(-1)))),NULL);
fd.assertion_flag=1;
}
(ds.p=0x0361F11A/*l497c13/native_array.e*/);
R=((T6)(1));
(ds.p=0x0361F21A/*l498c13/native_array.e*/);
_i=a1;
while (!(((ds.p=0x0361F426/*l500c19/native_array.e*/),(T6)(((int32_t)((_i)<(INT8_C(0))))||((T6)(r6_px_not(&ds,(T6)(R))))))))
{
(ds.p=0x0361F60C/*l502c6/native_array.e*/);
_v=(C)[_i];
(ds.p=0x0361F812/*l504c9/native_array.e*/);
R=((T6)((_v)==(((T3)'\000'))));
(ds.p=0x0361FA1A/*l506c13/native_array.e*/);
_i=r2_ix_45(&ds,_i,INT8_C(1));
}
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*NATIVE_ARRAY[CHARACTER]*/
void r9copy_from(se_dump_stack*caller,T9 C,T9 a1,T2 a2){
T2 _i=0;
void**locals[3];
static se_frame_descriptor fd={"copy_from NATIVE_ARRAY",1,3,"%E9%model%E9%upper%E2%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x03617F08/*l383c4/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&_i;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03618212/*l386c9/native_array.e*/);
ac_req((int32_t)((a2)>=(/*IC*/(T2)(INT8_C(-1)))),NULL);
fd.assertion_flag=1;
}
(ds.p=0x0361861E/*l390c15/native_array.e*/);
_i=a2;
while (!(((ds.p=0x03618644/*l390c34/native_array.e*/),(int32_t)((_i)<(INT8_C(0))))))
{
(ds.p=0x0361881A/*l392c13/native_array.e*/);
(C)[_i]=((a1)[_i]);
(ds.p=0x0361891A/*l393c13/native_array.e*/);
_i=r2_ix_45(&ds,_i,INT8_C(1));
}
set_dump_stack_top(caller);/*unlink*/
}

/*NATIVE_ARRAY[INTEGER]*/
T45 r45realloc(se_dump_stack*caller,T45 C,T2 a1,T2 a2){
T45 R=NULL;
void**locals[3];
static se_frame_descriptor fd={"realloc NATIVE_ARRAY",1,3,"%E45%old_nb_elts%E2%new_nb_elts%E2%Result%E45%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x03604308/*l67c4/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03604A14/*l74c10/native_array.e*/);
ac_req(r45is_not_null(&ds,C),NULL);
(ds.p=0x03604B2C/*l75c22/native_array.e*/);
ac_req((int32_t)((a1)>(/*IC*/(T2)(INT8_C(0)))),NULL);
(ds.p=0x03604C2C/*l76c22/native_array.e*/);
ac_req((int32_t)((a1)<(a2)),NULL);
fd.assertion_flag=1;
}
(ds.p=0x03604E14/*l78c10/native_array.e*/);
R=new45(a2);
(ds.p=0x03604F22/*l79c17/native_array.e*/);
r45copy_from(&ds,R,C,r2_ix_45(&ds,a1,/*IC*/(T2)(INT8_C(1))));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03605122/*l81c17/native_array.e*/);
ac_ens(r45is_not_null(&ds,R),NULL);
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*NATIVE_ARRAY[INTEGER]*/
void r45set_all_with(se_dump_stack*caller,T45 C,T2 a1,T2 a2){
T2 _i=0;
void**locals[3];
static se_frame_descriptor fd={"set_all_with NATIVE_ARRAY",1,3,"%E45%v%E2%upper%E2%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x03614F08/*l335c4/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&_i;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03615312/*l339c9/native_array.e*/);
ac_req((int32_t)((a2)>=(/*IC*/(T2)(INT8_C(-1)))),NULL);
fd.assertion_flag=1;
}
(ds.p=0x0361571E/*l343c15/native_array.e*/);
_i=a2;
while (!(((ds.p=0x03615744/*l343c34/native_array.e*/),(int32_t)((_i)<(INT8_C(0))))))
{
(ds.p=0x0361591A/*l345c13/native_array.e*/);
(C)[_i]=(a1);
(ds.p=0x03615A1A/*l346c13/native_array.e*/);
_i=r2_ix_45(&ds,_i,INT8_C(1));
}
set_dump_stack_top(caller);/*unlink*/
}

/*NATIVE_ARRAY[INTEGER]*/
T6 r45fast_memcmp(se_dump_stack*caller,T45 C,T45 a1,T2 a2){
T6 R=0;
T2 _i=0;
void**locals[4];
static se_frame_descriptor fd={"fast_memcmp NATIVE_ARRAY",1,4,"%E45%other%E45%capacity%E2%Result%E6%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x03606A08/*l106c4/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&R;
locals[3]=(void**)&_i;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03606D2E/*l109c23/native_array.e*/);
ac_req((T6)((!((int32_t)((a2)>(/*IC*/(T2)(INT8_C(0))))))||((T6)(r45is_not_null(&ds,a1)))),NULL);
fd.assertion_flag=1;
}
(ds.p=0x0360721A/*l114c13/native_array.e*/);
_i=r2_ix_45(&ds,a2,INT8_C(1));
while (!(((ds.p=0x03607426/*l116c19/native_array.e*/),(T6)(((int32_t)((_i)<(INT8_C(0))))||((T6)(((C)[_i])!=((a1)[_i])))))))
{
(ds.p=0x0360761A/*l118c13/native_array.e*/);
_i=r2_ix_45(&ds,_i,INT8_C(1));
}
(ds.p=0x03607814/*l120c10/native_array.e*/);
R=((T6)((int32_t)((_i)<(INT8_C(0)))));
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*NATIVE_ARRAY[INTEGER]*/
T6 r45is_not_null(se_dump_stack*caller,T45 C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"is_not_null NATIVE_ARRAY",1,1,"%E45%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x03620B08/*l523c4/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x03620D14/*l525c10/native_array.e*/);
R=((T6)((NULL!=((void*)(C)))));
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*NATIVE_ARRAY[INTEGER]*/
T6 r45all_default(se_dump_stack*caller,T45 C,T2 a1){
T6 R=0;
T2 _i=0;
T2 _v=0;
void**locals[4];
static se_frame_descriptor fd={"all_default NATIVE_ARRAY",1,4,"%E45%upper%E2%Result%E6%i%E2%v%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x0361E608/*l486c4/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
locals[2]=(void**)&_i;
locals[3]=(void**)&_v;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x0361EC20/*l492c16/native_array.e*/);
ac_req((int32_t)((a1)>=(/*IC*/(T2)(INT8_C(-1)))),NULL);
fd.assertion_flag=1;
}
(ds.p=0x0361F11A/*l497c13/native_array.e*/);
R=((T6)(1));
(ds.p=0x0361F21A/*l498c13/native_array.e*/);
_i=a1;
while (!(((ds.p=0x0361F426/*l500c19/native_array.e*/),(T6)(((int32_t)((_i)<(INT8_C(0))))||((T6)(r6_px_not(&ds,(T6)(R))))))))
{
(ds.p=0x0361F60C/*l502c6/native_array.e*/);
_v=(C)[_i];
(ds.p=0x0361F812/*l504c9/native_array.e*/);
R=((T6)((_v)==(INT8_C(0))));
(ds.p=0x0361FA1A/*l506c13/native_array.e*/);
_i=r2_ix_45(&ds,_i,INT8_C(1));
}
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*NATIVE_ARRAY[INTEGER]*/
void r45copy_from(se_dump_stack*caller,T45 C,T45 a1,T2 a2){
T2 _i=0;
void**locals[3];
static se_frame_descriptor fd={"copy_from NATIVE_ARRAY",1,3,"%E45%model%E45%upper%E2%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x03617F08/*l383c4/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&_i;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03618212/*l386c9/native_array.e*/);
ac_req((int32_t)((a2)>=(/*IC*/(T2)(INT8_C(-1)))),NULL);
fd.assertion_flag=1;
}
(ds.p=0x0361861E/*l390c15/native_array.e*/);
_i=a2;
while (!(((ds.p=0x03618644/*l390c34/native_array.e*/),(int32_t)((_i)<(INT8_C(0))))))
{
(ds.p=0x0361881A/*l392c13/native_array.e*/);
(C)[_i]=((a1)[_i]);
(ds.p=0x0361891A/*l393c13/native_array.e*/);
_i=r2_ix_45(&ds,_i,INT8_C(1));
}
set_dump_stack_top(caller);/*unlink*/
}

/*STRING*/
T6 r7is_default(se_dump_stack*caller,T7* C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"is_default GENERAL",1,1,"%R7%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x01E10F08/*l271c4/general.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x01E11806/*l280c3/general.e*/);
R=((T6)((C)==((void*)(r7default(&ds,C)))));
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*STRING*/
void r7put(se_dump_stack*caller,T7* C,T3 a1,T2 a2){
void**locals[2];
static se_frame_descriptor fd={"put STRING",1,2,"%R7%c%E3%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x00E44C08/*l1100c4/string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x00E44F2E/*l1103c23/string.e*/);
ac_req(r7valid_index(&ds,C,a2),"valid_index");
fd.assertion_flag=1;
}
(ds.p=0x00E45124/*l1105c18/string.e*/);
((/*RF2*/(C)->_storage/*1*/))[r2_ix_45(&ds,a2,/*IC*/(T2)(INT8_C(1)))]=(a1);
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x00E45326/*l1107c19/string.e*/);
ac_ens((r7item(&ds,C,a2))==(a1),NULL);
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}

/*STRING*/
T6 r7is_equal(se_dump_stack*caller,T7* C,T0* a1){
T6 R=0;
void**locals[2];
static se_frame_descriptor fd={"is_equal STRING",1,2,"%R7%other%R7%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x00E0C808/*l200c4/string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x01E07720/*l119c16/general.e*/);
ac_req((a1)!=((void*)(NULL)),NULL);
fd.assertion_flag=1;
}
/*[IF*/
if(((/*RF2*/(C)->_count/*5*/))==((/*RF2*/(se_i7(&ds,((T7*)ci(7,a1,0x00E0CC2A/*l204c21/string.e*/))))->_count/*5*/))){
(ds.p=0x00E0CD1A/*l205c13/string.e*/);
R=((T6)(r9fast_memcmp(&ds,(/*RF2*/(C)->_storage/*1*/),(/*RF2*/(se_i7(&ds,((T7*)ci(7,a1,0x00E0CD56/*l205c43/string.e*/))))->_storage/*1*/),(/*RF2*/(C)->_count/*5*/))));
}
/*FI]*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02E0212C/*l33c22/comparable.e*/);
ac_ens((R)==(r6_ix_and(&ds,(T6)(r6_px_not(&ds,(T6)(r7_ix_60(&ds,se_i7(&ds,C),a1)))),(T6)(r6_px_not(&ds,(T6)(r7_ix_60(&ds,se_i7(&ds,((T7*)ci(7,a1,0x02E02170/*l33c56/comparable.e*/))),(T0*)C)))))),"trichotomy");
(ds.p=0x01E07A64/*l122c50/general.e*/);
ac_ens((T6)((!(((T0*)(t[(C)->id]))==((void*)((T0*)(t[((T7*)a1)->id])))))||((T6)((R)==(r7is_equal(&ds,se_i7(&ds,((T7*)ci(7,a1,0x01E07B20/*l123c16/general.e*/))),(T0*)C))))),NULL);
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*STRING*/
T3 r7item(se_dump_stack*caller,T7* C,T2 a1){
T3 R=0;
void**locals[2];
static se_frame_descriptor fd={"item STRING",1,2,"%R7%i%E2%Result%E3%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x00E07508/*l117c4/string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x00E0782E/*l120c23/string.e*/);
ac_req(r7valid_index(&ds,C,a1),"valid_index");
fd.assertion_flag=1;
}
(ds.p=0x00E07A14/*l122c10/string.e*/);
R=((/*RF2*/(C)->_storage/*1*/))[r2_ix_45(&ds,a1,INT8_C(1))];
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*STRING*/
T6 r7valid_index(se_dump_stack*caller,T7* C,T2 a1){
T6 R=0;
void**locals[2];
static se_frame_descriptor fd={"valid_index STRING",1,2,"%R7%i%E2%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x00E07D08/*l125c4/string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x00E08014/*l128c10/string.e*/);
R=((T6)((T6)(((int32_t)((INT8_C(1))<=(a1)))&&((T6)((int32_t)((a1)<=((/*RF2*/(C)->_count/*5*/))))))));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x00E0823A/*l130c29/string.e*/);
ac_ens((R)==(r6_ix_and(&ds,(T6)((int32_t)((/*IC*/(T2)(INT8_C(1)))<=(a1))),(T6)((int32_t)((a1)<=((/*RF2*/(C)->_count/*5*/)))))),"definition");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*STRING*/
void r7make(se_dump_stack*caller,T7* C,T2 a1){
void**locals[1];
static se_frame_descriptor fd={"make STRING",1,1,"%R7%needed_capacity%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x00E04208/*l66c4/string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x00E0465C/*l70c46/string.e*/);
ac_req((int32_t)((a1)>=(/*IC*/(T2)(INT8_C(0)))),"non_negative_size");
fd.assertion_flag=1;
}
/*[IF*/
if(((ds.p=0x00E0483A/*l72c29/string.e*/),(int32_t)((a1)>(INT8_C(0))))){
/*[IF*/
if(((ds.p=0x00E04932/*l73c25/string.e*/),(int32_t)(((/*RF2*/(C)->_capacity/*9*/))<(a1)))){
(ds.p=0x00E04A20/*l74c16/string.e*/);
/*SFN*/(C->_storage/*1*/)=new9(a1);
(ds.p=0x00E04B20/*l75c16/string.e*/);
/*SFN*/(C->_capacity/*9*/)=a1;
}
/*FI]*/
}
/*FI]*/
(ds.p=0x00E04E14/*l78c10/string.e*/);
/*SFN*/(C->_count/*5*/)=INT8_C(0);
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x00E05034/*l80c26/string.e*/);
ac_ens((int32_t)((a1)<=((/*RF2*/(C)->_capacity/*9*/))),NULL);
(ds.p=0x00E0513C/*l81c30/string.e*/);
ac_ens(((/*RF2*/(C)->_count/*5*/))==(INT8_C(0)),"empty_string");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}

/*STRING*/
T6 r7is_empty(se_dump_stack*caller,T7* C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"is_empty STRING",1,1,"%R7%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x00E06F08/*l111c4/string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x00E07214/*l114c10/string.e*/);
R=((T6)(((/*RF2*/(C)->_count/*5*/))==(INT8_C(0))));
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*STRING*/
void r7extend(se_dump_stack*caller,T7* C,T3 a1){
T2 _new_capacity=0;
T2 o7_1215_26=0;
void**locals[3];
static se_frame_descriptor fd={"extend (add_last STRING)",1,3,"%R7%c%E3%new_capacity%E2%old value%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x00E4AD08/*l1197c4/string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&_new_capacity;
locals[2]=(void**)&o7_1215_26;
set_dump_stack_top(&ds);/*link*/
o7_1215_26=(/*RF2*/(C)->_count/*5*/);
/*[IF*/
if(((ds.p=0x00E4B22C/*l1202c22/string.e*/),(int32_t)(((/*RF2*/(C)->_capacity/*9*/))>((/*RF2*/(C)->_count/*5*/))))){
}
 else if(((/*RF2*/(C)->_capacity/*9*/))==(INT8_C(0))){
(ds.p=0x00E4B40C/*l1204c6/string.e*/);
_new_capacity=INT8_C(32);
(ds.p=0x00E4B51A/*l1205c13/string.e*/);
/*SFN*/(C->_storage/*1*/)=new9(_new_capacity);
(ds.p=0x00E4B61A/*l1206c13/string.e*/);
/*SFN*/(C->_capacity/*9*/)=_new_capacity;
}
else{
(ds.p=0x00E4B81A/*l1208c13/string.e*/);
_new_capacity=r2_ix_42(&ds,INT8_C(2),(/*RF2*/(C)->_capacity/*9*/));
(ds.p=0x00E4B91A/*l1209c13/string.e*/);
/*SFN*/(C->_storage/*1*/)=r9realloc(&ds,(/*RF2*/(C)->_storage/*1*/),(/*RF2*/(C)->_capacity/*9*/),_new_capacity);
(ds.p=0x00E4BA1A/*l1210c13/string.e*/);
/*SFN*/(C->_capacity/*9*/)=_new_capacity;
}
/*FI]*/
(ds.p=0x00E4BC24/*l1212c18/string.e*/);
((/*RF2*/(C)->_storage/*1*/))[(/*RF2*/(C)->_count/*5*/)]=(a1);
(ds.p=0x00E4BD14/*l1213c10/string.e*/);
/*SFN*/(C->_count/*5*/)=r2_ix_43(&ds,(/*RF2*/(C)->_count/*5*/),INT8_C(1));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x00E4BF20/*l1215c16/string.e*/);
ac_ens(((/*RF2*/(C)->_count/*5*/))==(r2_ix_43(&ds,/*IC*/(T2)(INT8_C(1)),o7_1215_26)),NULL);
(ds.p=0x00E4C02E/*l1216c23/string.e*/);
ac_ens((r7item(&ds,C,(/*RF2*/(C)->_count/*5*/)))==(a1),NULL);
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}

/*STRING*/
T6 r7has(se_dump_stack*caller,T7* C,T3 a1){
T6 R=0;
void**locals[2];
static se_frame_descriptor fd={"has STRING",1,2,"%R7%c%E3%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x00E13008/*l304c4/string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x00E13314/*l307c10/string.e*/);
R=((T6)(r9fast_has(&ds,(/*RF2*/(C)->_storage/*1*/),a1,r2_ix_45(&ds,(/*RF2*/(C)->_count/*5*/),/*IC*/(T2)(INT8_C(1))))));
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*STRING*/
void r7append_character(se_dump_stack*caller,T7* C,T3 a1){
T2 _new_capacity=0;
T2 o7_1215_26=0;
void**locals[3];
static se_frame_descriptor fd={"append_character (add_last STRING)",1,3,"%R7%c%E3%new_capacity%E2%old value%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x00E4AD08/*l1197c4/string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&_new_capacity;
locals[2]=(void**)&o7_1215_26;
set_dump_stack_top(&ds);/*link*/
o7_1215_26=(/*RF2*/(C)->_count/*5*/);
/*[IF*/
if(((ds.p=0x00E4B22C/*l1202c22/string.e*/),(int32_t)(((/*RF2*/(C)->_capacity/*9*/))>((/*RF2*/(C)->_count/*5*/))))){
}
 else if(((/*RF2*/(C)->_capacity/*9*/))==(INT8_C(0))){
(ds.p=0x00E4B40C/*l1204c6/string.e*/);
_new_capacity=INT8_C(32);
(ds.p=0x00E4B51A/*l1205c13/string.e*/);
/*SFN*/(C->_storage/*1*/)=new9(_new_capacity);
(ds.p=0x00E4B61A/*l1206c13/string.e*/);
/*SFN*/(C->_capacity/*9*/)=_new_capacity;
}
else{
(ds.p=0x00E4B81A/*l1208c13/string.e*/);
_new_capacity=r2_ix_42(&ds,INT8_C(2),(/*RF2*/(C)->_capacity/*9*/));
(ds.p=0x00E4B91A/*l1209c13/string.e*/);
/*SFN*/(C->_storage/*1*/)=r9realloc(&ds,(/*RF2*/(C)->_storage/*1*/),(/*RF2*/(C)->_capacity/*9*/),_new_capacity);
(ds.p=0x00E4BA1A/*l1210c13/string.e*/);
/*SFN*/(C->_capacity/*9*/)=_new_capacity;
}
/*FI]*/
(ds.p=0x00E4BC24/*l1212c18/string.e*/);
((/*RF2*/(C)->_storage/*1*/))[(/*RF2*/(C)->_count/*5*/)]=(a1);
(ds.p=0x00E4BD14/*l1213c10/string.e*/);
/*SFN*/(C->_count/*5*/)=r2_ix_43(&ds,(/*RF2*/(C)->_count/*5*/),INT8_C(1));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x00E4BF20/*l1215c16/string.e*/);
ac_ens(((/*RF2*/(C)->_count/*5*/))==(r2_ix_43(&ds,/*IC*/(T2)(INT8_C(1)),o7_1215_26)),NULL);
(ds.p=0x00E4C02E/*l1216c23/string.e*/);
ac_ens((r7item(&ds,C,(/*RF2*/(C)->_count/*5*/)))==(a1),NULL);
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}

/*STRING*/
void r7clear(se_dump_stack*caller,T7* C){
static se_frame_descriptor fd={"clear STRING",1,0,"%R7%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x00E3BA08/*l954c4/string.e*/;
ds.caller=caller;
ds.locals=NULL;
ds.exception_origin=NULL;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x00E3BE14/*l958c10/string.e*/);
/*SFN*/(C->_count/*5*/)=INT8_C(0);
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x00E3C020/*l960c16/string.e*/);
ac_ens(((/*RF2*/(C)->_count/*5*/))==(INT8_C(0)),NULL);
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}

/*STRING*/
T8 r7to_external(se_dump_stack*caller,T7* C){
T8 R=NULL;
T2 o7_1752_22=0;
void**locals[2];
static se_frame_descriptor fd={"to_external STRING",1,2,"%R7%Result%E8%old value%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x00E6C708/*l1735c4/string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
locals[1]=(void**)&o7_1752_22;
set_dump_stack_top(&ds);/*link*/
o7_1752_22=(/*RF2*/(C)->_count/*5*/);
/*[IF*/
if(((ds.p=0x00E6CD2C/*l1741c22/string.e*/),(int32_t)(((/*RF2*/(C)->_capacity/*9*/))>((/*RF2*/(C)->_count/*5*/))))){
(ds.p=0x00E6CE1A/*l1742c13/string.e*/);
/*SFN*/(C->_count/*5*/)=r2_ix_43(&ds,(/*RF2*/(C)->_count/*5*/),INT8_C(1));
/*[IF*/
if(((ds.p=0x00E6CF38/*l1743c28/string.e*/),(r7item(&ds,C,(/*RF2*/(C)->_count/*5*/)))!=(((T3)'\000')))){
(ds.p=0x00E6D020/*l1744c16/string.e*/);
r7put(&ds,C,((T3)'\000'),(/*RF2*/(C)->_count/*5*/));
}
/*FI]*/
}
else{
(ds.p=0x00E6D31A/*l1747c13/string.e*/);
r7append_character(&ds,C,((T3)'\000'));
}
/*FI]*/
(ds.p=0x00E6D514/*l1749c10/string.e*/);
/*SFN*/(C->_count/*5*/)=r2_ix_45(&ds,(/*RF2*/(C)->_count/*5*/),INT8_C(1));
(ds.p=0x00E6D614/*l1750c10/string.e*/);
R=((void*)((/*RF2*/(C)->_storage/*1*/)));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x00E6D820/*l1752c16/string.e*/);
ac_ens(((/*RF2*/(C)->_count/*5*/))==(o7_1752_22),NULL);
(ds.p=0x00E6D922/*l1753c17/string.e*/);
ac_ens((NULL!=R),NULL);
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*STRING*/
T0* r7default(se_dump_stack*caller,T7* C){
T0* R=NULL;
void**locals[1];
static se_frame_descriptor fd={"default GENERAL",1,1,"%R7%Result%R7%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x01E10816/*l264c11/general.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*STRING*/
T6 r7_ix_60(se_dump_stack*caller,T7* C,T0* a1){
T6 R=0;
T2 _i=0;
T2 _maxi=0;
void**locals[4];
static se_frame_descriptor fd={"infix < STRING",1,4,"%R7%other%R7%Result%E6%i%E2%maxi%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x00E09808/*l152c4/string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
locals[2]=(void**)&_i;
locals[3]=(void**)&_maxi;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02E0273C/*l39c30/comparable.e*/);
ac_req((a1)!=((void*)(NULL)),"other_exists");
fd.assertion_flag=1;
}
(ds.p=0x00E09F1A/*l159c13/string.e*/);
_i=INT8_C(1);
(ds.p=0x00E0A00C/*l160c6/string.e*/);
_maxi=r2min(&ds,(/*RF2*/(C)->_count/*5*/),(/*RF2*/(se_i7(&ds,((T7*)ci(7,a1,0x00E0A030/*l160c24/string.e*/))))->_count/*5*/));
while (!(((ds.p=0x00E0A22C/*l162c22/string.e*/),(T6)(((int32_t)((_i)>(_maxi)))||((T6)((r7item(&ds,C,_i))!=(r7item(&ds,se_i7(&ds,((T7*)ci(7,a1,0x00E0A252/*l162c41/string.e*/))),_i))))))))
{
(ds.p=0x00E0A41A/*l164c13/string.e*/);
_i=r2_ix_43(&ds,_i,INT8_C(1));
}
/*[IF*/
if(((ds.p=0x00E0A610/*l166c8/string.e*/),(int32_t)((_i)<=(_maxi)))){
(ds.p=0x00E0A70C/*l167c6/string.e*/);
R=((T6)(r3_ix_60(&ds,r7item(&ds,C,_i),r7item(&ds,se_i7(&ds,((T7*)ci(7,a1,0x00E0A734/*l167c26/string.e*/))),_i))));
}
else{
(ds.p=0x00E0A90C/*l169c6/string.e*/);
R=((T6)((int32_t)((_i)<=((/*RF2*/(se_i7(&ds,((T7*)ci(7,a1,0x00E0A92A/*l169c21/string.e*/))))->_count/*5*/)))));
}
/*FI]*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02E02A3A/*l42c29/comparable.e*/);
ac_ens((T6)((!(R))||((T6)(r6_px_not(&ds,(T6)(r7_ix_60(&ds,se_i7(&ds,((T7*)ci(7,a1,0x02E02A54/*l42c42/comparable.e*/))),(T0*)C)))))),"asymmetric");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*STRING*/
void r7swap(se_dump_stack*caller,T7* C,T2 a1,T2 a2){
T3 _tmp=0;
T3 o7_1121_25=0;
T3 o7_1122_25=0;
void**locals[5];
static se_frame_descriptor fd={"swap STRING",1,5,"%R7%i1%E2%i2%E2%tmp%E3%old value%E3%old value%E3%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x00E45608/*l1110c4/string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&_tmp;
locals[3]=(void**)&o7_1121_25;
locals[4]=(void**)&o7_1122_25;
set_dump_stack_top(&ds);/*link*/
o7_1121_25=r7item(&ds,C,a2);
o7_1122_25=r7item(&ds,C,a1);
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x00E45814/*l1112c10/string.e*/);
ac_req(r7valid_index(&ds,C,a1),NULL);
(ds.p=0x00E45914/*l1113c10/string.e*/);
ac_req(r7valid_index(&ds,C,a2),NULL);
fd.assertion_flag=1;
}
(ds.p=0x00E45D14/*l1117c10/string.e*/);
_tmp=r7item(&ds,C,a1);
(ds.p=0x00E45E14/*l1118c10/string.e*/);
r7put(&ds,C,r7item(&ds,C,a2),a1);
(ds.p=0x00E45F14/*l1119c10/string.e*/);
r7put(&ds,C,_tmp,a2);
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x00E46126/*l1121c19/string.e*/);
ac_ens((r7item(&ds,C,a1))==(o7_1121_25),NULL);
(ds.p=0x00E46226/*l1122c19/string.e*/);
ac_ens((r7item(&ds,C,a2))==(o7_1122_25),NULL);
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}
se_frame_descriptor se_ifd7={"invariant STRING",1,0,"%R7%",1};

T7*se_i7(se_dump_stack*caller,T7*C){
se_dump_stack ds;
ds.fd=&se_ifd7;
ds.current=((void**)&C);
ds.p=0x00E0130E/*l19c7/string.e*/;
ds.caller=caller;
ds.exception_origin=NULL;
ds.locals=NULL;
se_dst=&ds;/*link*/
if(ds.fd->assertion_flag){
ds.fd->assertion_flag=0;
(ds.p=0x00E7560C/*l1878c6/string.e*/);
ac_inv((int32_t)((/*IC*/(T2)(INT8_C(0)))<=((/*RF2*/(C)->_count/*5*/))),NULL);
(ds.p=0x00E75814/*l1880c10/string.e*/);
ac_inv((int32_t)(((/*RF2*/(C)->_count/*5*/))<=((/*RF2*/(C)->_capacity/*9*/))),NULL);
(ds.p=0x00E75A22/*l1882c17/string.e*/);
ac_inv((T6)((!((int32_t)(((/*RF2*/(C)->_capacity/*9*/))>(/*IC*/(T2)(INT8_C(0))))))||((T6)(r9is_not_null(&ds,(/*RF2*/(C)->_storage/*1*/))))),NULL);
ds.fd->assertion_flag=1;
}
se_dst=caller;/*unlink*/
return C;
}

/*ARRAY[INTEGER]*/
void r44copy(se_dump_stack*caller,T44* C,T0* a1){
T2 _needed_capacity=0;
void**locals[2];
static se_frame_descriptor fd={"copy ARRAY",1,2,"%R44%other%R44%needed_capacity%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x0220C608/*l198c4/array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&_needed_capacity;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x01E0CF06/*l207c3/general.e*/);
ac_req(/*same_dynamic_type*/(((vc(((T0*)(C)),0))->id)==((vc(((T0*)(a1)),0))->id)),NULL);
fd.assertion_flag=1;
}
(ds.p=0x0220CA14/*l202c10/array.e*/);
/*SFN*/(C->_lower/*13*/)=(/*RF2*/(se_i44(&ds,((T44*)ci(44,a1,0x0220CA26/*l202c19/array.e*/))))->_lower/*13*/);
(ds.p=0x0220CB14/*l203c10/array.e*/);
/*SFN*/(C->_upper/*9*/)=(/*RF2*/(se_i44(&ds,((T44*)ci(44,a1,0x0220CB26/*l203c19/array.e*/))))->_upper/*9*/);
(ds.p=0x0220CC14/*l204c10/array.e*/);
_needed_capacity=r2_ix_43(&ds,r2_ix_45(&ds,(/*RF2*/(C)->_upper/*9*/),(/*RF2*/(C)->_lower/*13*/)),INT8_C(1));
/*[IF*/
if(((ds.p=0x0220CD2C/*l205c22/array.e*/),(int32_t)(((/*RF2*/(C)->_capacity/*5*/))<(_needed_capacity)))){
(ds.p=0x0220CE1A/*l206c13/array.e*/);
/*SFN*/(C->_storage/*1*/)=new45(_needed_capacity);
(ds.p=0x0220CF1A/*l207c13/array.e*/);
/*SFN*/(C->_capacity/*5*/)=_needed_capacity;
}
/*FI]*/
/*[IF*/
if(((ds.p=0x0220D13A/*l209c29/array.e*/),(int32_t)((_needed_capacity)>(INT8_C(0))))){
(ds.p=0x0220D22A/*l210c21/array.e*/);
r45copy_from(&ds,(/*RF2*/(C)->_storage/*1*/),(/*RF2*/(se_i44(&ds,((T44*)ci(44,a1,0x0220D23E/*l210c31/array.e*/))))->_storage/*1*/),r2_ix_45(&ds,_needed_capacity,/*IC*/(T2)(INT8_C(1))));
}
/*FI]*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x01E0D214/*l210c10/general.e*/);
ac_ens(r44is_equal(&ds,C,a1),NULL);
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i44(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}

/*ARRAY[INTEGER]*/
void r44clear_all(se_dump_stack*caller,T44* C){
T2 _value=0;
T2 o19_163_29=0;
T2 o19_164_29=0;
void**locals[3];
static se_frame_descriptor fd={"clear_all COLLECTION",1,3,"%R44%value%E2%old value%E2%old value%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x02609B08/*l155c4/collection.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&_value;
locals[1]=(void**)&o19_163_29;
locals[2]=(void**)&o19_164_29;
set_dump_stack_top(&ds);/*link*/
o19_163_29=(/*RF2*/(C)->_upper/*9*/);
o19_164_29=(/*RF2*/(C)->_lower/*13*/);
(ds.p=0x0260A114/*l161c10/collection.e*/);
r44set_all_with(&ds,C,_value);
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x0260A32E/*l163c23/collection.e*/);
ac_ens(((/*RF2*/(C)->_upper/*9*/))==(o19_163_29),"stable_upper");
(ds.p=0x0260A42E/*l164c23/collection.e*/);
ac_ens(((/*RF2*/(C)->_lower/*13*/))==(o19_164_29),"stable_lower");
(ds.p=0x0260A514/*l165c10/collection.e*/);
ac_ens(r44all_default(&ds,C),NULL);
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i44(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}

/*ARRAY[INTEGER]*/
T2 r44last(se_dump_stack*caller,T44* C){
T2 R=0;
void**locals[1];
static se_frame_descriptor fd={"last ARRAYED_COLLECTION",1,1,"%R44%Result%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x02403D08/*l61c4/arrayed_collection.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02605C14/*l92c10/collection.e*/);
ac_req(r6_px_not(&ds,(T6)(r44is_empty(&ds,C))),NULL);
fd.assertion_flag=1;
}
(ds.p=0x02403F14/*l63c10/arrayed_collection.e*/);
R=r44item(&ds,C,(/*RF2*/(C)->_upper/*9*/));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02605F22/*l95c17/collection.e*/);
ac_ens((R)==(r44item(&ds,C,(/*RF2*/(C)->_upper/*9*/))),NULL);
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i44(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*ARRAY[INTEGER]*/
T2 r44count(se_dump_stack*caller,T44* C){
T2 R=0;
void**locals[1];
static se_frame_descriptor fd={"count ARRAY",1,1,"%R44%Result%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x0220A208/*l162c4/array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x0220A414/*l164c10/array.e*/);
R=r2_ix_43(&ds,r2_ix_45(&ds,(/*RF2*/(C)->_upper/*9*/),(/*RF2*/(C)->_lower/*13*/)),INT8_C(1));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02603D22/*l61c17/collection.e*/);
ac_ens((R)==(r2_ix_43(&ds,r2_ix_45(&ds,(/*RF2*/(C)->_upper/*9*/),(/*RF2*/(C)->_lower/*13*/)),/*IC*/(T2)(INT8_C(1)))),NULL);
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i44(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*ARRAY[INTEGER]*/
void r44put(se_dump_stack*caller,T44* C,T2 a1,T2 a2){
T2 o19_107_22=0;
void**locals[3];
static se_frame_descriptor fd={"put ARRAY",1,3,"%R44%element%E2%i%E2%old value%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x0220AC08/*l172c4/array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&o19_107_22;
set_dump_stack_top(&ds);/*link*/
o19_107_22=r44count(&ds,C);
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02606714/*l103c10/collection.e*/);
ac_req(r44valid_index(&ds,C,a2),NULL);
fd.assertion_flag=1;
}
(ds.p=0x0220AE24/*l174c18/array.e*/);
((/*RF2*/(C)->_storage/*1*/))[r2_ix_45(&ds,a2,(/*RF2*/(C)->_lower/*13*/))]=(a1);
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02606A24/*l106c18/collection.e*/);
ac_ens((r44item(&ds,C,a2))==(a1),NULL);
(ds.p=0x02606B20/*l107c16/collection.e*/);
ac_ens((r44count(&ds,C))==(o19_107_22),NULL);
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i44(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}

/*ARRAY[INTEGER]*/
T6 r44is_equal(se_dump_stack*caller,T44* C,T0* a1){
T6 R=0;
void**locals[2];
static se_frame_descriptor fd={"is_equal ARRAY",1,2,"%R44%other%R44%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x02213B08/*l315c4/array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x01E07720/*l119c16/general.e*/);
ac_req((a1)!=((void*)(NULL)),NULL);
fd.assertion_flag=1;
}
/*[IF*/
if((C)==((void*)(a1))){
(ds.p=0x02213E1A/*l318c13/array.e*/);
R=((T6)(1));
}
 else if(((ds.p=0x02213F4A/*l319c37/array.e*/),(T6)((((/*RF2*/(C)->_lower/*13*/))==((/*RF2*/(se_i44(&ds,((T44*)ci(44,a1,0x02213F32/*l319c25/array.e*/))))->_lower/*13*/)))&&((T6)(((/*RF2*/(C)->_upper/*9*/))==((/*RF2*/(se_i44(&ds,((T44*)ci(44,a1,0x02213F6C/*l319c54/array.e*/))))->_upper/*9*/))))))){
(ds.p=0x0221401A/*l320c13/array.e*/);
R=((T6)(r45fast_memcmp(&ds,(/*RF2*/(C)->_storage/*1*/),(/*RF2*/(se_i44(&ds,((T44*)ci(44,a1,0x02214056/*l320c43/array.e*/))))->_storage/*1*/),r44count(&ds,C))));
}
/*FI]*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02615914/*l345c10/collection.e*/);
ac_ens((T6)((!(R))||((T6)(r6_ix_and(&ds,(T6)(((/*RF2*/(C)->_lower/*13*/))==((/*RF2*/(se_i44(&ds,((T44*)ci(44,a1,0x02615936/*l345c27/collection.e*/))))->_lower/*13*/))),(T6)(((/*RF2*/(C)->_upper/*9*/))==((/*RF2*/(se_i44(&ds,((T44*)ci(44,a1,0x02615966/*l345c51/collection.e*/))))->_upper/*9*/))))))),NULL);
(ds.p=0x01E07A64/*l122c50/general.e*/);
ac_ens((T6)((!(((T0*)(t[(C)->id]))==((void*)((T0*)(t[((T44*)a1)->id])))))||((T6)((R)==(r44is_equal(&ds,se_i44(&ds,((T44*)ci(44,a1,0x01E07B20/*l123c16/general.e*/))),(T0*)C))))),NULL);
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i44(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*ARRAY[INTEGER]*/
T2 r44item(se_dump_stack*caller,T44* C,T2 a1){
T2 R=0;
void**locals[2];
static se_frame_descriptor fd={"item ARRAY",1,2,"%R44%i%E2%Result%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x0220A708/*l167c4/array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02604C14/*l76c10/collection.e*/);
ac_req(r44valid_index(&ds,C,a1),NULL);
fd.assertion_flag=1;
}
(ds.p=0x0220A914/*l169c10/array.e*/);
R=((/*RF2*/(C)->_storage/*1*/))[r2_ix_45(&ds,a1,(/*RF2*/(C)->_lower/*13*/))];
if(se_rci(caller,C))se_i44(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*ARRAY[INTEGER]*/
T6 r44valid_index(se_dump_stack*caller,T44* C,T2 a1){
T6 R=0;
void**locals[2];
static se_frame_descriptor fd={"valid_index COLLECTION",1,2,"%R44%index%E2%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x02602E16/*l46c11/collection.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x02603214/*l50c10/collection.e*/);
R=((T6)((T6)(((int32_t)(((/*RF2*/(C)->_lower/*13*/))<=(a1)))&&((T6)((int32_t)((a1)<=((/*RF2*/(C)->_upper/*9*/))))))));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02603422/*l52c17/collection.e*/);
ac_ens((R)==((T6)(((int32_t)(((/*RF2*/(C)->_lower/*13*/))<=(a1)))&&((T6)((int32_t)((a1)<=((/*RF2*/(C)->_upper/*9*/))))))),NULL);
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i44(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*ARRAY[INTEGER]*/
void r44make(se_dump_stack*caller,T44* C,T2 a1,T2 a2){
T2 _needed=0;
void**locals[3];
static se_frame_descriptor fd={"make ARRAY",1,3,"%R44%min_index%E2%max_index%E2%needed%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x02202308/*l35c4/array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&_needed;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02202844/*l40c34/array.e*/);
ac_req((int32_t)((a1)<=(r2_ix_43(&ds,a2,/*IC*/(T2)(INT8_C(1))))),"valid_bounds");
fd.assertion_flag=1;
}
(ds.p=0x02202C14/*l44c10/array.e*/);
/*SFN*/(C->_lower/*13*/)=a1;
(ds.p=0x02202D14/*l45c10/array.e*/);
/*SFN*/(C->_upper/*9*/)=a2;
(ds.p=0x02202E14/*l46c10/array.e*/);
_needed=r2_ix_43(&ds,r2_ix_45(&ds,a2,a1),INT8_C(1));
/*[IF*/
if(((ds.p=0x02202F28/*l47c20/array.e*/),(int32_t)((_needed)>(INT8_C(0))))){
/*[IF*/
if(((ds.p=0x02203032/*l48c25/array.e*/),(int32_t)(((/*RF2*/(C)->_capacity/*5*/))<(_needed)))){
(ds.p=0x02203120/*l49c16/array.e*/);
/*SFN*/(C->_storage/*1*/)=new45(_needed);
(ds.p=0x02203220/*l50c16/array.e*/);
/*SFN*/(C->_capacity/*5*/)=_needed;
}
else{
(ds.p=0x02203420/*l52c16/array.e*/);
r44clear_all(&ds,C);
}
/*FI]*/
}
/*FI]*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02203836/*l56c27/array.e*/);
ac_ens(((/*RF2*/(C)->_lower/*13*/))==(a1),"lower_set");
(ds.p=0x02203936/*l57c27/array.e*/);
ac_ens(((/*RF2*/(C)->_upper/*9*/))==(a2),"upper_set");
(ds.p=0x02203A2A/*l58c21/array.e*/);
ac_ens(r44all_default(&ds,C),"items_set");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i44(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}

/*ARRAY[INTEGER]*/
T6 r44is_empty(se_dump_stack*caller,T44* C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"is_empty ARRAY",1,1,"%R44%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x02209D08/*l157c4/array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x02209F14/*l159c10/array.e*/);
R=((T6)((int32_t)(((/*RF2*/(C)->_upper/*9*/))<((/*RF2*/(C)->_lower/*13*/)))));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02604414/*l68c10/collection.e*/);
ac_ens((R)==((r44count(&ds,C))==(INT8_C(0))),NULL);
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i44(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*ARRAY[INTEGER]*/
void r44set_all_with(se_dump_stack*caller,T44* C,T2 a1){
T2 o19_131_22=0;
void**locals[2];
static se_frame_descriptor fd={"set_all_with ARRAY",1,2,"%R44%v%E2%old value%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x0220D608/*l214c4/array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&o19_131_22;
set_dump_stack_top(&ds);/*link*/
o19_131_22=r44count(&ds,C);
(ds.p=0x0220D824/*l216c18/array.e*/);
r45set_all_with(&ds,(/*RF2*/(C)->_storage/*1*/),a1,r2_ix_45(&ds,(/*RF2*/(C)->_upper/*9*/),(/*RF2*/(C)->_lower/*13*/)));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02608320/*l131c16/collection.e*/);
ac_ens((r44count(&ds,C))==(o19_131_22),NULL);
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i44(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}

/*ARRAY[INTEGER]*/
void r44add_last(se_dump_stack*caller,T44* C,T2 a1){
T2 _new_capacity=0;
T2 o19_186_26=0;
T2 o19_187_22=0;
T2 o19_188_26=0;
void**locals[5];
static se_frame_descriptor fd={"add_last ARRAY",1,5,"%R44%element%E2%new_capacity%E2%old value%E2%old value%E2%old value%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x0220FB08/*l251c4/array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&_new_capacity;
locals[2]=(void**)&o19_186_26;
locals[3]=(void**)&o19_187_22;
locals[4]=(void**)&o19_188_26;
set_dump_stack_top(&ds);/*link*/
o19_186_26=r44count(&ds,C);
o19_187_22=(/*RF2*/(C)->_lower/*13*/);
o19_188_26=(/*RF2*/(C)->_upper/*9*/);
/*[IF*/
if(((ds.p=0x0220FF2C/*l255c22/array.e*/),(int32_t)(((/*RF2*/(C)->_capacity/*5*/))<(r2_ix_43(&ds,r44count(&ds,C),INT8_C(1)))))){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*5*/))==(INT8_C(0))){
(ds.p=0x02210120/*l257c16/array.e*/);
_new_capacity=INT8_C(16);
(ds.p=0x02210220/*l258c16/array.e*/);
/*SFN*/(C->_storage/*1*/)=new45(_new_capacity);
(ds.p=0x02210320/*l259c16/array.e*/);
/*SFN*/(C->_capacity/*5*/)=_new_capacity;
}
else{
(ds.p=0x02210520/*l261c16/array.e*/);
_new_capacity=r2_ix_42(&ds,INT8_C(2),(/*RF2*/(C)->_capacity/*5*/));
(ds.p=0x02210620/*l262c16/array.e*/);
/*SFN*/(C->_storage/*1*/)=r45realloc(&ds,(/*RF2*/(C)->_storage/*1*/),(/*RF2*/(C)->_capacity/*5*/),_new_capacity);
(ds.p=0x02210720/*l263c16/array.e*/);
/*SFN*/(C->_capacity/*5*/)=_new_capacity;
}
/*FI]*/
}
/*FI]*/
(ds.p=0x02210A14/*l266c10/array.e*/);
/*SFN*/(C->_upper/*9*/)=r2_ix_43(&ds,(/*RF2*/(C)->_upper/*9*/),INT8_C(1));
(ds.p=0x02210B14/*l267c10/array.e*/);
r44put(&ds,C,a1,(/*RF2*/(C)->_upper/*9*/));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x0260B91E/*l185c15/collection.e*/);
ac_ens((r44last(&ds,C))==(a1),NULL);
(ds.p=0x0260BA20/*l186c16/collection.e*/);
ac_ens((r44count(&ds,C))==(r2_ix_43(&ds,/*IC*/(T2)(INT8_C(1)),o19_186_26)),NULL);
(ds.p=0x0260BB20/*l187c16/collection.e*/);
ac_ens(((/*RF2*/(C)->_lower/*13*/))==(o19_187_22),NULL);
(ds.p=0x0260BC20/*l188c16/collection.e*/);
ac_ens(((/*RF2*/(C)->_upper/*9*/))==(r2_ix_43(&ds,/*IC*/(T2)(INT8_C(1)),o19_188_26)),NULL);
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i44(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}

/*ARRAY[INTEGER]*/
T6 r44all_default(se_dump_stack*caller,T44* C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"all_default ARRAY",1,1,"%R44%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x02212208/*l290c4/array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x02212414/*l292c10/array.e*/);
R=((T6)(r45all_default(&ds,(/*RF2*/(C)->_storage/*1*/),r2_ix_45(&ds,(/*RF2*/(C)->_upper/*9*/),(/*RF2*/(C)->_lower/*13*/)))));
if(se_rci(caller,C))se_i44(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*ARRAY[INTEGER]*/
T0* r44twin(se_dump_stack*caller,T44* C){
T0* R=NULL;
void**locals[1];
static se_frame_descriptor fd={"twin GENERAL",1,1,"%R44%Result%R44%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x01E0BF16/*l191c11/general.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
R=((void*)new44());
r44copy(&ds,((T44*)R),((T0*)C));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x01E0C730/*l199c24/general.e*/);
ac_ens(r44is_equal(&ds,se_i44(&ds,((T44*)ci(44,R,0x01E0C722/*l199c17/general.e*/))),(T0*)C),"equal");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i44(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}
se_frame_descriptor se_ifd44={"invariant ARRAY[INTEGER]",1,0,"%R44%",1};

T44*se_i44(se_dump_stack*caller,T44*C){
se_dump_stack ds;
ds.fd=&se_ifd44;
ds.current=((void**)&C);
ds.p=0x0220130E/*l19c7/array.e*/;
ds.caller=caller;
ds.exception_origin=NULL;
ds.locals=NULL;
se_dst=&ds;/*link*/
if(ds.fd->assertion_flag){
ds.fd->assertion_flag=0;
(ds.p=0x02624C30/*l588c24/collection.e*/);
ac_inv((int32_t)(((/*RF2*/(C)->_lower/*13*/))<=(r2_ix_43(&ds,(/*RF2*/(C)->_upper/*9*/),/*IC*/(T2)(INT8_C(1))))),"valid_bounds");
(ds.p=0x0240751A/*l117c13/arrayed_collection.e*/);
ac_inv((int32_t)(((/*RF2*/(C)->_capacity/*5*/))>=(r2_ix_43(&ds,r2_ix_45(&ds,(/*RF2*/(C)->_upper/*9*/),(/*RF2*/(C)->_lower/*13*/)),/*IC*/(T2)(INT8_C(1))))),NULL);
(ds.p=0x02407722/*l119c17/arrayed_collection.e*/);
ac_inv((T6)((!((int32_t)(((/*RF2*/(C)->_capacity/*5*/))>(/*IC*/(T2)(INT8_C(0))))))||((T6)(r45is_not_null(&ds,(/*RF2*/(C)->_storage/*1*/))))),NULL);
ds.fd->assertion_flag=1;
}
se_dst=caller;/*unlink*/
return C;
}

/*ARRAY[RULE]*/
void r31clear_all(se_dump_stack*caller,T31* C){
T0* _value=NULL;
T2 o19_163_29=0;
T2 o19_164_29=0;
void**locals[3];
static se_frame_descriptor fd={"clear_all COLLECTION",1,3,"%R31%value%R16%old value%E2%old value%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x02609B08/*l155c4/collection.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&_value;
locals[1]=(void**)&o19_163_29;
locals[2]=(void**)&o19_164_29;
set_dump_stack_top(&ds);/*link*/
o19_163_29=(/*RF2*/(C)->_upper/*9*/);
o19_164_29=(/*RF2*/(C)->_lower/*13*/);
(ds.p=0x0260A114/*l161c10/collection.e*/);
r31set_all_with(&ds,C,_value);
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x0260A32E/*l163c23/collection.e*/);
ac_ens(((/*RF2*/(C)->_upper/*9*/))==(o19_163_29),"stable_upper");
(ds.p=0x0260A42E/*l164c23/collection.e*/);
ac_ens(((/*RF2*/(C)->_lower/*13*/))==(o19_164_29),"stable_lower");
(ds.p=0x0260A514/*l165c10/collection.e*/);
ac_ens(r31all_default(&ds,C),NULL);
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i31(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}

/*ARRAY[RULE]*/
T0* r31last(se_dump_stack*caller,T31* C){
T0* R=NULL;
void**locals[1];
static se_frame_descriptor fd={"last ARRAYED_COLLECTION",1,1,"%R31%Result%R16%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x02403D08/*l61c4/arrayed_collection.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02605C14/*l92c10/collection.e*/);
ac_req(r6_px_not(&ds,(T6)(r31is_empty(&ds,C))),NULL);
fd.assertion_flag=1;
}
(ds.p=0x02403F14/*l63c10/arrayed_collection.e*/);
R=r31item(&ds,C,(/*RF2*/(C)->_upper/*9*/));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02605F22/*l95c17/collection.e*/);
ac_ens((R)==((void*)(r31item(&ds,C,(/*RF2*/(C)->_upper/*9*/)))),NULL);
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i31(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*ARRAY[RULE]*/
T2 r31count(se_dump_stack*caller,T31* C){
T2 R=0;
void**locals[1];
static se_frame_descriptor fd={"count ARRAY",1,1,"%R31%Result%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x0220A208/*l162c4/array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x0220A414/*l164c10/array.e*/);
R=r2_ix_43(&ds,r2_ix_45(&ds,(/*RF2*/(C)->_upper/*9*/),(/*RF2*/(C)->_lower/*13*/)),INT8_C(1));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02603D22/*l61c17/collection.e*/);
ac_ens((R)==(r2_ix_43(&ds,r2_ix_45(&ds,(/*RF2*/(C)->_upper/*9*/),(/*RF2*/(C)->_lower/*13*/)),/*IC*/(T2)(INT8_C(1)))),NULL);
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i31(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*ARRAY[RULE]*/
void r31put(se_dump_stack*caller,T31* C,T0* a1,T2 a2){
T2 o19_107_22=0;
void**locals[3];
static se_frame_descriptor fd={"put ARRAY",1,3,"%R31%element%R16%i%E2%old value%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x0220AC08/*l172c4/array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&o19_107_22;
set_dump_stack_top(&ds);/*link*/
o19_107_22=r31count(&ds,C);
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02606714/*l103c10/collection.e*/);
ac_req(r31valid_index(&ds,C,a2),NULL);
fd.assertion_flag=1;
}
(ds.p=0x0220AE24/*l174c18/array.e*/);
((/*RF2*/(C)->_storage/*1*/))[r2_ix_45(&ds,a2,(/*RF2*/(C)->_lower/*13*/))]=(a1);
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02606A24/*l106c18/collection.e*/);
ac_ens((r31item(&ds,C,a2))==((void*)(a1)),NULL);
(ds.p=0x02606B20/*l107c16/collection.e*/);
ac_ens((r31count(&ds,C))==(o19_107_22),NULL);
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i31(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}

/*ARRAY[RULE]*/
T0* r31item(se_dump_stack*caller,T31* C,T2 a1){
T0* R=NULL;
void**locals[2];
static se_frame_descriptor fd={"item ARRAY",1,2,"%R31%i%E2%Result%R16%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x0220A708/*l167c4/array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02604C14/*l76c10/collection.e*/);
ac_req(r31valid_index(&ds,C,a1),NULL);
fd.assertion_flag=1;
}
(ds.p=0x0220A914/*l169c10/array.e*/);
R=((/*RF2*/(C)->_storage/*1*/))[r2_ix_45(&ds,a1,(/*RF2*/(C)->_lower/*13*/))];
if(se_rci(caller,C))se_i31(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*ARRAY[RULE]*/
T6 r31valid_index(se_dump_stack*caller,T31* C,T2 a1){
T6 R=0;
void**locals[2];
static se_frame_descriptor fd={"valid_index COLLECTION",1,2,"%R31%index%E2%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x02602E16/*l46c11/collection.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x02603214/*l50c10/collection.e*/);
R=((T6)((T6)(((int32_t)(((/*RF2*/(C)->_lower/*13*/))<=(a1)))&&((T6)((int32_t)((a1)<=((/*RF2*/(C)->_upper/*9*/))))))));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02603422/*l52c17/collection.e*/);
ac_ens((R)==((T6)(((int32_t)(((/*RF2*/(C)->_lower/*13*/))<=(a1)))&&((T6)((int32_t)((a1)<=((/*RF2*/(C)->_upper/*9*/))))))),NULL);
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i31(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*ARRAY[RULE]*/
void r31make(se_dump_stack*caller,T31* C,T2 a1,T2 a2){
T2 _needed=0;
void**locals[3];
static se_frame_descriptor fd={"make ARRAY",1,3,"%R31%min_index%E2%max_index%E2%needed%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x02202308/*l35c4/array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&_needed;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02202844/*l40c34/array.e*/);
ac_req((int32_t)((a1)<=(r2_ix_43(&ds,a2,/*IC*/(T2)(INT8_C(1))))),"valid_bounds");
fd.assertion_flag=1;
}
(ds.p=0x02202C14/*l44c10/array.e*/);
/*SFN*/(C->_lower/*13*/)=a1;
(ds.p=0x02202D14/*l45c10/array.e*/);
/*SFN*/(C->_upper/*9*/)=a2;
(ds.p=0x02202E14/*l46c10/array.e*/);
_needed=r2_ix_43(&ds,r2_ix_45(&ds,a2,a1),INT8_C(1));
/*[IF*/
if(((ds.p=0x02202F28/*l47c20/array.e*/),(int32_t)((_needed)>(INT8_C(0))))){
/*[IF*/
if(((ds.p=0x02203032/*l48c25/array.e*/),(int32_t)(((/*RF2*/(C)->_capacity/*5*/))<(_needed)))){
(ds.p=0x02203120/*l49c16/array.e*/);
/*SFN*/(C->_storage/*1*/)=new33(_needed);
(ds.p=0x02203220/*l50c16/array.e*/);
/*SFN*/(C->_capacity/*5*/)=_needed;
}
else{
(ds.p=0x02203420/*l52c16/array.e*/);
r31clear_all(&ds,C);
}
/*FI]*/
}
/*FI]*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02203836/*l56c27/array.e*/);
ac_ens(((/*RF2*/(C)->_lower/*13*/))==(a1),"lower_set");
(ds.p=0x02203936/*l57c27/array.e*/);
ac_ens(((/*RF2*/(C)->_upper/*9*/))==(a2),"upper_set");
(ds.p=0x02203A2A/*l58c21/array.e*/);
ac_ens(r31all_default(&ds,C),"items_set");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i31(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}

/*ARRAY[RULE]*/
T6 r31is_empty(se_dump_stack*caller,T31* C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"is_empty ARRAY",1,1,"%R31%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x02209D08/*l157c4/array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x02209F14/*l159c10/array.e*/);
R=((T6)((int32_t)(((/*RF2*/(C)->_upper/*9*/))<((/*RF2*/(C)->_lower/*13*/)))));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02604414/*l68c10/collection.e*/);
ac_ens((R)==((r31count(&ds,C))==(INT8_C(0))),NULL);
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i31(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*ARRAY[RULE]*/
void r31set_all_with(se_dump_stack*caller,T31* C,T0* a1){
T2 o19_131_22=0;
void**locals[2];
static se_frame_descriptor fd={"set_all_with ARRAY",1,2,"%R31%v%R16%old value%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x0220D608/*l214c4/array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&o19_131_22;
set_dump_stack_top(&ds);/*link*/
o19_131_22=r31count(&ds,C);
(ds.p=0x0220D824/*l216c18/array.e*/);
r33set_all_with(&ds,(/*RF2*/(C)->_storage/*1*/),a1,r2_ix_45(&ds,(/*RF2*/(C)->_upper/*9*/),(/*RF2*/(C)->_lower/*13*/)));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02608320/*l131c16/collection.e*/);
ac_ens((r31count(&ds,C))==(o19_131_22),NULL);
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i31(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}

/*ARRAY[RULE]*/
void r31add_last(se_dump_stack*caller,T31* C,T0* a1){
T2 _new_capacity=0;
T2 o19_186_26=0;
T2 o19_187_22=0;
T2 o19_188_26=0;
void**locals[5];
static se_frame_descriptor fd={"add_last ARRAY",1,5,"%R31%element%R16%new_capacity%E2%old value%E2%old value%E2%old value%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x0220FB08/*l251c4/array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&_new_capacity;
locals[2]=(void**)&o19_186_26;
locals[3]=(void**)&o19_187_22;
locals[4]=(void**)&o19_188_26;
set_dump_stack_top(&ds);/*link*/
o19_186_26=r31count(&ds,C);
o19_187_22=(/*RF2*/(C)->_lower/*13*/);
o19_188_26=(/*RF2*/(C)->_upper/*9*/);
/*[IF*/
if(((ds.p=0x0220FF2C/*l255c22/array.e*/),(int32_t)(((/*RF2*/(C)->_capacity/*5*/))<(r2_ix_43(&ds,r31count(&ds,C),INT8_C(1)))))){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*5*/))==(INT8_C(0))){
(ds.p=0x02210120/*l257c16/array.e*/);
_new_capacity=INT8_C(16);
(ds.p=0x02210220/*l258c16/array.e*/);
/*SFN*/(C->_storage/*1*/)=new33(_new_capacity);
(ds.p=0x02210320/*l259c16/array.e*/);
/*SFN*/(C->_capacity/*5*/)=_new_capacity;
}
else{
(ds.p=0x02210520/*l261c16/array.e*/);
_new_capacity=r2_ix_42(&ds,INT8_C(2),(/*RF2*/(C)->_capacity/*5*/));
(ds.p=0x02210620/*l262c16/array.e*/);
/*SFN*/(C->_storage/*1*/)=r33realloc(&ds,(/*RF2*/(C)->_storage/*1*/),(/*RF2*/(C)->_capacity/*5*/),_new_capacity);
(ds.p=0x02210720/*l263c16/array.e*/);
/*SFN*/(C->_capacity/*5*/)=_new_capacity;
}
/*FI]*/
}
/*FI]*/
(ds.p=0x02210A14/*l266c10/array.e*/);
/*SFN*/(C->_upper/*9*/)=r2_ix_43(&ds,(/*RF2*/(C)->_upper/*9*/),INT8_C(1));
(ds.p=0x02210B14/*l267c10/array.e*/);
r31put(&ds,C,a1,(/*RF2*/(C)->_upper/*9*/));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x0260B91E/*l185c15/collection.e*/);
ac_ens((r31last(&ds,C))==((void*)(a1)),NULL);
(ds.p=0x0260BA20/*l186c16/collection.e*/);
ac_ens((r31count(&ds,C))==(r2_ix_43(&ds,/*IC*/(T2)(INT8_C(1)),o19_186_26)),NULL);
(ds.p=0x0260BB20/*l187c16/collection.e*/);
ac_ens(((/*RF2*/(C)->_lower/*13*/))==(o19_187_22),NULL);
(ds.p=0x0260BC20/*l188c16/collection.e*/);
ac_ens(((/*RF2*/(C)->_upper/*9*/))==(r2_ix_43(&ds,/*IC*/(T2)(INT8_C(1)),o19_188_26)),NULL);
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i31(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}

/*ARRAY[RULE]*/
T6 r31all_default(se_dump_stack*caller,T31* C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"all_default ARRAY",1,1,"%R31%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x02212208/*l290c4/array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x02212414/*l292c10/array.e*/);
R=((T6)(r33all_default(&ds,(/*RF2*/(C)->_storage/*1*/),r2_ix_45(&ds,(/*RF2*/(C)->_upper/*9*/),(/*RF2*/(C)->_lower/*13*/)))));
if(se_rci(caller,C))se_i31(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}
se_frame_descriptor se_ifd31={"invariant ARRAY[RULE]",1,0,"%R31%",1};

T31*se_i31(se_dump_stack*caller,T31*C){
se_dump_stack ds;
ds.fd=&se_ifd31;
ds.current=((void**)&C);
ds.p=0x0220130E/*l19c7/array.e*/;
ds.caller=caller;
ds.exception_origin=NULL;
ds.locals=NULL;
se_dst=&ds;/*link*/
if(ds.fd->assertion_flag){
ds.fd->assertion_flag=0;
(ds.p=0x02624C30/*l588c24/collection.e*/);
ac_inv((int32_t)(((/*RF2*/(C)->_lower/*13*/))<=(r2_ix_43(&ds,(/*RF2*/(C)->_upper/*9*/),/*IC*/(T2)(INT8_C(1))))),"valid_bounds");
(ds.p=0x0240751A/*l117c13/arrayed_collection.e*/);
ac_inv((int32_t)(((/*RF2*/(C)->_capacity/*5*/))>=(r2_ix_43(&ds,r2_ix_45(&ds,(/*RF2*/(C)->_upper/*9*/),(/*RF2*/(C)->_lower/*13*/)),/*IC*/(T2)(INT8_C(1))))),NULL);
(ds.p=0x02407722/*l119c17/arrayed_collection.e*/);
ac_inv((T6)((!((int32_t)(((/*RF2*/(C)->_capacity/*5*/))>(/*IC*/(T2)(INT8_C(0))))))||((T6)(r33is_not_null(&ds,(/*RF2*/(C)->_storage/*1*/))))),NULL);
ds.fd->assertion_flag=1;
}
se_dst=caller;/*unlink*/
return C;
}

/*FIXED_ARRAY[STRING]*/
T2 r42count(se_dump_stack*caller,T42* C){
T2 R=0;
void**locals[1];
static se_frame_descriptor fd={"count FIXED_ARRAY",1,1,"%R42%Result%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x0520A308/*l163c4/fixed_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x0520A514/*l165c10/fixed_array.e*/);
R=r2_ix_43(&ds,(/*RF2*/(C)->_upper/*9*/),INT8_C(1));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02603D22/*l61c17/collection.e*/);
ac_ens((R)==(r2_ix_43(&ds,r2_ix_45(&ds,(/*RF2*/(C)->_upper/*9*/),INT8_C(0)),/*IC*/(T2)(INT8_C(1)))),NULL);
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i42(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*FIXED_ARRAY[STRING]*/
void r42put(se_dump_stack*caller,T42* C,T0* a1,T2 a2){
T2 o19_107_22=0;
void**locals[3];
static se_frame_descriptor fd={"put FIXED_ARRAY",1,3,"%R42%element%R7%i%E2%old value%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x05207F08/*l127c4/fixed_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&o19_107_22;
set_dump_stack_top(&ds);/*link*/
o19_107_22=r42count(&ds,C);
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02606714/*l103c10/collection.e*/);
ac_req(r42valid_index(&ds,C,a2),NULL);
fd.assertion_flag=1;
}
(ds.p=0x05208124/*l129c18/fixed_array.e*/);
((/*RF2*/(C)->_storage/*1*/))[a2]=(a1);
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02606A24/*l106c18/collection.e*/);
ac_ens((r42item(&ds,C,a2))==((void*)(a1)),NULL);
(ds.p=0x02606B20/*l107c16/collection.e*/);
ac_ens((r42count(&ds,C))==(o19_107_22),NULL);
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i42(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}

/*FIXED_ARRAY[STRING]*/
T0* r42item(se_dump_stack*caller,T42* C,T2 a1){
T0* R=NULL;
void**locals[2];
static se_frame_descriptor fd={"item FIXED_ARRAY",1,2,"%R42%i%E2%Result%R7%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x05207A08/*l122c4/fixed_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02604C14/*l76c10/collection.e*/);
ac_req(r42valid_index(&ds,C,a1),NULL);
fd.assertion_flag=1;
}
(ds.p=0x05207C14/*l124c10/fixed_array.e*/);
R=((/*RF2*/(C)->_storage/*1*/))[a1];
if(se_rci(caller,C))se_i42(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*FIXED_ARRAY[STRING]*/
T6 r42valid_index(se_dump_stack*caller,T42* C,T2 a1){
T6 R=0;
void**locals[2];
static se_frame_descriptor fd={"valid_index COLLECTION",1,2,"%R42%index%E2%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x02602E16/*l46c11/collection.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x02603214/*l50c10/collection.e*/);
R=((T6)((T6)(((int32_t)((INT8_C(0))<=(a1)))&&((T6)((int32_t)((a1)<=((/*RF2*/(C)->_upper/*9*/))))))));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02603422/*l52c17/collection.e*/);
ac_ens((R)==((T6)(((int32_t)((INT8_C(0))<=(a1)))&&((T6)((int32_t)((a1)<=((/*RF2*/(C)->_upper/*9*/))))))),NULL);
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i42(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*FIXED_ARRAY[STRING]*/
void r42make(se_dump_stack*caller,T42* C,T2 a1){
T2 o41_59_26=0;
void**locals[2];
static se_frame_descriptor fd={"make FIXED_ARRAY",1,2,"%R42%new_count%E2%old value%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x05202708/*l39c4/fixed_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&o41_59_26;
set_dump_stack_top(&ds);/*link*/
o41_59_26=(/*RF2*/(C)->_capacity/*5*/);
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x05202B28/*l43c20/fixed_array.e*/);
ac_req((int32_t)((a1)>=(/*IC*/(T2)(INT8_C(0)))),NULL);
fd.assertion_flag=1;
}
/*[IF*/
if(((ds.p=0x05202D20/*l45c16/fixed_array.e*/),(int32_t)((a1)>((/*RF2*/(C)->_capacity/*5*/))))){
(ds.p=0x05202F1A/*l47c13/fixed_array.e*/);
/*SFN*/(C->_storage/*1*/)=new29(a1);
(ds.p=0x0520301A/*l48c13/fixed_array.e*/);
/*SFN*/(C->_capacity/*5*/)=a1;
}
 else if(((ds.p=0x05203126/*l49c19/fixed_array.e*/),(int32_t)(((/*RF2*/(C)->_capacity/*5*/))>(INT8_C(0))))){
(ds.p=0x0520330C/*l51c6/fixed_array.e*/);
/*SFN*/(C->_upper/*9*/)=r2max(&ds,(/*RF2*/(C)->_upper/*9*/),r2_ix_45(&ds,a1,INT8_C(1)));
/*[IF*/
if(((ds.p=0x0520341E/*l52c15/fixed_array.e*/),(int32_t)(((/*RF2*/(C)->_upper/*9*/))>=(INT8_C(0))))){
(ds.p=0x05203522/*l53c17/fixed_array.e*/);
r29clear_all(&ds,(/*RF2*/(C)->_storage/*1*/),(/*RF2*/(C)->_upper/*9*/));
}
/*FI]*/
}
/*FI]*/
(ds.p=0x05203806/*l56c3/fixed_array.e*/);
/*SFN*/(C->_upper/*9*/)=r2_ix_45(&ds,a1,INT8_C(1));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x05203A20/*l58c16/fixed_array.e*/);
ac_ens((r42count(&ds,C))==(a1),NULL);
(ds.p=0x05203B26/*l59c19/fixed_array.e*/);
ac_ens((int32_t)(((/*RF2*/(C)->_capacity/*5*/))>=(o41_59_26)),NULL);
(ds.p=0x05203C14/*l60c10/fixed_array.e*/);
ac_ens(r42all_default(&ds,C),NULL);
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i42(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}

/*FIXED_ARRAY[STRING]*/
T6 r42is_empty(se_dump_stack*caller,T42* C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"is_empty FIXED_ARRAY",1,1,"%R42%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x05207508/*l117c4/fixed_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x05207714/*l119c10/fixed_array.e*/);
R=((T6)((int32_t)(((/*RF2*/(C)->_upper/*9*/))<(INT8_C(0)))));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02604414/*l68c10/collection.e*/);
ac_ens((R)==((r42count(&ds,C))==(INT8_C(0))),NULL);
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i42(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*FIXED_ARRAY[STRING]*/
T6 r42all_default(se_dump_stack*caller,T42* C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"all_default FIXED_ARRAY",1,1,"%R42%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x0520EE08/*l238c4/fixed_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x0520F014/*l240c10/fixed_array.e*/);
R=((T6)(r29all_default(&ds,(/*RF2*/(C)->_storage/*1*/),(/*RF2*/(C)->_upper/*9*/))));
if(se_rci(caller,C))se_i42(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}
se_frame_descriptor se_ifd42={"invariant FIXED_ARRAY[STRING]",1,0,"%R42%",1};

T42*se_i42(se_dump_stack*caller,T42*C){
se_dump_stack ds;
ds.fd=&se_ifd42;
ds.current=((void**)&C);
ds.p=0x0520130E/*l19c7/fixed_array.e*/;
ds.caller=caller;
ds.exception_origin=NULL;
ds.locals=NULL;
se_dst=&ds;/*link*/
if(ds.fd->assertion_flag){
ds.fd->assertion_flag=0;
(ds.p=0x02624C30/*l588c24/collection.e*/);
ac_inv((int32_t)((INT8_C(0))<=(r2_ix_43(&ds,(/*RF2*/(C)->_upper/*9*/),/*IC*/(T2)(INT8_C(1))))),"valid_bounds");
(ds.p=0x0240751A/*l117c13/arrayed_collection.e*/);
ac_inv((int32_t)(((/*RF2*/(C)->_capacity/*5*/))>=(r2_ix_43(&ds,r2_ix_45(&ds,(/*RF2*/(C)->_upper/*9*/),INT8_C(0)),/*IC*/(T2)(INT8_C(1))))),NULL);
(ds.p=0x02407722/*l119c17/arrayed_collection.e*/);
ac_inv((T6)((!((int32_t)(((/*RF2*/(C)->_capacity/*5*/))>(/*IC*/(T2)(INT8_C(0))))))||((T6)(r29is_not_null(&ds,(/*RF2*/(C)->_storage/*1*/))))),NULL);
ds.fd->assertion_flag=1;
}
se_dst=caller;/*unlink*/
return C;
}

/*ARRAY[STRING]*/
void r22copy(se_dump_stack*caller,T22* C,T0* a1){
T2 _needed_capacity=0;
void**locals[2];
static se_frame_descriptor fd={"copy ARRAY",1,2,"%R22%other%R22%needed_capacity%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x0220C608/*l198c4/array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&_needed_capacity;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x01E0CF06/*l207c3/general.e*/);
ac_req(/*same_dynamic_type*/(((vc(((T0*)(C)),0))->id)==((vc(((T0*)(a1)),0))->id)),NULL);
fd.assertion_flag=1;
}
(ds.p=0x0220CA14/*l202c10/array.e*/);
/*SFN*/(C->_lower/*13*/)=(/*RF2*/(se_i22(&ds,((T22*)ci(22,a1,0x0220CA26/*l202c19/array.e*/))))->_lower/*13*/);
(ds.p=0x0220CB14/*l203c10/array.e*/);
/*SFN*/(C->_upper/*9*/)=(/*RF2*/(se_i22(&ds,((T22*)ci(22,a1,0x0220CB26/*l203c19/array.e*/))))->_upper/*9*/);
(ds.p=0x0220CC14/*l204c10/array.e*/);
_needed_capacity=r2_ix_43(&ds,r2_ix_45(&ds,(/*RF2*/(C)->_upper/*9*/),(/*RF2*/(C)->_lower/*13*/)),INT8_C(1));
/*[IF*/
if(((ds.p=0x0220CD2C/*l205c22/array.e*/),(int32_t)(((/*RF2*/(C)->_capacity/*5*/))<(_needed_capacity)))){
(ds.p=0x0220CE1A/*l206c13/array.e*/);
/*SFN*/(C->_storage/*1*/)=new29(_needed_capacity);
(ds.p=0x0220CF1A/*l207c13/array.e*/);
/*SFN*/(C->_capacity/*5*/)=_needed_capacity;
}
/*FI]*/
/*[IF*/
if(((ds.p=0x0220D13A/*l209c29/array.e*/),(int32_t)((_needed_capacity)>(INT8_C(0))))){
(ds.p=0x0220D22A/*l210c21/array.e*/);
r29copy_from(&ds,(/*RF2*/(C)->_storage/*1*/),(/*RF2*/(se_i22(&ds,((T22*)ci(22,a1,0x0220D23E/*l210c31/array.e*/))))->_storage/*1*/),r2_ix_45(&ds,_needed_capacity,/*IC*/(T2)(INT8_C(1))));
}
/*FI]*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x01E0D214/*l210c10/general.e*/);
ac_ens(r22is_equal(&ds,C,a1),NULL);
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i22(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}

/*ARRAY[STRING]*/
void r22clear_all(se_dump_stack*caller,T22* C){
T0* _value=NULL;
T2 o19_163_29=0;
T2 o19_164_29=0;
void**locals[3];
static se_frame_descriptor fd={"clear_all COLLECTION",1,3,"%R22%value%R7%old value%E2%old value%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x02609B08/*l155c4/collection.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&_value;
locals[1]=(void**)&o19_163_29;
locals[2]=(void**)&o19_164_29;
set_dump_stack_top(&ds);/*link*/
o19_163_29=(/*RF2*/(C)->_upper/*9*/);
o19_164_29=(/*RF2*/(C)->_lower/*13*/);
(ds.p=0x0260A114/*l161c10/collection.e*/);
r22set_all_with(&ds,C,_value);
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x0260A32E/*l163c23/collection.e*/);
ac_ens(((/*RF2*/(C)->_upper/*9*/))==(o19_163_29),"stable_upper");
(ds.p=0x0260A42E/*l164c23/collection.e*/);
ac_ens(((/*RF2*/(C)->_lower/*13*/))==(o19_164_29),"stable_lower");
(ds.p=0x0260A514/*l165c10/collection.e*/);
ac_ens(r22all_default(&ds,C),NULL);
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i22(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}

/*ARRAY[STRING]*/
void r22remove_first(se_dump_stack*caller,T22* C){
T2 o17_224_22=0;
T2 o19_259_23=0;
T2 o19_260_54=0;
T2 o19_260_24=0;
void**locals[4];
static se_frame_descriptor fd={"remove_first ARRAY",1,4,"%R22%old value%E2%old value%E2%old value%E2%old value%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x0220DB08/*l219c4/array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&o17_224_22;
locals[1]=(void**)&o19_259_23;
locals[2]=(void**)&o19_260_24;
locals[3]=(void**)&o19_260_54;
set_dump_stack_top(&ds);/*link*/
o17_224_22=(/*RF2*/(C)->_upper/*9*/);
o19_259_23=r22count(&ds,C);
o19_260_54=(/*RF2*/(C)->_upper/*9*/);
o19_260_24=(/*RF2*/(C)->_lower/*13*/);
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02610014/*l256c10/collection.e*/);
ac_req(r6_px_not(&ds,(T6)(r22is_empty(&ds,C))),NULL);
fd.assertion_flag=1;
}
(ds.p=0x0220DD24/*l221c18/array.e*/);
r29remove_first(&ds,(/*RF2*/(C)->_storage/*1*/),r2_ix_45(&ds,(/*RF2*/(C)->_upper/*9*/),(/*RF2*/(C)->_lower/*13*/)));
(ds.p=0x0220DE14/*l222c10/array.e*/);
/*SFN*/(C->_lower/*13*/)=r2_ix_43(&ds,(/*RF2*/(C)->_lower/*13*/),INT8_C(1));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x0220E020/*l224c16/array.e*/);
ac_ens(((/*RF2*/(C)->_upper/*9*/))==(o17_224_22),NULL);
(ds.p=0x02610320/*l259c16/collection.e*/);
ac_ens((r22count(&ds,C))==(r2_ix_45(&ds,o19_259_23,/*IC*/(T2)(INT8_C(1)))),NULL);
(ds.p=0x02610448/*l260c36/collection.e*/);
ac_ens(r6_ix_xor(&ds,(T6)(((/*RF2*/(C)->_lower/*13*/))==(r2_ix_43(&ds,o19_260_24,/*IC*/(T2)(INT8_C(1))))),(T6)(((/*RF2*/(C)->_upper/*9*/))==(r2_ix_45(&ds,o19_260_54,/*IC*/(T2)(INT8_C(1)))))),NULL);
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i22(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}

/*ARRAY[STRING]*/
T0* r22last(se_dump_stack*caller,T22* C){
T0* R=NULL;
void**locals[1];
static se_frame_descriptor fd={"last ARRAYED_COLLECTION",1,1,"%R22%Result%R7%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x02403D08/*l61c4/arrayed_collection.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02605C14/*l92c10/collection.e*/);
ac_req(r6_px_not(&ds,(T6)(r22is_empty(&ds,C))),NULL);
fd.assertion_flag=1;
}
(ds.p=0x02403F14/*l63c10/arrayed_collection.e*/);
R=r22item(&ds,C,(/*RF2*/(C)->_upper/*9*/));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02605F22/*l95c17/collection.e*/);
ac_ens((R)==((void*)(r22item(&ds,C,(/*RF2*/(C)->_upper/*9*/)))),NULL);
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i22(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*ARRAY[STRING]*/
T2 r22count(se_dump_stack*caller,T22* C){
T2 R=0;
void**locals[1];
static se_frame_descriptor fd={"count ARRAY",1,1,"%R22%Result%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x0220A208/*l162c4/array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x0220A414/*l164c10/array.e*/);
R=r2_ix_43(&ds,r2_ix_45(&ds,(/*RF2*/(C)->_upper/*9*/),(/*RF2*/(C)->_lower/*13*/)),INT8_C(1));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02603D22/*l61c17/collection.e*/);
ac_ens((R)==(r2_ix_43(&ds,r2_ix_45(&ds,(/*RF2*/(C)->_upper/*9*/),(/*RF2*/(C)->_lower/*13*/)),/*IC*/(T2)(INT8_C(1)))),NULL);
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i22(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*ARRAY[STRING]*/
void r22put(se_dump_stack*caller,T22* C,T0* a1,T2 a2){
T2 o19_107_22=0;
void**locals[3];
static se_frame_descriptor fd={"put ARRAY",1,3,"%R22%element%R7%i%E2%old value%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x0220AC08/*l172c4/array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&o19_107_22;
set_dump_stack_top(&ds);/*link*/
o19_107_22=r22count(&ds,C);
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02606714/*l103c10/collection.e*/);
ac_req(r22valid_index(&ds,C,a2),NULL);
fd.assertion_flag=1;
}
(ds.p=0x0220AE24/*l174c18/array.e*/);
((/*RF2*/(C)->_storage/*1*/))[r2_ix_45(&ds,a2,(/*RF2*/(C)->_lower/*13*/))]=(a1);
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02606A24/*l106c18/collection.e*/);
ac_ens((r22item(&ds,C,a2))==((void*)(a1)),NULL);
(ds.p=0x02606B20/*l107c16/collection.e*/);
ac_ens((r22count(&ds,C))==(o19_107_22),NULL);
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i22(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}

/*ARRAY[STRING]*/
T6 r22is_equal(se_dump_stack*caller,T22* C,T0* a1){
T6 R=0;
void**locals[2];
static se_frame_descriptor fd={"is_equal ARRAY",1,2,"%R22%other%R22%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x02213B08/*l315c4/array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x01E07720/*l119c16/general.e*/);
ac_req((a1)!=((void*)(NULL)),NULL);
fd.assertion_flag=1;
}
/*[IF*/
if((C)==((void*)(a1))){
(ds.p=0x02213E1A/*l318c13/array.e*/);
R=((T6)(1));
}
 else if(((ds.p=0x02213F4A/*l319c37/array.e*/),(T6)((((/*RF2*/(C)->_lower/*13*/))==((/*RF2*/(se_i22(&ds,((T22*)ci(22,a1,0x02213F32/*l319c25/array.e*/))))->_lower/*13*/)))&&((T6)(((/*RF2*/(C)->_upper/*9*/))==((/*RF2*/(se_i22(&ds,((T22*)ci(22,a1,0x02213F6C/*l319c54/array.e*/))))->_upper/*9*/))))))){
(ds.p=0x0221401A/*l320c13/array.e*/);
R=((T6)(r29fast_memcmp(&ds,(/*RF2*/(C)->_storage/*1*/),(/*RF2*/(se_i22(&ds,((T22*)ci(22,a1,0x02214056/*l320c43/array.e*/))))->_storage/*1*/),r22count(&ds,C))));
}
/*FI]*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02615914/*l345c10/collection.e*/);
ac_ens((T6)((!(R))||((T6)(r6_ix_and(&ds,(T6)(((/*RF2*/(C)->_lower/*13*/))==((/*RF2*/(se_i22(&ds,((T22*)ci(22,a1,0x02615936/*l345c27/collection.e*/))))->_lower/*13*/))),(T6)(((/*RF2*/(C)->_upper/*9*/))==((/*RF2*/(se_i22(&ds,((T22*)ci(22,a1,0x02615966/*l345c51/collection.e*/))))->_upper/*9*/))))))),NULL);
(ds.p=0x01E07A64/*l122c50/general.e*/);
ac_ens((T6)((!(((T0*)(t[(C)->id]))==((void*)((T0*)(t[((T22*)a1)->id])))))||((T6)((R)==(r22is_equal(&ds,se_i22(&ds,((T22*)ci(22,a1,0x01E07B20/*l123c16/general.e*/))),(T0*)C))))),NULL);
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i22(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*ARRAY[STRING]*/
T0* r22item(se_dump_stack*caller,T22* C,T2 a1){
T0* R=NULL;
void**locals[2];
static se_frame_descriptor fd={"item ARRAY",1,2,"%R22%i%E2%Result%R7%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x0220A708/*l167c4/array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02604C14/*l76c10/collection.e*/);
ac_req(r22valid_index(&ds,C,a1),NULL);
fd.assertion_flag=1;
}
(ds.p=0x0220A914/*l169c10/array.e*/);
R=((/*RF2*/(C)->_storage/*1*/))[r2_ix_45(&ds,a1,(/*RF2*/(C)->_lower/*13*/))];
if(se_rci(caller,C))se_i22(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*ARRAY[STRING]*/
T6 r22valid_index(se_dump_stack*caller,T22* C,T2 a1){
T6 R=0;
void**locals[2];
static se_frame_descriptor fd={"valid_index COLLECTION",1,2,"%R22%index%E2%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x02602E16/*l46c11/collection.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x02603214/*l50c10/collection.e*/);
R=((T6)((T6)(((int32_t)(((/*RF2*/(C)->_lower/*13*/))<=(a1)))&&((T6)((int32_t)((a1)<=((/*RF2*/(C)->_upper/*9*/))))))));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02603422/*l52c17/collection.e*/);
ac_ens((R)==((T6)(((int32_t)(((/*RF2*/(C)->_lower/*13*/))<=(a1)))&&((T6)((int32_t)((a1)<=((/*RF2*/(C)->_upper/*9*/))))))),NULL);
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i22(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*ARRAY[STRING]*/
void r22make(se_dump_stack*caller,T22* C,T2 a1,T2 a2){
T2 _needed=0;
void**locals[3];
static se_frame_descriptor fd={"make ARRAY",1,3,"%R22%min_index%E2%max_index%E2%needed%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x02202308/*l35c4/array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&_needed;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02202844/*l40c34/array.e*/);
ac_req((int32_t)((a1)<=(r2_ix_43(&ds,a2,/*IC*/(T2)(INT8_C(1))))),"valid_bounds");
fd.assertion_flag=1;
}
(ds.p=0x02202C14/*l44c10/array.e*/);
/*SFN*/(C->_lower/*13*/)=a1;
(ds.p=0x02202D14/*l45c10/array.e*/);
/*SFN*/(C->_upper/*9*/)=a2;
(ds.p=0x02202E14/*l46c10/array.e*/);
_needed=r2_ix_43(&ds,r2_ix_45(&ds,a2,a1),INT8_C(1));
/*[IF*/
if(((ds.p=0x02202F28/*l47c20/array.e*/),(int32_t)((_needed)>(INT8_C(0))))){
/*[IF*/
if(((ds.p=0x02203032/*l48c25/array.e*/),(int32_t)(((/*RF2*/(C)->_capacity/*5*/))<(_needed)))){
(ds.p=0x02203120/*l49c16/array.e*/);
/*SFN*/(C->_storage/*1*/)=new29(_needed);
(ds.p=0x02203220/*l50c16/array.e*/);
/*SFN*/(C->_capacity/*5*/)=_needed;
}
else{
(ds.p=0x02203420/*l52c16/array.e*/);
r22clear_all(&ds,C);
}
/*FI]*/
}
/*FI]*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02203836/*l56c27/array.e*/);
ac_ens(((/*RF2*/(C)->_lower/*13*/))==(a1),"lower_set");
(ds.p=0x02203936/*l57c27/array.e*/);
ac_ens(((/*RF2*/(C)->_upper/*9*/))==(a2),"upper_set");
(ds.p=0x02203A2A/*l58c21/array.e*/);
ac_ens(r22all_default(&ds,C),"items_set");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i22(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}

/*ARRAY[STRING]*/
void r22add_first(se_dump_stack*caller,T22* C,T0* a1){
T2 o19_176_26=0;
T2 o19_177_22=0;
T2 o19_178_26=0;
void**locals[4];
static se_frame_descriptor fd={"add_first ARRAY",1,4,"%R22%element%R7%old value%E2%old value%E2%old value%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x0220F008/*l240c4/array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&o19_176_26;
locals[2]=(void**)&o19_177_22;
locals[3]=(void**)&o19_178_26;
set_dump_stack_top(&ds);/*link*/
o19_176_26=r22count(&ds,C);
o19_177_22=(/*RF2*/(C)->_lower/*13*/);
o19_178_26=(/*RF2*/(C)->_upper/*9*/);
/*[IF*/
if(((ds.p=0x0220F226/*l242c19/array.e*/),(int32_t)(((/*RF2*/(C)->_upper/*9*/))<((/*RF2*/(C)->_lower/*13*/))))){
(ds.p=0x0220F31A/*l243c13/array.e*/);
r22add_last(&ds,C,a1);
}
else{
(ds.p=0x0220F51A/*l245c13/array.e*/);
r22add_last(&ds,C,a1);
(ds.p=0x0220F61A/*l246c13/array.e*/);
r22move(&ds,C,(/*RF2*/(C)->_lower/*13*/),r2_ix_45(&ds,(/*RF2*/(C)->_upper/*9*/),/*IC*/(T2)(INT8_C(1))),/*IC*/(T2)(INT8_C(1)));
(ds.p=0x0220F71A/*l247c13/array.e*/);
r22put(&ds,C,a1,(/*RF2*/(C)->_lower/*13*/));
}
/*FI]*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x0260AF20/*l175c16/collection.e*/);
ac_ens((r22first(&ds,C))==((void*)(a1)),NULL);
(ds.p=0x0260B020/*l176c16/collection.e*/);
ac_ens((r22count(&ds,C))==(r2_ix_43(&ds,/*IC*/(T2)(INT8_C(1)),o19_176_26)),NULL);
(ds.p=0x0260B120/*l177c16/collection.e*/);
ac_ens(((/*RF2*/(C)->_lower/*13*/))==(o19_177_22),NULL);
(ds.p=0x0260B220/*l178c16/collection.e*/);
ac_ens(((/*RF2*/(C)->_upper/*9*/))==(r2_ix_43(&ds,/*IC*/(T2)(INT8_C(1)),o19_178_26)),NULL);
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i22(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}

/*ARRAY[STRING]*/
T6 r22is_empty(se_dump_stack*caller,T22* C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"is_empty ARRAY",1,1,"%R22%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x02209D08/*l157c4/array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x02209F14/*l159c10/array.e*/);
R=((T6)((int32_t)(((/*RF2*/(C)->_upper/*9*/))<((/*RF2*/(C)->_lower/*13*/)))));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02604414/*l68c10/collection.e*/);
ac_ens((R)==((r22count(&ds,C))==(INT8_C(0))),NULL);
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i22(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*ARRAY[STRING]*/
void r22move(se_dump_stack*caller,T22* C,T2 a1,T2 a2,T2 a3){
T0* _default_value=NULL;
T2 _i=0;
T2 o19_549_22=0;
void**locals[6];
static se_frame_descriptor fd={"move COLLECTION",1,6,"%R22%lower_index%E2%upper_index%E2%distance%E2%default_value%R7%i%E2%old value%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x02620008/*l512c4/collection.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&a3;
locals[3]=(void**)&_default_value;
locals[4]=(void**)&_i;
locals[5]=(void**)&o19_549_22;
set_dump_stack_top(&ds);/*link*/
o19_549_22=r22count(&ds,C);
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x0262052C/*l517c22/collection.e*/);
ac_req((int32_t)((a1)<=(a2)),NULL);
(ds.p=0x02620614/*l518c10/collection.e*/);
ac_req(r22valid_index(&ds,C,a1),NULL);
(ds.p=0x02620714/*l519c10/collection.e*/);
ac_req(r22valid_index(&ds,C,r2_ix_43(&ds,a1,a3)),NULL);
(ds.p=0x02620814/*l520c10/collection.e*/);
ac_req(r22valid_index(&ds,C,a2),NULL);
(ds.p=0x02620914/*l521c10/collection.e*/);
ac_req(r22valid_index(&ds,C,r2_ix_43(&ds,a2,a3)),NULL);
fd.assertion_flag=1;
}
/*[IF*/
if((a3)==(INT8_C(0))){
}
 else if(((ds.p=0x02620F34/*l527c26/collection.e*/),(int32_t)((a3)<(INT8_C(0))))){
(ds.p=0x02621120/*l529c16/collection.e*/);
_i=a1;
while (!(((ds.p=0x02621324/*l531c18/collection.e*/),(int32_t)((_i)>(a2)))))
{
(ds.p=0x02621520/*l533c16/collection.e*/);
r22put(&ds,C,r22item(&ds,C,_i),r2_ix_43(&ds,_i,a3));
(ds.p=0x02621620/*l534c16/collection.e*/);
r22put(&ds,C,_default_value,_i);
(ds.p=0x02621720/*l535c16/collection.e*/);
_i=r2_ix_43(&ds,_i,INT8_C(1));
}
}
else{
(ds.p=0x02621B20/*l539c16/collection.e*/);
_i=a2;
while (!(((ds.p=0x02621D24/*l541c18/collection.e*/),(int32_t)((_i)<(a1)))))
{
(ds.p=0x02621F20/*l543c16/collection.e*/);
r22put(&ds,C,r22item(&ds,C,_i),r2_ix_43(&ds,_i,a3));
(ds.p=0x02622020/*l544c16/collection.e*/);
r22put(&ds,C,_default_value,_i);
(ds.p=0x02622120/*l545c16/collection.e*/);
_i=r2_ix_45(&ds,_i,INT8_C(1));
}
}
/*FI]*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02622520/*l549c16/collection.e*/);
ac_ens((r22count(&ds,C))==(o19_549_22),NULL);
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i22(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}

/*ARRAY[STRING]*/
void r22set_all_with(se_dump_stack*caller,T22* C,T0* a1){
T2 o19_131_22=0;
void**locals[2];
static se_frame_descriptor fd={"set_all_with ARRAY",1,2,"%R22%v%R7%old value%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x0220D608/*l214c4/array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&o19_131_22;
set_dump_stack_top(&ds);/*link*/
o19_131_22=r22count(&ds,C);
(ds.p=0x0220D824/*l216c18/array.e*/);
r29set_all_with(&ds,(/*RF2*/(C)->_storage/*1*/),a1,r2_ix_45(&ds,(/*RF2*/(C)->_upper/*9*/),(/*RF2*/(C)->_lower/*13*/)));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02608320/*l131c16/collection.e*/);
ac_ens((r22count(&ds,C))==(o19_131_22),NULL);
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i22(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}

/*ARRAY[STRING]*/
void r22add_last(se_dump_stack*caller,T22* C,T0* a1){
T2 _new_capacity=0;
T2 o19_186_26=0;
T2 o19_187_22=0;
T2 o19_188_26=0;
void**locals[5];
static se_frame_descriptor fd={"add_last ARRAY",1,5,"%R22%element%R7%new_capacity%E2%old value%E2%old value%E2%old value%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x0220FB08/*l251c4/array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&_new_capacity;
locals[2]=(void**)&o19_186_26;
locals[3]=(void**)&o19_187_22;
locals[4]=(void**)&o19_188_26;
set_dump_stack_top(&ds);/*link*/
o19_186_26=r22count(&ds,C);
o19_187_22=(/*RF2*/(C)->_lower/*13*/);
o19_188_26=(/*RF2*/(C)->_upper/*9*/);
/*[IF*/
if(((ds.p=0x0220FF2C/*l255c22/array.e*/),(int32_t)(((/*RF2*/(C)->_capacity/*5*/))<(r2_ix_43(&ds,r22count(&ds,C),INT8_C(1)))))){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*5*/))==(INT8_C(0))){
(ds.p=0x02210120/*l257c16/array.e*/);
_new_capacity=INT8_C(16);
(ds.p=0x02210220/*l258c16/array.e*/);
/*SFN*/(C->_storage/*1*/)=new29(_new_capacity);
(ds.p=0x02210320/*l259c16/array.e*/);
/*SFN*/(C->_capacity/*5*/)=_new_capacity;
}
else{
(ds.p=0x02210520/*l261c16/array.e*/);
_new_capacity=r2_ix_42(&ds,INT8_C(2),(/*RF2*/(C)->_capacity/*5*/));
(ds.p=0x02210620/*l262c16/array.e*/);
/*SFN*/(C->_storage/*1*/)=r29realloc(&ds,(/*RF2*/(C)->_storage/*1*/),(/*RF2*/(C)->_capacity/*5*/),_new_capacity);
(ds.p=0x02210720/*l263c16/array.e*/);
/*SFN*/(C->_capacity/*5*/)=_new_capacity;
}
/*FI]*/
}
/*FI]*/
(ds.p=0x02210A14/*l266c10/array.e*/);
/*SFN*/(C->_upper/*9*/)=r2_ix_43(&ds,(/*RF2*/(C)->_upper/*9*/),INT8_C(1));
(ds.p=0x02210B14/*l267c10/array.e*/);
r22put(&ds,C,a1,(/*RF2*/(C)->_upper/*9*/));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x0260B91E/*l185c15/collection.e*/);
ac_ens((r22last(&ds,C))==((void*)(a1)),NULL);
(ds.p=0x0260BA20/*l186c16/collection.e*/);
ac_ens((r22count(&ds,C))==(r2_ix_43(&ds,/*IC*/(T2)(INT8_C(1)),o19_186_26)),NULL);
(ds.p=0x0260BB20/*l187c16/collection.e*/);
ac_ens(((/*RF2*/(C)->_lower/*13*/))==(o19_187_22),NULL);
(ds.p=0x0260BC20/*l188c16/collection.e*/);
ac_ens(((/*RF2*/(C)->_upper/*9*/))==(r2_ix_43(&ds,/*IC*/(T2)(INT8_C(1)),o19_188_26)),NULL);
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i22(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}

/*ARRAY[STRING]*/
T0* r22first(se_dump_stack*caller,T22* C){
T0* R=NULL;
void**locals[1];
static se_frame_descriptor fd={"first ARRAYED_COLLECTION",1,1,"%R22%Result%R7%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x02403808/*l56c4/arrayed_collection.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02605320/*l83c16/collection.e*/);
ac_req((int32_t)((r22count(&ds,C))>=(/*IC*/(T2)(INT8_C(1)))),NULL);
fd.assertion_flag=1;
}
(ds.p=0x02403A14/*l58c10/arrayed_collection.e*/);
R=((/*RF2*/(C)->_storage/*1*/))[INT8_C(0)];
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02605622/*l86c17/collection.e*/);
ac_ens((R)==((void*)(r22item(&ds,C,(/*RF2*/(C)->_lower/*13*/)))),NULL);
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i22(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*ARRAY[STRING]*/
T6 r22all_default(se_dump_stack*caller,T22* C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"all_default ARRAY",1,1,"%R22%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x02212208/*l290c4/array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x02212414/*l292c10/array.e*/);
R=((T6)(r29all_default(&ds,(/*RF2*/(C)->_storage/*1*/),r2_ix_45(&ds,(/*RF2*/(C)->_upper/*9*/),(/*RF2*/(C)->_lower/*13*/)))));
if(se_rci(caller,C))se_i22(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*ARRAY[STRING]*/
T0* r22twin(se_dump_stack*caller,T22* C){
T0* R=NULL;
void**locals[1];
static se_frame_descriptor fd={"twin GENERAL",1,1,"%R22%Result%R22%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x01E0BF16/*l191c11/general.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
R=((void*)new22());
r22copy(&ds,((T22*)R),((T0*)C));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x01E0C730/*l199c24/general.e*/);
ac_ens(r22is_equal(&ds,se_i22(&ds,((T22*)ci(22,R,0x01E0C722/*l199c17/general.e*/))),(T0*)C),"equal");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i22(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}
se_frame_descriptor se_ifd22={"invariant ARRAY[STRING]",1,0,"%R22%",1};

T22*se_i22(se_dump_stack*caller,T22*C){
se_dump_stack ds;
ds.fd=&se_ifd22;
ds.current=((void**)&C);
ds.p=0x0220130E/*l19c7/array.e*/;
ds.caller=caller;
ds.exception_origin=NULL;
ds.locals=NULL;
se_dst=&ds;/*link*/
if(ds.fd->assertion_flag){
ds.fd->assertion_flag=0;
(ds.p=0x02624C30/*l588c24/collection.e*/);
ac_inv((int32_t)(((/*RF2*/(C)->_lower/*13*/))<=(r2_ix_43(&ds,(/*RF2*/(C)->_upper/*9*/),/*IC*/(T2)(INT8_C(1))))),"valid_bounds");
(ds.p=0x0240751A/*l117c13/arrayed_collection.e*/);
ac_inv((int32_t)(((/*RF2*/(C)->_capacity/*5*/))>=(r2_ix_43(&ds,r2_ix_45(&ds,(/*RF2*/(C)->_upper/*9*/),(/*RF2*/(C)->_lower/*13*/)),/*IC*/(T2)(INT8_C(1))))),NULL);
(ds.p=0x02407722/*l119c17/arrayed_collection.e*/);
ac_inv((T6)((!((int32_t)(((/*RF2*/(C)->_capacity/*5*/))>(/*IC*/(T2)(INT8_C(0))))))||((T6)(r29is_not_null(&ds,(/*RF2*/(C)->_storage/*1*/))))),NULL);
ds.fd->assertion_flag=1;
}
se_dst=caller;/*unlink*/
return C;
}

/*STD_INPUT_OUTPUT*/
void r34put_new_line(se_dump_stack*caller,T34* C){
static se_frame_descriptor fd={"put_new_line OUTPUT_STREAM",1,0,"%R34%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x0460AB08/*l171c4/output_stream.e*/;
ds.caller=caller;
ds.locals=NULL;
ds.exception_origin=NULL;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x0460AE14/*l174c10/output_stream.e*/);
ac_req(1,NULL);
fd.assertion_flag=1;
}
(ds.p=0x0460B014/*l176c10/output_stream.e*/);
r34put_character(&ds,C,((T3)'\n'));
set_dump_stack_top(caller);/*unlink*/
}
T0*oBC35tmp_string=NULL;

/*STD_INPUT_OUTPUT*/
void r34make(se_dump_stack*caller,T34* C){
static se_frame_descriptor fd={"make STD_INPUT_OUTPUT",1,0,"%R34%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x04402108/*l33c4/std_input_output.e*/;
ds.caller=caller;
ds.locals=NULL;
ds.exception_origin=NULL;
set_dump_stack_top(&ds);/*link*/
set_dump_stack_top(caller);/*unlink*/
}

/*STD_INPUT_OUTPUT*/
void r34put_integer(se_dump_stack*caller,T34* C,T11 a1){
void**locals[1];
static se_frame_descriptor fd={"put_integer OUTPUT_STREAM",1,1,"%R34%i%E11%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x04604816/*l72c11/output_stream.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x04604B14/*l75c10/output_stream.e*/);
ac_req(1,NULL);
fd.assertion_flag=1;
}
(ds.p=0x04604D2A/*l77c21/output_stream.e*/);
r7clear(&ds,se_i7(&ds,((T7*)ci(7,oBC35tmp_string,0x04604D14/*l77c10/output_stream.e*/))));
(ds.p=0x04604E18/*l78c12/output_stream.e*/);
r11append_in(&ds,a1,oBC35tmp_string);
(ds.p=0x04604F14/*l79c10/output_stream.e*/);
r34put_string(&ds,C,oBC35tmp_string);
set_dump_stack_top(caller);/*unlink*/
}
T0*oBC15std_output=NULL;

/*STD_INPUT_OUTPUT*/
void r34put_character(se_dump_stack*caller,T34* C,T3 a1){
void**locals[1];
static se_frame_descriptor fd={"put_character STD_INPUT_OUTPUT",1,1,"%R34%c%E3%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x04403908/*l57c4/std_input_output.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x04602314/*l35c10/output_stream.e*/);
ac_req(1,NULL);
fd.assertion_flag=1;
}
(ds.p=0x04403B1C/*l59c14/std_input_output.e*/);
r37put_character(&ds,((T37*)ci(37,oBC15std_output,0x04403B06/*l59c3/std_input_output.e*/)),a1);
set_dump_stack_top(caller);/*unlink*/
}

/*STD_INPUT_OUTPUT*/
void r34put_string(se_dump_stack*caller,T34* C,T0* a1){
T2 _i=0;
T2 _count=0;
void**locals[3];
static se_frame_descriptor fd={"put_string OUTPUT_STREAM",1,3,"%R34%s%R7%i%E2%count%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x04602908/*l41c4/output_stream.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&_i;
locals[2]=(void**)&_count;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x04602C14/*l44c10/output_stream.e*/);
ac_req(1,NULL);
(ds.p=0x04602D18/*l45c12/output_stream.e*/);
ac_req((a1)!=((void*)(NULL)),NULL);
fd.assertion_flag=1;
}
(ds.p=0x0460321A/*l50c13/output_stream.e*/);
_i=INT8_C(1);
(ds.p=0x0460330C/*l51c6/output_stream.e*/);
_count=(/*RF2*/(se_i7(&ds,((T7*)ci(7,a1,0x0460331E/*l51c15/output_stream.e*/))))->_count/*5*/);
while (!(((ds.p=0x0460351E/*l53c15/output_stream.e*/),(int32_t)((_i)>(_count)))))
{
(ds.p=0x0460371A/*l55c13/output_stream.e*/);
r34put_character(&ds,C,r7item(&ds,se_i7(&ds,((T7*)ci(7,a1,0x04603736/*l55c27/output_stream.e*/))),_i));
(ds.p=0x0460381A/*l56c13/output_stream.e*/);
_i=r2_ix_43(&ds,_i,INT8_C(1));
}
set_dump_stack_top(caller);/*unlink*/
}

/*TOKENIZER*/
void r38make(se_dump_stack*caller,T38* C,T0* a1){
void**locals[1];
static se_frame_descriptor fd={"make TOKENIZER",1,1,"%R38%nm%R7%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x04C0080A/*l8c5/tokenizer.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x04C00A12/*l10c9/tokenizer.e*/);
{T39*n=new39();
r39connect_to(&ds,n,a1);
/*SFN*/(C->_file/*1*/)=((T0*)n);
}
(ds.p=0x04C00B12/*l11c9/tokenizer.e*/);
/*SFN*/(C->_s/*5*/)=se_ms(0,s12_0);
set_dump_stack_top(caller);/*unlink*/
}

/*TOKENIZER*/
T0* r38next_token(se_dump_stack*caller,T38* C){
T0* R=NULL;
T3 _c=0;
T6 _done=0;
void**locals[3];
static se_frame_descriptor fd={"next_token TOKENIZER",1,3,"%R38%Result%R7%c%E3%done%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x04C00E0A/*l14c5/tokenizer.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
locals[1]=(void**)&_c;
locals[2]=(void**)&_done;
set_dump_stack_top(&ds);/*link*/
/*[IF*/
if(((ds.p=0x04C01318/*l19c12/tokenizer.e*/),r6_px_not(&ds,(T6)(r39is_connected(&ds,((T39*)ci(39,(/*RF2*/(C)->_file/*1*/),0x04C01320/*l19c16/tokenizer.e*/))))))){
(ds.p=0x04C01418/*l20c12/tokenizer.e*/);
R=se_ms(3,s12_2190);
}
 else if((/*RF2*/(((T39*)ci(39,(/*RF2*/(C)->_file/*1*/),0x04C01520/*l21c16/tokenizer.e*/)))->_end_of_input/*6*/)){
(ds.p=0x04C01618/*l22c12/tokenizer.e*/);
R=se_ms(3,s12_2190);
(ds.p=0x04C01722/*l23c17/tokenizer.e*/);
r39disconnect(&ds,((T39*)ci(39,(/*RF2*/(C)->_file/*1*/),0x04C01718/*l23c12/tokenizer.e*/)));
}
else{
(ds.p=0x04C01A1C/*l26c14/tokenizer.e*/);
_done=((T6)(0));
while (!(((ds.p=0x04C01C1C/*l28c14/tokenizer.e*/),_done)))
{
/*[IF*/
if(((ds.p=0x04C01E44/*l30c34/tokenizer.e*/),r6_ix_or(&ds,(T6)(r7is_equal(&ds,se_i7(&ds,((T7*)ci(7,(/*RF2*/(C)->_s/*5*/),0x04C01E22/*l30c17/tokenizer.e*/))),se_ms(2,s12_335))),(T6)(r7is_equal(&ds,se_i7(&ds,((T7*)ci(7,(/*RF2*/(C)->_s/*5*/),0x04C01E4A/*l30c37/tokenizer.e*/))),se_ms(1,s12_46)))))){
(ds.p=0x04C01F22/*l31c17/tokenizer.e*/);
R=(/*RF2*/(C)->_s/*5*/);
(ds.p=0x04C02022/*l32c17/tokenizer.e*/);
/*SFN*/(C->_s/*5*/)=se_ms(0,s12_0);
(ds.p=0x04C02122/*l33c17/tokenizer.e*/);
_done=((T6)(1));
}
else{
(ds.p=0x04C0232C/*l35c22/tokenizer.e*/);
r39read_character(&ds,((T39*)ci(39,(/*RF2*/(C)->_file/*1*/),0x04C02322/*l35c17/tokenizer.e*/)));
/*[IF*/
if((/*RF2*/(((T39*)ci(39,(/*RF2*/(C)->_file/*1*/),0x04C02428/*l36c20/tokenizer.e*/)))->_end_of_input/*6*/)){
(ds.p=0x04C02528/*l37c20/tokenizer.e*/);
R=se_ms(3,s12_2190);
(ds.p=0x04C02632/*l38c25/tokenizer.e*/);
r39disconnect(&ds,((T39*)ci(39,(/*RF2*/(C)->_file/*1*/),0x04C02628/*l38c20/tokenizer.e*/)));
(ds.p=0x04C02728/*l39c20/tokenizer.e*/);
_done=((T6)(1));
}
else{
(ds.p=0x04C02928/*l41c20/tokenizer.e*/);
_c=(/*RF2*/(((T39*)ci(39,(/*RF2*/(C)->_file/*1*/),0x04C02932/*l41c25/tokenizer.e*/)))->_last_character/*5*/);
/*[INSPECT*/
{int z1=((ds.p=0x04C02A38/*l42c28/tokenizer.e*/),_c);
switch(z1){
case 46:
/*[IF*/
if(((ds.p=0x04C02C36/*l44c27/tokenizer.e*/),r6_px_not(&ds,(T6)(r7is_equal(&ds,se_i7(&ds,((T7*)ci(7,(/*RF2*/(C)->_s/*5*/),0x04C02C3E/*l44c31/tokenizer.e*/))),se_ms(0,s12_0)))))){
(ds.p=0x04C02D34/*l45c26/tokenizer.e*/);
R=(/*RF2*/(C)->_s/*5*/);
(ds.p=0x04C02E34/*l46c26/tokenizer.e*/);
/*SFN*/(C->_s/*5*/)=se_ms(1,s12_46);
}
else{
(ds.p=0x04C03034/*l48c26/tokenizer.e*/);
R=se_ms(1,s12_46);
(ds.p=0x04C03134/*l49c26/tokenizer.e*/);
/*SFN*/(C->_s/*5*/)=se_ms(0,s12_0);
}
/*FI]*/
(ds.p=0x04C03330/*l51c24/tokenizer.e*/);
_done=((T6)(1));
break;
case 58:
/*[IF*/
if(((ds.p=0x04C03536/*l53c27/tokenizer.e*/),r6_px_not(&ds,(T6)(r7is_equal(&ds,se_i7(&ds,((T7*)ci(7,(/*RF2*/(C)->_s/*5*/),0x04C0353E/*l53c31/tokenizer.e*/))),se_ms(0,s12_0)))))){
(ds.p=0x04C03636/*l54c27/tokenizer.e*/);
R=(/*RF2*/(C)->_s/*5*/);
(ds.p=0x04C03740/*l55c32/tokenizer.e*/);
r39read_character(&ds,((T39*)ci(39,(/*RF2*/(C)->_file/*1*/),0x04C03736/*l55c27/tokenizer.e*/)));
(ds.p=0x04C03836/*l56c27/tokenizer.e*/);
/*SFN*/(C->_s/*5*/)=se_ms(2,s12_335);
(ds.p=0x04C03936/*l57c27/tokenizer.e*/);
_done=((T6)(1));
}
else{
(ds.p=0x04C03B40/*l59c32/tokenizer.e*/);
r39read_character(&ds,((T39*)ci(39,(/*RF2*/(C)->_file/*1*/),0x04C03B36/*l59c27/tokenizer.e*/)));
(ds.p=0x04C03C36/*l60c27/tokenizer.e*/);
R=se_ms(2,s12_335);
(ds.p=0x04C03D36/*l61c27/tokenizer.e*/);
/*SFN*/(C->_s/*5*/)=se_ms(0,s12_0);
(ds.p=0x04C03E36/*l62c27/tokenizer.e*/);
_done=((T6)(1));
}
/*FI]*/
break;
case 44:
/*[IF*/
if(((ds.p=0x04C04136/*l65c27/tokenizer.e*/),r6_px_not(&ds,(T6)(r7is_equal(&ds,se_i7(&ds,((T7*)ci(7,(/*RF2*/(C)->_s/*5*/),0x04C0413E/*l65c31/tokenizer.e*/))),se_ms(0,s12_0)))))){
(ds.p=0x04C04236/*l66c27/tokenizer.e*/);
R=(/*RF2*/(C)->_s/*5*/);
(ds.p=0x04C04336/*l67c27/tokenizer.e*/);
/*SFN*/(C->_s/*5*/)=se_ms(0,s12_0);
(ds.p=0x04C04436/*l68c27/tokenizer.e*/);
_done=((T6)(1));
}
/*FI]*/
break;
case 10:
case 32:
/*[IF*/
if(((ds.p=0x04C04736/*l71c27/tokenizer.e*/),r6_px_not(&ds,(T6)(r7is_equal(&ds,se_i7(&ds,((T7*)ci(7,(/*RF2*/(C)->_s/*5*/),0x04C0473E/*l71c31/tokenizer.e*/))),se_ms(0,s12_0)))))){
(ds.p=0x04C04836/*l72c27/tokenizer.e*/);
R=(/*RF2*/(C)->_s/*5*/);
(ds.p=0x04C04936/*l73c27/tokenizer.e*/);
/*SFN*/(C->_s/*5*/)=se_ms(0,s12_0);
(ds.p=0x04C04A36/*l74c27/tokenizer.e*/);
_done=((T6)(1));
}
/*FI]*/
break;
default:;
(ds.p=0x04C04D34/*l77c26/tokenizer.e*/);
r7append_character(&ds,se_i7(&ds,((T7*)ci(7,(/*RF2*/(C)->_s/*5*/),0x04C04D30/*l77c24/tokenizer.e*/))),_c);
}
}/*INSPECT]*/
}
/*FI]*/
}
/*FI]*/
}
}
/*FI]*/
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*TEXT_FILE_READ*/
void r39disconnect(se_dump_stack*caller,T39* C){
static se_frame_descriptor fd={"disconnect TEXT_FILE_READ",1,0,"%R39%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x04E04208/*l66c4/text_file_read.e*/;
ds.caller=caller;
ds.locals=NULL;
ds.exception_origin=NULL;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x05002A14/*l42c10/file.e*/);
ac_req(r39is_connected(&ds,C),NULL);
fd.assertion_flag=1;
}
(ds.p=0x04E04414/*l68c10/text_file_read.e*/);
basic_io_fclose((/*RF2*/(C)->_input_stream/*8*/));
(ds.p=0x04E04514/*l69c10/text_file_read.e*/);
/*SFN*/(C->_path/*1*/)=NULL;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x05002D14/*l45c10/file.e*/);
ac_ens(r6_px_not(&ds,(T6)(r39is_connected(&ds,C))),NULL);
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
}

/*TEXT_FILE_READ*/
T6 r39is_connected(se_dump_stack*caller,T39* C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"is_connected TEXT_FILE_READ",1,1,"%R39%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x04E02508/*l37c4/text_file_read.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x04E02714/*l39c10/text_file_read.e*/);
R=((T6)(((/*RF2*/(C)->_path/*1*/))!=((void*)(NULL))));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x04E0292C/*l41c22/text_file_read.e*/);
ac_ens((R)==(((/*RF2*/(C)->_path/*1*/))!=((void*)(NULL))),"definition");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*TEXT_FILE_READ*/
void r39read_character(se_dump_stack*caller,T39* C){
static se_frame_descriptor fd={"read_character TEXT_FILE_READ",1,0,"%R39%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x04E04808/*l72c4/text_file_read.e*/;
ds.caller=caller;
ds.locals=NULL;
ds.exception_origin=NULL;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x04803114/*l49c10/input_stream.e*/);
ac_req(r39is_connected(&ds,C),NULL);
(ds.p=0x04803214/*l50c10/input_stream.e*/);
ac_req(r6_px_not(&ds,(T6)((/*RF2*/(C)->_end_of_input/*6*/))),NULL);
fd.assertion_flag=1;
}
(ds.p=0x04E04A06/*l74c3/text_file_read.e*/);
/*SFN*/(C->_push_back_flag/*7*/)=((T6)(0));
/*[IF*/
if(((ds.p=0x04E04B2C/*l75c22/text_file_read.e*/),(int32_t)(((/*RF2*/(C)->_buffer_position/*17*/))>=((/*RF2*/(C)->_buffer_size/*21*/))))){
(ds.p=0x04E04C0C/*l76c6/text_file_read.e*/);
r39fill_buffer(&ds,C);
}
/*FI]*/
(ds.p=0x04E04E06/*l78c3/text_file_read.e*/);
/*SFN*/(C->_last_character/*5*/)=((/*RF2*/(C)->_buffer/*12*/))[(/*RF2*/(C)->_buffer_position/*17*/)];
(ds.p=0x04E04F06/*l79c3/text_file_read.e*/);
/*SFN*/(C->_buffer_position/*17*/)=r2_ix_43(&ds,(/*RF2*/(C)->_buffer_position/*17*/),INT8_C(1));
(ds.p=0x04E05006/*l80c3/text_file_read.e*/);
/*SFN*/(C->_end_of_input/*6*/)=((T6)((/*RF2*/(C)->_end_reached/*16*/)));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x04803514/*l53c10/input_stream.e*/);
ac_ens(r6_px_not(&ds,(T6)((/*RF2*/(C)->_push_back_flag/*7*/))),NULL);
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
}

/*TEXT_FILE_READ*/
void r39fill_buffer(se_dump_stack*caller,T39* C){
T3 _last=0;
void**locals[1];
static se_frame_descriptor fd={"fill_buffer TEXT_FILE_READ",1,1,"%R39%last%E3%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x04E0E108/*l225c4/text_file_read.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&_last;
set_dump_stack_top(&ds);/*link*/
/*[IF*/
if(((ds.p=0x04E0E524/*l229c18/text_file_read.e*/),(int32_t)(((/*RF2*/(C)->_buffer_size/*21*/))>(INT8_C(0))))){
(ds.p=0x04E0E60C/*l230c6/text_file_read.e*/);
_last=((/*RF2*/(C)->_buffer/*12*/))[r2_ix_45(&ds,(/*RF2*/(C)->_buffer_size/*21*/),INT8_C(1))];
}
/*FI]*/
(ds.p=0x04E0E814/*l232c10/text_file_read.e*/);
/*SFN*/(C->_buffer_size/*21*/)=basic_io_fread((/*RF2*/(C)->_buffer/*12*/),(/*RF2*/(C)->_capacity/*25*/),(/*RF2*/(C)->_input_stream/*8*/));
(ds.p=0x04E0EA14/*l234c10/text_file_read.e*/);
/*SFN*/(C->_buffer_position/*17*/)=INT8_C(0);
/*[IF*/
if(((ds.p=0x04E0EB24/*l235c18/text_file_read.e*/),(int32_t)(((/*RF2*/(C)->_buffer_size/*21*/))<=(INT8_C(0))))){
(ds.p=0x04E0EC0C/*l236c6/text_file_read.e*/);
/*SFN*/(C->_end_reached/*16*/)=((T6)(1));
(ds.p=0x04E0ED1A/*l237c13/text_file_read.e*/);
((/*RF2*/(C)->_buffer/*12*/))[/*IC*/(T2)(INT8_C(0))]=(_last);
(ds.p=0x04E0EF0C/*l239c6/text_file_read.e*/);
/*SFN*/(C->_buffer_size/*21*/)=INT8_C(1);
(ds.p=0x04E0F00C/*l240c6/text_file_read.e*/);
/*SFN*/(C->_buffer_position/*17*/)=INT8_C(1);
}
/*FI]*/
set_dump_stack_top(caller);/*unlink*/
}

/*TEXT_FILE_READ*/
void r39connect_to(se_dump_stack*caller,T39* C,T0* a1){
T8 _p=NULL;
void**locals[2];
static se_frame_descriptor fd={"connect_to TEXT_FILE_READ",1,2,"%R39%new_path%R7%p%E8%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x04E02C08/*l44c4/text_file_read.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&_p;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x05002214/*l34c10/file.e*/);
ac_req(r6_px_not(&ds,(T6)(r39is_connected(&ds,C))),NULL);
(ds.p=0x05002314/*l35c10/file.e*/);
ac_req(r6_px_not(&ds,(T6)(r7is_empty(&ds,se_i7(&ds,((T7*)ci(7,a1,0x0500231C/*l35c14/file.e*/)))))),NULL);
fd.assertion_flag=1;
}
(ds.p=0x04E03214/*l50c10/text_file_read.e*/);
_p=r7to_external(&ds,se_i7(&ds,((T7*)ci(7,a1,0x04E0321E/*l50c15/text_file_read.e*/))));
(ds.p=0x04E03314/*l51c10/text_file_read.e*/);
/*SFN*/(C->_input_stream/*8*/)=basic_io_text_file_read_open(_p);
/*[IF*/
if(((ds.p=0x04E03434/*l52c26/text_file_read.e*/),(NULL!=(/*RF2*/(C)->_input_stream/*8*/)))){
(ds.p=0x04E0351A/*l53c13/text_file_read.e*/);
/*SFN*/(C->_push_back_flag/*7*/)=((T6)(0));
(ds.p=0x04E0360C/*l54c6/text_file_read.e*/);
/*SFN*/(C->_end_of_input/*6*/)=((T6)(0));
(ds.p=0x04E0371A/*l55c13/text_file_read.e*/);
/*SFN*/(C->_path/*1*/)=a1;
/*[IF*/
if(((/*RF2*/(C)->_capacity/*25*/))==(INT8_C(0))){
(ds.p=0x04E03912/*l57c9/text_file_read.e*/);
/*SFN*/(C->_buffer/*12*/)=new9(INT16_C(4096));
(ds.p=0x04E03A12/*l58c9/text_file_read.e*/);
/*SFN*/(C->_capacity/*25*/)=INT16_C(4096);
}
/*FI]*/
(ds.p=0x04E03C0C/*l60c6/text_file_read.e*/);
/*SFN*/(C->_end_reached/*16*/)=((T6)(0));
(ds.p=0x04E03D0C/*l61c6/text_file_read.e*/);
/*SFN*/(C->_buffer_position/*17*/)=INT8_C(0);
(ds.p=0x04E03E0C/*l62c6/text_file_read.e*/);
/*SFN*/(C->_buffer_size/*21*/)=INT8_C(0);
}
/*FI]*/
set_dump_stack_top(caller);/*unlink*/
}

/*RULE*/
T6 r16is_default(se_dump_stack*caller,T16* C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"is_default GENERAL",1,1,"%R16%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x01E10F08/*l271c4/general.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x01E11806/*l280c3/general.e*/);
R=((T6)((C)==((void*)(r16default(&ds,C)))));
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*RULE*/
T2 r16upper(se_dump_stack*caller,T16* C){
T2 R=0;
void**locals[1];
static se_frame_descriptor fd={"upper RULE",1,1,"%R16%Result%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x0200220A/*l34c5/rule.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x02002412/*l36c9/rule.e*/);
R=(/*RF2*/(se_i22(&ds,((T22*)ci(22,(/*RF2*/(C)->_rules/*1*/),0x02002426/*l36c19/rule.e*/))))->_upper/*9*/);
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*RULE*/
T2 r16lower(se_dump_stack*caller,T16* C){
T2 R=0;
void**locals[1];
static se_frame_descriptor fd={"lower RULE",1,1,"%R16%Result%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x0200270A/*l39c5/rule.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x02002912/*l41c9/rule.e*/);
R=(/*RF2*/(se_i22(&ds,((T22*)ci(22,(/*RF2*/(C)->_rules/*1*/),0x02002926/*l41c19/rule.e*/))))->_lower/*13*/);
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*RULE*/
T0* r16rule(se_dump_stack*caller,T16* C,T2 a1){
T0* R=NULL;
void**locals[2];
static se_frame_descriptor fd={"rule RULE",1,2,"%R16%i%E2%Result%R7%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x02001D0A/*l29c5/rule.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x02001F12/*l31c9/rule.e*/);
R=r22item(&ds,se_i22(&ds,((T22*)ci(22,(/*RF2*/(C)->_rules/*1*/),0x02001F26/*l31c19/rule.e*/))),a1);
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*RULE*/
void r16make(se_dump_stack*caller,T16* C,T0* a1){
void**locals[1];
static se_frame_descriptor fd={"make RULE",1,1,"%R16%r%R22%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x0200080A/*l8c5/rule.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x02000A14/*l10c10/rule.e*/);
/*SFN*/(C->_rules/*1*/)=a1;
set_dump_stack_top(caller);/*unlink*/
}

/*RULE*/
T0* r16default(se_dump_stack*caller,T16* C){
T0* R=NULL;
void**locals[1];
static se_frame_descriptor fd={"default GENERAL",1,1,"%R16%Result%R16%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x01E10816/*l264c11/general.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*DATABASE*/
T6 r30qquery(se_dump_stack*caller,T30* C,T0* a1,T0* a2){
T6 R=0;
T0* _qq=NULL;
T0* _rr=NULL;
T2 _i=0;
T2 _j=0;
T2 _k=0;
T6 _matched=0;
void**locals[9];
static se_frame_descriptor fd={"qquery DATABASE",1,9,"%R30%q%R22%r%R44%Result%E6%qq%R22%rr%R44%i%E2%j%E2%k%E2%matched%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x03C02806/*l40c3/database.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&R;
locals[3]=(void**)&_qq;
locals[4]=(void**)&_rr;
locals[5]=(void**)&_i;
locals[6]=(void**)&_j;
locals[7]=(void**)&_k;
locals[8]=(void**)&_matched;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x03C02F0E/*l47c7/database.e*/);
_matched=((T6)(0));
(ds.p=0x03C04D12/*l77c9/database.e*/);
_i=(/*RF2*/(se_i31(&ds,((T31*)ci(31,(/*RF2*/(C)->_db/*1*/),0x03C04D1C/*l77c14/database.e*/))))->_lower/*13*/);
while (!(((ds.p=0x03C04F42/*l79c33/database.e*/),r6_ix_or(&ds,(T6)(r6_ix_or(&ds,(T6)((int32_t)((_i)>((/*RF2*/(se_i31(&ds,((T31*)ci(31,(/*RF2*/(C)->_db/*1*/),0x03C04F1A/*l79c13/database.e*/))))->_upper/*9*/)))),(T6)(_matched))),(T6)((/*RF2*/(C)->_cut/*5*/))))))
{
/*[IF*/
if(((ds.p=0x03C05132/*l81c25/database.e*/),(T6)(((r22count(&ds,se_i22(&ds,((T22*)ci(22,a1,0x03C0511A/*l81c13/database.e*/)))))==(INT8_C(0)))||((T6)((T6)(((r22count(&ds,se_i22(&ds,((T22*)ci(22,a1,0x03C05144/*l81c34/database.e*/)))))==(INT8_C(1)))&&((T6)(r7is_equal(&ds,se_i7(&ds,((T7*)ci(7,r22item(&ds,se_i22(&ds,((T22*)ci(22,a1,0x03C0521A/*l82c13/database.e*/))),(/*RF2*/(se_i22(&ds,((T22*)ci(22,a1,0x03C05228/*l82c20/database.e*/))))->_lower/*13*/)),0x03C0521E/*l82c15/database.e*/))),se_ms(1,s30_33)))))))))){
(ds.p=0x03C05416/*l84c11/database.e*/);
_matched=((T6)(1));
(ds.p=0x03C0561A/*l86c13/database.e*/);
_j=(/*RF2*/(se_i44(&ds,((T44*)ci(44,a2,0x03C05624/*l86c18/database.e*/))))->_lower/*13*/);
while (!(((ds.p=0x03C0581E/*l88c15/database.e*/),(int32_t)((_j)>((/*RF2*/(se_i44(&ds,((T44*)ci(44,a2,0x03C05822/*l88c17/database.e*/))))->_upper/*9*/))))))
{
(ds.p=0x03C05A20/*l90c16/database.e*/);
r34put_integer(&ds,((T34*)ci(34,oBC15io,0x03C05A1A/*l90c13/database.e*/)),/*IC*/(T11)(r44item(&ds,se_i44(&ds,((T44*)ci(44,a2,0x03C05A38/*l90c28/database.e*/))),_j)));
(ds.p=0x03C05B20/*l91c16/database.e*/);
r34put_string(&ds,((T34*)ci(34,oBC15io,0x03C05B1A/*l91c13/database.e*/)),se_ms(1," "));
(ds.p=0x03C05C1A/*l92c13/database.e*/);
_j=r2_ix_43(&ds,_j,INT8_C(1));
}
(ds.p=0x03C05E1C/*l94c14/database.e*/);
r34put_new_line(&ds,((T34*)ci(34,oBC15io,0x03C05E16/*l94c11/database.e*/)));
(ds.p=0x03C05F16/*l95c11/database.e*/);
R=((T6)(0));
}
else{
(ds.p=0x03C06116/*l97c11/database.e*/);
{T22*n=new22();
r22make(&ds,n,/*IC*/(T2)(INT8_C(1)),/*IC*/(T2)(INT8_C(0)));
_qq=((T0*)n);
se_i22(&ds,n);}
(ds.p=0x03C06216/*l98c11/database.e*/);
{T44*n=new44();
r44make(&ds,n,/*IC*/(T2)(INT8_C(1)),/*IC*/(T2)(INT8_C(0)));
_rr=((T0*)n);
se_i44(&ds,n);}
/*[IF*/
if(((ds.p=0x03C0643C/*l100c30/database.e*/),r7is_equal(&ds,se_i7(&ds,((T7*)ci(7,r22item(&ds,se_i22(&ds,((T22*)ci(22,a1,0x03C0641C/*l100c14/database.e*/))),(/*RF2*/(se_i22(&ds,((T22*)ci(22,a1,0x03C0642A/*l100c21/database.e*/))))->_lower/*13*/)),0x03C06420/*l100c16/database.e*/))),se_ms(1,s30_33)))){
(ds.p=0x03C0651E/*l101c15/database.e*/);
r22remove_first(&ds,se_i22(&ds,((T22*)ci(22,a1,0x03C0651A/*l101c13/database.e*/))));
(ds.p=0x03C0661A/*l102c13/database.e*/);
R=((T6)(1));
}
/*FI]*/
(ds.p=0x03C06916/*l105c11/database.e*/);
_qq=r22twin(&ds,se_i22(&ds,((T22*)ci(22,a1,0x03C06922/*l105c17/database.e*/))));
(ds.p=0x03C06A16/*l106c11/database.e*/);
_rr=r44twin(&ds,se_i44(&ds,((T44*)ci(44,a2,0x03C06A22/*l106c17/database.e*/))));
(ds.p=0x03C06B1C/*l107c14/database.e*/);
r22remove_first(&ds,se_i22(&ds,((T22*)ci(22,_qq,0x03C06B16/*l107c11/database.e*/))));
/*[IF*/
if(((ds.p=0x03C06D60/*l109c48/database.e*/),r7is_equal(&ds,se_i7(&ds,((T7*)ci(7,r16rule(&ds,((T16*)ci(16,r31item(&ds,se_i31(&ds,((T31*)ci(31,(/*RF2*/(C)->_db/*1*/),0x03C06D1C/*l109c14/database.e*/))),_i),0x03C06D22/*l109c17/database.e*/)),r16lower(&ds,((T16*)ci(16,r31item(&ds,se_i31(&ds,((T31*)ci(31,(/*RF2*/(C)->_db/*1*/),0x03C06D3C/*l109c30/database.e*/))),_i),0x03C06D42/*l109c33/database.e*/)))),0x03C06D32/*l109c25/database.e*/))),r22item(&ds,se_i22(&ds,((T22*)ci(22,a1,0x03C06D72/*l109c57/database.e*/))),(/*RF2*/(se_i22(&ds,((T22*)ci(22,a1,0x03C06D80/*l109c64/database.e*/))))->_lower/*13*/))))){
(ds.p=0x03C0701E/*l112c15/database.e*/);
_k=r16upper(&ds,((T16*)ci(16,r31item(&ds,se_i31(&ds,((T31*)ci(31,(/*RF2*/(C)->_db/*1*/),0x03C07028/*l112c20/database.e*/))),_i),0x03C0702E/*l112c23/database.e*/)));
while (!(((ds.p=0x03C07222/*l114c17/database.e*/),(_k)==(INT8_C(1)))))
{
(ds.p=0x03C07424/*l116c18/database.e*/);
r22add_first(&ds,se_i22(&ds,((T22*)ci(22,_qq,0x03C0741E/*l116c15/database.e*/))),r16rule(&ds,((T16*)ci(16,r31item(&ds,se_i31(&ds,((T31*)ci(31,(/*RF2*/(C)->_db/*1*/),0x03C07438/*l116c28/database.e*/))),_i),0x03C0743E/*l116c31/database.e*/)),_k));
(ds.p=0x03C0751E/*l117c15/database.e*/);
_k=r2_ix_45(&ds,_k,INT8_C(1));
}
(ds.p=0x03C07720/*l119c16/database.e*/);
r44add_last(&ds,se_i44(&ds,((T44*)ci(44,_rr,0x03C0771A/*l119c13/database.e*/))),_i);
/*[IF*/
if(((ds.p=0x03C07820/*l120c16/database.e*/),r30qquery(&ds,C,_qq,_rr))){
(ds.p=0x03C0791E/*l121c15/database.e*/);
/*SFN*/(C->_cut/*5*/)=((T6)(1));
}
/*FI]*/
}
/*FI]*/
}
/*FI]*/
(ds.p=0x03C07D12/*l125c9/database.e*/);
_i=r2_ix_43(&ds,_i,INT8_C(1));
}
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*DATABASE*/
void r30addrule(se_dump_stack*caller,T30* C,T0* a1){
void**locals[1];
static se_frame_descriptor fd={"addrule DATABASE",1,1,"%R30%r%R16%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x03C00906/*l9c3/database.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x03C00B0C/*l11c6/database.e*/);
r31add_last(&ds,se_i31(&ds,((T31*)ci(31,(/*RF2*/(C)->_db/*1*/),0x03C00B06/*l11c3/database.e*/))),a1);
set_dump_stack_top(caller);/*unlink*/
}
T0*oBC15io=NULL;

/*DATABASE*/
T6 r30query(se_dump_stack*caller,T30* C,T0* a1,T0* a2){
T6 R=0;
void**locals[3];
static se_frame_descriptor fd={"query DATABASE",1,3,"%R30%q%R22%r%R44%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x03C02206/*l34c3/database.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x03C0240E/*l36c7/database.e*/);
/*SFN*/(C->_dummy/*6*/)=((T6)(r30qquery(&ds,C,a1,a2)));
(ds.p=0x03C0250E/*l37c7/database.e*/);
R=((T6)(1));
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*DATABASE*/
void r30make(se_dump_stack*caller,T30* C){
static se_frame_descriptor fd={"make DATABASE",1,0,"%R30%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x03C00E06/*l14c3/database.e*/;
ds.caller=caller;
ds.locals=NULL;
ds.exception_origin=NULL;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x03C0100E/*l16c7/database.e*/);
{T31*n=new31();
r31make(&ds,n,/*IC*/(T2)(INT8_C(1)),/*IC*/(T2)(INT8_C(0)));
/*SFN*/(C->_db/*1*/)=((T0*)n);
se_i31(&ds,n);}
(ds.p=0x03C0110E/*l17c7/database.e*/);
/*SFN*/(C->_cut/*5*/)=((T6)(0));
set_dump_stack_top(caller);/*unlink*/
}

/*STD_OUTPUT*/
void r37make(se_dump_stack*caller,T37* C){
static se_frame_descriptor fd={"make STD_OUTPUT",1,0,"%R37%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x04A02808/*l40c4/std_output.e*/;
ds.caller=caller;
ds.locals=NULL;
ds.exception_origin=NULL;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x04A02A14/*l42c10/std_output.e*/);
/*SFN*/(C->_buffer/*5*/)=new9(INT16_C(4096));
(ds.p=0x04A02B14/*l43c10/std_output.e*/);
/*SFN*/(C->_capacity/*9*/)=INT16_C(4096);
set_dump_stack_top(caller);/*unlink*/
}

/*STD_OUTPUT*/
void r37flush(se_dump_stack*caller,T37* C){
static se_frame_descriptor fd={"flush STD_OUTPUT",1,0,"%R37%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x04A03C08/*l60c4/std_output.e*/;
ds.caller=caller;
ds.locals=NULL;
ds.exception_origin=NULL;
set_dump_stack_top(&ds);/*link*/
/*[IF*/
if(((ds.p=0x04A03E2C/*l62c22/std_output.e*/),(int32_t)(((/*RF2*/(C)->_buffer_position/*1*/))>(INT8_C(0))))){
(ds.p=0x04A03F0C/*l63c6/std_output.e*/);
r37write_buffer(&ds,C);
}
/*FI]*/
(ds.p=0x04A04106/*l65c3/std_output.e*/);
basic_io_flush(basic_io_stdout);
set_dump_stack_top(caller);/*unlink*/
}

/*STD_OUTPUT*/
void r37write_buffer(se_dump_stack*caller,T37* C){
static se_frame_descriptor fd={"write_buffer STD_OUTPUT",1,0,"%R37%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x04A04C08/*l76c4/std_output.e*/;
ds.caller=caller;
ds.locals=NULL;
ds.exception_origin=NULL;
set_dump_stack_top(&ds);/*link*/
/*[IF*/
if(((ds.p=0x04A04E2C/*l78c22/std_output.e*/),(int32_t)(((/*RF2*/(C)->_buffer_position/*1*/))>(INT8_C(0))))){
(ds.p=0x04A04F0C/*l79c6/std_output.e*/);
basic_io_fwrite((/*RF2*/(C)->_buffer/*5*/),(/*RF2*/(C)->_buffer_position/*1*/),basic_io_stdout);
(ds.p=0x04A0500C/*l80c6/std_output.e*/);
/*SFN*/(C->_buffer_position/*1*/)=INT8_C(0);
}
/*FI]*/
set_dump_stack_top(caller);/*unlink*/
}

/*STD_OUTPUT*/
void r37put_character(se_dump_stack*caller,T37* C,T3 a1){
void**locals[1];
static se_frame_descriptor fd={"put_character STD_OUTPUT",1,1,"%R37%c%E3%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x04A03008/*l48c4/std_output.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x04602314/*l35c10/output_stream.e*/);
ac_req(1,NULL);
fd.assertion_flag=1;
}
/*[IF*/
if(((ds.p=0x04A0323A/*l50c29/std_output.e*/),(int32_t)(((/*RF2*/(C)->_buffer_position/*1*/))>=(INT16_C(4096))))){
(ds.p=0x04A0331A/*l51c13/std_output.e*/);
r37write_buffer(&ds,C);
}
/*FI]*/
(ds.p=0x04A03514/*l53c10/std_output.e*/);
((/*RF2*/(C)->_buffer/*5*/))[(/*RF2*/(C)->_buffer_position/*1*/)]=(a1);
(ds.p=0x04A03614/*l54c10/std_output.e*/);
/*SFN*/(C->_buffer_position/*1*/)=r2_ix_43(&ds,(/*RF2*/(C)->_buffer_position/*1*/),INT8_C(1));
/*[IF*/
if((a1)==(((T3)'\n'))){
(ds.p=0x04A0380C/*l56c6/std_output.e*/);
r37write_buffer(&ds,C);
}
/*FI]*/
set_dump_stack_top(caller);/*unlink*/
}
T0*oBC15command_arguments=NULL;
int fBC15command_arguments=0;

/*A5*/
T0* r12command_arguments(se_dump_stack*caller){
if(fBC15command_arguments==0){fBC15command_arguments=1;{
T2 _i=0;
T0* _arg=NULL;
void**locals[3];
static se_frame_descriptor fd={"command_arguments GENERAL",0,3,"Result%R42%i%E2%arg%R7%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=NULL;
ds.p=0x01E1CD16/*l461c11/general.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&oBC15command_arguments;
locals[1]=(void**)&_i;
locals[2]=(void**)&_arg;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x01E1D51A/*l469c13/general.e*/);
_i=se_argc;
(ds.p=0x01E1D61A/*l470c13/general.e*/);
{T42*n=new42();
oBC15command_arguments=((T0*)n);
r42make(&ds,n,_i);
se_i42(&ds,n);}
while (!(((ds.p=0x01E1D81E/*l472c15/general.e*/),(_i)==(INT8_C(0)))))
{
(ds.p=0x01E1DA1A/*l474c13/general.e*/);
_i=r2_ix_45(&ds,_i,INT8_C(1));
(ds.p=0x01E1DB1A/*l475c13/general.e*/);
_arg=((T0*)se_string(se_argv[_i]));
(ds.p=0x01E1DC28/*l476c20/general.e*/);
r42put(&ds,se_i42(&ds,((T42*)ci(42,oBC15command_arguments,0x01E1DC1A/*l476c13/general.e*/))),_arg,_i);
}
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x01E1DF14/*l479c10/general.e*/);
ac_ens(r6_px_not(&ds,(T6)(r42is_empty(&ds,se_i42(&ds,((T42*)ci(42,oBC15command_arguments,0x01E1DF1C/*l479c14/general.e*/)))))),NULL);
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
}}
return oBC15command_arguments;
}

/*A5*/
T2 r12argument_count(se_dump_stack*caller,T12* C){
T2 R=0;
void**locals[1];
static se_frame_descriptor fd={"argument_count GENERAL",1,1,"%R12%Result%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x01E1B808/*l440c4/general.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x01E1BC14/*l444c10/general.e*/);
R=(/*RF2*/(se_i42(&ds,((T42*)ci(42,r12command_arguments(&ds),0x01E1BC28/*l444c20/general.e*/))))->_upper/*9*/);
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x01E1BE22/*l446c17/general.e*/);
ac_ens((int32_t)((R)>=(/*IC*/(T2)(INT8_C(0)))),NULL);
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*A5*/
void r12make(se_dump_stack*caller,T12* C){
T0* _s=NULL;
T0* _rs=NULL;
T0* _r=NULL;
T0* _q=NULL;
T2 _i=0;
T0* _rr=NULL;
void**locals[6];
static se_frame_descriptor fd={"make A5",1,6,"%R12%s%R7%rs%R22%r%R16%q%R22%i%E2%rr%R44%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x0180070A/*l7c5/a5.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&_s;
locals[1]=(void**)&_rs;
locals[2]=(void**)&_r;
locals[3]=(void**)&_q;
locals[4]=(void**)&_i;
locals[5]=(void**)&_rr;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x01801012/*l16c9/a5.e*/);
{T38*n=new38();
r38make(&ds,n,r12argument(&ds,C,/*IC*/(T2)(INT8_C(1))));
/*SFN*/(C->_tok/*1*/)=((T0*)n);
}
(ds.p=0x01801112/*l17c9/a5.e*/);
{T30*n=new30();
r30make(&ds,n);
/*SFN*/(C->_db/*5*/)=((T0*)n);
}
(ds.p=0x01801212/*l18c9/a5.e*/);
{T22*n=new22();
r22make(&ds,n,/*IC*/(T2)(INT8_C(1)),/*IC*/(T2)(INT8_C(0)));
_rs=((T0*)n);
se_i22(&ds,n);}
(ds.p=0x01801312/*l19c9/a5.e*/);
{T22*n=new22();
r22make(&ds,n,/*IC*/(T2)(INT8_C(1)),/*IC*/(T2)(INT8_C(0)));
_q=((T0*)n);
se_i22(&ds,n);}
(ds.p=0x01801412/*l20c9/a5.e*/);
{T44*n=new44();
r44make(&ds,n,/*IC*/(T2)(INT8_C(1)),/*IC*/(T2)(INT8_C(0)));
_rr=((T0*)n);
se_i44(&ds,n);}
(ds.p=0x01801616/*l22c11/a5.e*/);
_s=se_ms(0,s12_0);
while (!(((ds.p=0x0180181A/*l24c13/a5.e*/),r7is_equal(&ds,se_i7(&ds,((T7*)ci(7,_s,0x01801816/*l24c11/a5.e*/))),se_ms(3,s12_2190)))))
{
(ds.p=0x01801A16/*l26c11/a5.e*/);
_s=r38next_token(&ds,((T38*)ci(38,(/*RF2*/(C)->_tok/*1*/),0x01801A20/*l26c16/a5.e*/)));
/*[IF*/
if(((ds.p=0x01801D20/*l29c16/a5.e*/),r7is_equal(&ds,se_i7(&ds,((T7*)ci(7,_s,0x01801D1C/*l29c14/a5.e*/))),se_ms(1,s12_46)))){
(ds.p=0x01801E1C/*l30c14/a5.e*/);
{T16*n=new16();
r16make(&ds,n,_rs);
_r=((T0*)n);
}
(ds.p=0x01801F22/*l31c17/a5.e*/);
r30addrule(&ds,((T30*)ci(30,(/*RF2*/(C)->_db/*5*/),0x01801F1C/*l31c14/a5.e*/)),_r);
(ds.p=0x0180201C/*l32c14/a5.e*/);
{T22*n=new22();
r22make(&ds,n,/*IC*/(T2)(INT8_C(1)),/*IC*/(T2)(INT8_C(0)));
_rs=((T0*)n);
se_i22(&ds,n);}
}
else{
/*[IF*/
if(((ds.p=0x01802220/*l34c16/a5.e*/),r6_px_not(&ds,(T6)(r7is_equal(&ds,se_i7(&ds,((T7*)ci(7,_s,0x01802228/*l34c20/a5.e*/))),se_ms(2,s12_335)))))){
(ds.p=0x01802324/*l35c18/a5.e*/);
r22add_last(&ds,se_i22(&ds,((T22*)ci(22,_rs,0x0180231E/*l35c15/a5.e*/))),_s);
}
/*FI]*/
}
/*FI]*/
}
(ds.p=0x01802816/*l40c11/a5.e*/);
_i=INT8_C(2);
while (!(((ds.p=0x01802A1A/*l42c13/a5.e*/),(int32_t)((_i)>(r12argument_count(&ds,C))))))
{
(ds.p=0x01802C1A/*l44c13/a5.e*/);
r22add_last(&ds,se_i22(&ds,((T22*)ci(22,_q,0x01802C16/*l44c11/a5.e*/))),r12argument(&ds,C,_i));
(ds.p=0x01802D16/*l45c11/a5.e*/);
_i=r2_ix_43(&ds,_i,INT8_C(1));
}
(ds.p=0x01803B12/*l59c9/a5.e*/);
/*SFN*/(C->_dummy/*9*/)=((T6)(r30query(&ds,((T30*)ci(30,(/*RF2*/(C)->_db/*5*/),0x01803B24/*l59c18/a5.e*/)),_q,_rr)));
set_dump_stack_top(caller);/*unlink*/
}

/*A5*/
T0* r12argument(se_dump_stack*caller,T12* C,T2 a1){
T0* R=NULL;
void**locals[2];
static se_frame_descriptor fd={"argument GENERAL",1,2,"%R12%i%E2%Result%R7%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x01E1C108/*l449c4/general.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x01E1C518/*l453c12/general.e*/);
ac_req((int32_t)((a1)>=(/*IC*/(T2)(INT8_C(0)))),NULL);
(ds.p=0x01E1C618/*l454c12/general.e*/);
ac_req((int32_t)((a1)<=(r12argument_count(&ds,C))),NULL);
fd.assertion_flag=1;
}
(ds.p=0x01E1C814/*l456c10/general.e*/);
R=r42item(&ds,se_i42(&ds,((T42*)ci(42,r12command_arguments(&ds),0x01E1C828/*l456c20/general.e*/))),a1);
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x01E1CA22/*l458c17/general.e*/);
ac_ens((R)!=((void*)(NULL)),NULL);
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}
T12*eiffel_root_object=NULL;
int se_argc;
char**se_argv;
T7*g[47];
T7*t[47];
char*p[47];
void(*se_prinT[47])(FILE*,void**);
int se_strucT[47];

void se_atexit(void){
se_frame_descriptor fd={"<atexit wrapper>",0,0,"",1};
se_dump_stack ds;
ds.fd=&fd;
ds.p=0;
ds.caller=NULL;
ds.exception_origin=NULL;
ds.locals=NULL;
{
T0*C=oBC15std_output;
r37flush(&ds,((T37*)C));
}
}

void initialize_eiffel_runtime(int argc,char*argv[]){
se_frame_descriptor irfd={"<runtime init>",0,0,"",1};
se_dump_stack ds = {NULL,NULL,0,NULL,NULL};
ds.fd=&irfd;
set_dump_stack_top(&ds);/*link*/
se_argc=argc;
se_argv=argv;
atexit(se_atexit);
gcmt=((mch**)se_malloc((gcmt_max+1)*sizeof(void*)));
if (!stack_bottom) stack_bottom=((void**)(&argc));
p[0]="???";
p[21]="/software/smarteiffel-1.1/distribution/lib/kernel/safe_equal.e";
p[35]="/software/smarteiffel-1.1/distribution/lib/io/output_stream.e";
p[14]="/software/smarteiffel-1.1/distribution/lib/kernel/platform.e";
p[40]="/software/smarteiffel-1.1/distribution/lib/io/file.e";
p[25]="/software/smarteiffel-1.1/distribution/lib/kernel/integer_general.e";
p[2]="/software/smarteiffel-1.1/distribution/lib/kernel/integer.e";
p[12]="/u3/npow/cs442/a5/a5.e";
p[7]="/software/smarteiffel-1.1/distribution/lib/kernel/string.e";
p[23]="/software/smarteiffel-1.1/distribution/lib/kernel/comparable.e";
p[1]="/software/smarteiffel-1.1/distribution/lib/kernel/integer_8.e";
p[16]="/u3/npow/cs442/a5/rule.e";
p[30]="/u3/npow/cs442/a5/database.e";
p[13]="/software/smarteiffel-1.1/distribution/lib/kernel/any.e";
p[41]="/software/smarteiffel-1.1/distribution/lib/base/fixed_array.e";
p[37]="/software/smarteiffel-1.1/distribution/lib/io/std_output.e";
p[26]="/software/smarteiffel-1.1/distribution/lib/kernel/numeric.e";
p[39]="/software/smarteiffel-1.1/distribution/lib/io/text_file_read.e";
p[15]="/software/smarteiffel-1.1/distribution/lib/kernel/general.e";
p[20]="TUPLE";
p[10]="/software/smarteiffel-1.1/distribution/lib/kernel/integer_16.e";
p[11]="/software/smarteiffel-1.1/distribution/lib/kernel/integer_64.e";
p[17]="/software/smarteiffel-1.1/distribution/lib/kernel/array.e";
p[24]="/software/smarteiffel-1.1/distribution/lib/kernel/hashable.e";
p[8]="/software/smarteiffel-1.1/distribution/lib/kernel/pointer.e";
p[38]="/u3/npow/cs442/a5/tokenizer.e";
p[27]="/software/smarteiffel-1.1/distribution/lib/kernel/native_array.e";
p[19]="/software/smarteiffel-1.1/distribution/lib/kernel/collection.e";
p[3]="/software/smarteiffel-1.1/distribution/lib/kernel/character.e";
p[28]="/software/smarteiffel-1.1/distribution/lib/kernel/string_handler.e";
p[36]="/software/smarteiffel-1.1/distribution/lib/io/input_stream.e";
p[6]="/software/smarteiffel-1.1/distribution/lib/kernel/boolean.e";
p[34]="/software/smarteiffel-1.1/distribution/lib/io/std_input_output.e";
p[18]="/software/smarteiffel-1.1/distribution/lib/base/arrayed_collection.e";
se_prinT[34]=((void(*)(FILE*,void**))se_prinT34);
se_strucT[34]=sizeof(T34);
se_prinT[8]=((void(*)(FILE*,void**))se_prinT8);
se_strucT[8]=sizeof(T8);
se_prinT[6]=((void(*)(FILE*,void**))se_prinT6);
se_strucT[6]=sizeof(T6);
se_prinT[44]=((void(*)(FILE*,void**))se_prinT44);
p[44]=p[17];
se_strucT[44]=sizeof(T44);
se_prinT[3]=((void(*)(FILE*,void**))se_prinT3);
se_strucT[3]=sizeof(T3);
se_prinT[1]=((void(*)(FILE*,void**))se_prinT1);
se_strucT[1]=sizeof(T1);
se_prinT[33]=((void(*)(FILE*,void**))se_prinT33);
p[33]=p[27];
se_strucT[33]=sizeof(T33);
se_prinT[38]=((void(*)(FILE*,void**))se_prinT38);
se_strucT[38]=sizeof(T38);
se_prinT[31]=((void(*)(FILE*,void**))se_prinT31);
p[31]=p[17];
se_strucT[31]=sizeof(T31);
se_prinT[42]=((void(*)(FILE*,void**))se_prinT42);
p[42]=p[41];
se_strucT[42]=sizeof(T42);
se_prinT[39]=((void(*)(FILE*,void**))se_prinT39);
se_strucT[39]=sizeof(T39);
se_prinT[29]=((void(*)(FILE*,void**))se_prinT29);
p[29]=p[27];
se_strucT[29]=sizeof(T29);
se_prinT[7]=((void(*)(FILE*,void**))se_prinT7);
se_strucT[7]=sizeof(T7);
se_prinT[9]=((void(*)(FILE*,void**))se_prinT9);
p[9]=p[27];
se_strucT[9]=sizeof(T9);
se_prinT[2]=((void(*)(FILE*,void**))se_prinT2);
se_strucT[2]=sizeof(T2);
se_prinT[16]=((void(*)(FILE*,void**))se_prinT16);
se_strucT[16]=sizeof(T16);
se_prinT[22]=((void(*)(FILE*,void**))se_prinT22);
p[22]=p[17];
se_strucT[22]=sizeof(T22);
se_prinT[12]=((void(*)(FILE*,void**))se_prinT12);
se_strucT[12]=sizeof(T12);
se_prinT[11]=((void(*)(FILE*,void**))se_prinT11);
se_strucT[11]=sizeof(T11);
se_prinT[45]=((void(*)(FILE*,void**))se_prinT45);
p[45]=p[27];
se_strucT[45]=sizeof(T45);
se_prinT[10]=((void(*)(FILE*,void**))se_prinT10);
se_strucT[10]=sizeof(T10);
se_prinT[30]=((void(*)(FILE*,void**))se_prinT30);
se_strucT[30]=sizeof(T30);
se_prinT[37]=((void(*)(FILE*,void**))se_prinT37);
se_strucT[37]=sizeof(T37);
g[21]=(T7*)se_string("SAFE_EQUAL");
g[35]=(T7*)se_string("OUTPUT_STREAM");
g[14]=(T7*)se_string("PLATFORM");
g[40]=(T7*)se_string("FILE");
g[25]=(T7*)se_string("INTEGER_GENERAL");
g[2]=(T7*)se_string("INTEGER");
g[12]=(T7*)se_string("A5");
g[7]=(T7*)se_string("STRING");
g[23]=(T7*)se_string("COMPARABLE");
g[1]=(T7*)se_string("INTEGER_8");
g[16]=(T7*)se_string("RULE");
g[30]=(T7*)se_string("DATABASE");
g[13]=(T7*)se_string("ANY");
g[41]=(T7*)se_string("FIXED_ARRAY");
g[37]=(T7*)se_string("STD_OUTPUT");
g[26]=(T7*)se_string("NUMERIC");
g[39]=(T7*)se_string("TEXT_FILE_READ");
g[15]=(T7*)se_string("GENERAL");
g[20]=(T7*)se_string("TUPLE");
g[10]=(T7*)se_string("INTEGER_16");
g[11]=(T7*)se_string("INTEGER_64");
g[17]=(T7*)se_string("ARRAY");
g[24]=(T7*)se_string("HASHABLE");
g[8]=(T7*)se_string("POINTER");
g[38]=(T7*)se_string("TOKENIZER");
g[27]=(T7*)se_string("NATIVE_ARRAY");
g[19]=(T7*)se_string("COLLECTION");
g[3]=(T7*)se_string("CHARACTER");
g[28]=(T7*)se_string("STRING_HANDLER");
g[36]=(T7*)se_string("INPUT_STREAM");
g[6]=(T7*)se_string("BOOLEAN");
g[0]=(T7*)se_string("NONE");
g[34]=(T7*)se_string("STD_INPUT_OUTPUT");
g[18]=(T7*)se_string("ARRAYED_COLLECTION");
g[44]=g[17];
g[33]=g[27];
g[31]=g[17];
g[42]=g[41];
g[29]=g[27];
g[9]=g[27];
g[22]=g[17];
g[45]=g[27];
t[34]=g[34];
t[8]=g[8];
t[6]=g[6];
t[44]=(T7*)se_string("ARRAY[INTEGER]");
t[3]=g[3];
t[1]=g[1];
t[33]=(T7*)se_string("NATIVE_ARRAY[RULE]");
t[38]=g[38];
t[31]=(T7*)se_string("ARRAY[RULE]");
t[42]=(T7*)se_string("FIXED_ARRAY[STRING]");
t[39]=g[39];
t[29]=(T7*)se_string("NATIVE_ARRAY[STRING]");
t[7]=g[7];
t[9]=(T7*)se_string("NATIVE_ARRAY[CHARACTER]");
t[2]=g[2];
t[16]=g[16];
t[22]=(T7*)se_string("ARRAY[STRING]");
t[12]=g[12];
t[11]=g[11];
t[45]=(T7*)se_string("NATIVE_ARRAY[INTEGER]");
t[10]=g[10];
t[30]=g[30];
t[37]=g[37];
#ifdef SIGINT
signal(SIGINT,se_signal_handler);
#endif
#ifdef SIGTERM
signal(SIGTERM,se_signal_handler);
#endif
#ifdef SIGQUIT
signal(SIGQUIT,se_signal_handler);
#endif
#ifdef SIGILL
signal(SIGILL,se_signal_handler);
#endif
#ifdef SIGABRT
signal(SIGABRT,se_signal_handler);
#endif
#ifdef SIGFPE
signal(SIGFPE,se_signal_handler);
#endif
#ifdef SIGSEGV
signal(SIGSEGV,se_signal_handler);
#endif
#ifdef SIGBUS
signal(SIGBUS,se_signal_handler);
#endif
#ifdef SIGSYS
signal(SIGSYS,se_signal_handler);
#endif
#ifdef SIGTRAP
signal(SIGTRAP,se_signal_handler);
#endif
#ifdef SIGXCPU
signal(SIGXCPU,se_signal_handler);
#endif
#ifdef SIGXFSZ
signal(SIGXFSZ,se_signal_handler);
#endif
se_msi1();
/*PCO*/
(ds.p=0x0460F214/*l242c10/output_stream.e*/);
{T7*n=new7();
oBC35tmp_string=((T0*)n);
r7make(&ds,n,/*IC*/(T2)(INT16_C(512)));
se_i7(&ds,n);}
/*PCO*/
(ds.p=0x01E14214/*l322c10/general.e*/);
{T37*n=new37();
oBC15std_output=((T0*)n);
r37make(&ds,n);
}
/*PCO*/
(ds.p=0x01E13414/*l308c10/general.e*/);
{T34*n=new34();
oBC15io=((T0*)n);
r34make(&ds,n);
}
/*PCO*/
gc_is_off=0;
{
T12*n=new12();
eiffel_root_object=n;
}
set_dump_stack_top(NULL);/*unlink*/
}
int main(int argc,char*argv[]){
stack_bottom=((void**)(&argc));
initialize_eiffel_runtime(argc,argv);
{T12*n=eiffel_root_object;
se_frame_descriptor root={"<system root>",1,0,"%R12%",1};
se_dump_stack ds;
ds.fd=&root;
ds.current=((void**)(&n));
ds.p=0x0180070A/*l7c5/a5.e*/;
ds.caller=NULL;
ds.exception_origin=NULL;
ds.locals=NULL;
set_dump_stack_top(&ds);/*link*/
r12make(&ds,n);
set_dump_stack_top(NULL);/*unlink*/
}
exit(0);
return 0;}
T0*ms25_117797837;

T0*se_ms(int c,char*e){
/* Allocate a Manifest STRING.*/
T7*s=new7();
s->_count=c;
s->_capacity=c+1;
s->_storage=((T9)new9(c+1));
memcpy(s->_storage,e,c+1);
return((T0*)s);}

T0*se_string(char*e){
/* Allocate an Eiffel STRING by copying C char*e */
int c=strlen(e);
T7*s=new7();
s->_count=c;
s->_capacity=c+1;
s->_storage=((T9)new9(c+1));
memcpy(s->_storage,e,c+1);
return((T0*)s);}

void se_msi1(void){
ms25_117797837=se_ms(10,"0123456789");
}

void manifest_string_mark1(void){
gc_mark7((T7*)ms25_117797837);
}

void once_function_mark(void){
if(NULL!=oBC15command_arguments)gc_mark42((T42*)(oBC15command_arguments));
if(NULL!=oBC35tmp_string)gc_mark7((T7*)(oBC35tmp_string));
if(NULL!=oBC15std_output)gc_mark37((T37*)(oBC15std_output));
if(NULL!=oBC15io)gc_mark34((T34*)(oBC15io));
}

void gc_start(void){
if(gc_is_off)return;
if(garbage_delayed())return;
gcmt_tail_addr=(((char*)(gcmt[gcmt_used-1]))+(gcmt[gcmt_used-1])->size);
((gc12*)eiffel_root_object)->header.flag=FSOH_UNMARKED;
gc_free34=NULL;
gc_free44=NULL;
if(na_env33.store_left>0){
na_env33.store->header.size=na_env33.store_left;
na_env33.store->header.magic_flag=RSOH_FREE;
na_env33.store_left=0;
}
na_env33.chunk_list=NULL;
na_env33.store_chunk=NULL;
gc_free38=NULL;
gc_free31=NULL;
gc_free42=NULL;
gc_free39=NULL;
if(na_env29.store_left>0){
na_env29.store->header.size=na_env29.store_left;
na_env29.store->header.magic_flag=RSOH_FREE;
na_env29.store_left=0;
}
na_env29.chunk_list=NULL;
na_env29.store_chunk=NULL;
gc_free7=NULL;
if(na_env9.store_left>0){
na_env9.store->header.size=na_env9.store_left;
na_env9.store->header.magic_flag=RSOH_FREE;
na_env9.store_left=0;
}
na_env9.chunk_list=NULL;
na_env9.store_chunk=NULL;
gc_free16=NULL;
gc_free22=NULL;
gc_free12=NULL;
if(na_env45.store_left>0){
na_env45.store->header.size=na_env45.store_left;
na_env45.store->header.magic_flag=RSOH_FREE;
na_env45.store_left=0;
}
na_env45.chunk_list=NULL;
na_env45.store_chunk=NULL;
gc_free30=NULL;
gc_free37=NULL;
gc_mark12(eiffel_root_object);
manifest_string_mark1();
once_function_mark();
{int i=SE_MAXID-1;
while(i>=0){
if(g[i]!=NULL)gc_mark7(g[i]);
i--;}
}
{int i=SE_MAXID-1;
while(i>=0){
if(t[i]!=NULL)gc_mark7(t[i]);
i--;}
}
mark_stack_and_registers();
gc_sweep();
collector_counter++;
}
gc34*store34=NULL;
int store_left34=0;
fsoc*store_chunk34=NULL;
gc34*gc_free34=NULL;
gc44*store44=NULL;
int store_left44=0;
fsoc*store_chunk44=NULL;
gc44*gc_free44=NULL;
na_env na_env33={0,NULL,NULL,NULL,(void(*)(T0*))gc_mark33};
gc38*store38=NULL;
int store_left38=0;
fsoc*store_chunk38=NULL;
gc38*gc_free38=NULL;
gc31*store31=NULL;
int store_left31=0;
fsoc*store_chunk31=NULL;
gc31*gc_free31=NULL;
gc42*store42=NULL;
int store_left42=0;
fsoc*store_chunk42=NULL;
gc42*gc_free42=NULL;
gc39*store39=NULL;
int store_left39=0;
fsoc*store_chunk39=NULL;
gc39*gc_free39=NULL;
na_env na_env29={0,NULL,NULL,NULL,(void(*)(T0*))gc_mark29};
gc7*store7=NULL;
int store_left7=0;
fsoc*store_chunk7=NULL;
gc7*gc_free7=NULL;
na_env na_env9={0,NULL,NULL,NULL,(void(*)(T0*))gc_mark9};
gc16*store16=NULL;
int store_left16=0;
fsoc*store_chunk16=NULL;
gc16*gc_free16=NULL;
gc22*store22=NULL;
int store_left22=0;
fsoc*store_chunk22=NULL;
gc22*gc_free22=NULL;
gc12*store12=NULL;
int store_left12=0;
fsoc*store_chunk12=NULL;
gc12*gc_free12=NULL;
na_env na_env45={0,NULL,NULL,NULL,(void(*)(T0*))gc_mark45};
gc30*store30=NULL;
int store_left30=0;
fsoc*store_chunk30=NULL;
gc30*gc_free30=NULL;
gc37*store37=NULL;
int store_left37=0;
fsoc*store_chunk37=NULL;
gc37*gc_free37=NULL;

void gc_sweep34(fsoc*c){
gc34*o1,*o2,*flt,flh;
o1=((gc34*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store34;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
}
else{
o1->header.next=gc_free34;
gc_free34=o1;
}
}
}
else{
int dead=1;
flh.header.next=NULL;
flt=&flh;
o2=o1+c->count_minus_one;
for(;o1<=o2;o2--){
if((o2->header.flag)==FSOH_MARKED){
o2->header.flag=FSOH_UNMARKED;
dead=0;}
else{
flt->header.next=o2;
flt=o2;
}
}
if (dead){
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
else if(flh.header.next!=NULL){
flt->header.next=gc_free34;
gc_free34=flh.header.next;
}
}
}

void gc_mark34(T34*o){
se_gc_check_id(o,34);
{((gc34*)o)->header.flag=FSOH_MARKED;

}}

void gc_align_mark34(fsoc*c,gc34*p){
gc34*b=((gc34*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store34)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T34*o=(&(p->object));
((gc34*)o)->header.flag=FSOH_MARKED;
}
}
}
fsoc H34={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark34,
(void(*)(mch*))gc_sweep34},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc34))-1)};

T34*new34(void){
gc34*n;
fsoc*c;
if(store_left34>1){
store_left34--;
n=store34++;
}
else if(gc_free34!=NULL){
n=gc_free34;
gc_free34=n->header.next;
}
else if(store_left34==1){
store_left34=0;
store_chunk34->header.state_type=FSO_USED_CHUNK;
n=store34++;
}
else{
c=gc_fsoc_get1();
if(gc_free34!=NULL){
n=gc_free34;
gc_free34=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk34=c;
*store_chunk34=H34;
store34=((gc34*)(&(store_chunk34->first_object)));
store_left34=H34.count_minus_one;
n=store34++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M34;
return((T34*)n);
}

void gc_sweep44(fsoc*c){
gc44*o1,*o2,*flt,flh;
o1=((gc44*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store44;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
}
else{
o1->header.next=gc_free44;
gc_free44=o1;
}
}
}
else{
int dead=1;
flh.header.next=NULL;
flt=&flh;
o2=o1+c->count_minus_one;
for(;o1<=o2;o2--){
if((o2->header.flag)==FSOH_MARKED){
o2->header.flag=FSOH_UNMARKED;
dead=0;}
else{
flt->header.next=o2;
flt=o2;
}
}
if (dead){
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
else if(flh.header.next!=NULL){
flt->header.next=gc_free44;
gc_free44=flh.header.next;
}
}
}

void gc_mark44(T44*o){
se_gc_check_id(o,44);
{if(((gc44*)o)->header.flag==FSOH_UNMARKED){
((gc44*)o)->header.flag=FSOH_MARKED;
if(NULL!=o->_storage/*1*/)gc_mark45((o->_storage/*1*/));
}
}}

void gc_align_mark44(fsoc*c,gc44*p){
gc44*b=((gc44*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store44)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T44*o=(&(p->object));
((gc44*)o)->header.flag=FSOH_MARKED;
if(NULL!=o->_storage/*1*/)gc_mark45((o->_storage/*1*/));
}
}
}
fsoc H44={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark44,
(void(*)(mch*))gc_sweep44},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc44))-1)};

T44*new44(void){
gc44*n;
fsoc*c;
if(store_left44>1){
store_left44--;
n=store44++;
}
else if(gc_free44!=NULL){
n=gc_free44;
gc_free44=n->header.next;
}
else if(store_left44==1){
store_left44=0;
store_chunk44->header.state_type=FSO_USED_CHUNK;
n=store44++;
}
else{
c=gc_fsoc_get1();
if(gc_free44!=NULL){
n=gc_free44;
gc_free44=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk44=c;
*store_chunk44=H44;
store44=((gc44*)(&(store_chunk44->first_object)));
store_left44=H44.count_minus_one;
n=store44++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M44;
return((T44*)n);
}

void gc_mark33(T33 o){
{rsoh*h=((rsoh*)o)-1;
 if((h->header.magic_flag)==RSOH_UNMARKED){
    h->header.magic_flag=RSOH_MARKED;
    {T0* e;
T0**p=((void*)(o+((((h->header.size)-sizeof(rsoh))/sizeof(e))-1)));
for(;((void*)p)>=((void*)o);p--){
e=*p;
if(NULL!=e)gc_mark16((T16*)(e));
}}}}
}

T33 new33(unsigned int size){
size=(size*sizeof(T0*))+sizeof(rsoh);
if((size%sizeof(double))!=0)size+=(sizeof(double)-(size%sizeof(double)));
if (size<=(na_env33.store_left)){
rsoh*r=na_env33.store;
na_env33.store_left-=size;
if(na_env33.store_left>sizeof(rsoh)){
r->header.size=size;
na_env33.store=((rsoh*)(((char*)(na_env33.store))+size));
}
else {
r->header.size=size+na_env33.store_left;
na_env33.store_left=0;
}
(r->header.magic_flag)=RSOH_UNMARKED;
((void)memset((r+1),0,r->header.size-sizeof(rsoh)));
return((T33)(r+1));
}
return((T33)new_na(&na_env33,size));
}

void gc_sweep38(fsoc*c){
gc38*o1,*o2,*flt,flh;
o1=((gc38*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store38;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
}
else{
o1->header.next=gc_free38;
gc_free38=o1;
}
}
}
else{
int dead=1;
flh.header.next=NULL;
flt=&flh;
o2=o1+c->count_minus_one;
for(;o1<=o2;o2--){
if((o2->header.flag)==FSOH_MARKED){
o2->header.flag=FSOH_UNMARKED;
dead=0;}
else{
flt->header.next=o2;
flt=o2;
}
}
if (dead){
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
else if(flh.header.next!=NULL){
flt->header.next=gc_free38;
gc_free38=flh.header.next;
}
}
}

void gc_mark38(T38*o){
se_gc_check_id(o,38);
{if(((gc38*)o)->header.flag==FSOH_UNMARKED){
((gc38*)o)->header.flag=FSOH_MARKED;
if(NULL!=o->_s/*5*/)gc_mark7((T7*)(o->_s/*5*/));
if(NULL!=o->_file/*1*/)gc_mark39((T39*)(o->_file/*1*/));
}
}}

void gc_align_mark38(fsoc*c,gc38*p){
gc38*b=((gc38*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store38)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T38*o=(&(p->object));
((gc38*)o)->header.flag=FSOH_MARKED;
if(NULL!=o->_s/*5*/)gc_mark7((T7*)(o->_s/*5*/));
if(NULL!=o->_file/*1*/)gc_mark39((T39*)(o->_file/*1*/));
}
}
}
fsoc H38={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark38,
(void(*)(mch*))gc_sweep38},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc38))-1)};

T38*new38(void){
gc38*n;
fsoc*c;
if(store_left38>1){
store_left38--;
n=store38++;
}
else if(gc_free38!=NULL){
n=gc_free38;
gc_free38=n->header.next;
}
else if(store_left38==1){
store_left38=0;
store_chunk38->header.state_type=FSO_USED_CHUNK;
n=store38++;
}
else{
c=gc_fsoc_get1();
if(gc_free38!=NULL){
n=gc_free38;
gc_free38=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk38=c;
*store_chunk38=H38;
store38=((gc38*)(&(store_chunk38->first_object)));
store_left38=H38.count_minus_one;
n=store38++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M38;
return((T38*)n);
}

void gc_sweep31(fsoc*c){
gc31*o1,*o2,*flt,flh;
o1=((gc31*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store31;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
}
else{
o1->header.next=gc_free31;
gc_free31=o1;
}
}
}
else{
int dead=1;
flh.header.next=NULL;
flt=&flh;
o2=o1+c->count_minus_one;
for(;o1<=o2;o2--){
if((o2->header.flag)==FSOH_MARKED){
o2->header.flag=FSOH_UNMARKED;
dead=0;}
else{
flt->header.next=o2;
flt=o2;
}
}
if (dead){
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
else if(flh.header.next!=NULL){
flt->header.next=gc_free31;
gc_free31=flh.header.next;
}
}
}

void gc_mark31(T31*o){
se_gc_check_id(o,31);
{if(((gc31*)o)->header.flag==FSOH_UNMARKED){
((gc31*)o)->header.flag=FSOH_MARKED;
if(NULL!=o->_storage/*1*/)gc_mark33((o->_storage/*1*/));
}
}}

void gc_align_mark31(fsoc*c,gc31*p){
gc31*b=((gc31*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store31)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T31*o=(&(p->object));
((gc31*)o)->header.flag=FSOH_MARKED;
if(NULL!=o->_storage/*1*/)gc_mark33((o->_storage/*1*/));
}
}
}
fsoc H31={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark31,
(void(*)(mch*))gc_sweep31},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc31))-1)};

T31*new31(void){
gc31*n;
fsoc*c;
if(store_left31>1){
store_left31--;
n=store31++;
}
else if(gc_free31!=NULL){
n=gc_free31;
gc_free31=n->header.next;
}
else if(store_left31==1){
store_left31=0;
store_chunk31->header.state_type=FSO_USED_CHUNK;
n=store31++;
}
else{
c=gc_fsoc_get1();
if(gc_free31!=NULL){
n=gc_free31;
gc_free31=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk31=c;
*store_chunk31=H31;
store31=((gc31*)(&(store_chunk31->first_object)));
store_left31=H31.count_minus_one;
n=store31++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M31;
return((T31*)n);
}

void gc_sweep42(fsoc*c){
gc42*o1,*o2,*flt,flh;
o1=((gc42*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store42;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
}
else{
o1->header.next=gc_free42;
gc_free42=o1;
}
}
}
else{
int dead=1;
flh.header.next=NULL;
flt=&flh;
o2=o1+c->count_minus_one;
for(;o1<=o2;o2--){
if((o2->header.flag)==FSOH_MARKED){
o2->header.flag=FSOH_UNMARKED;
dead=0;}
else{
flt->header.next=o2;
flt=o2;
}
}
if (dead){
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
else if(flh.header.next!=NULL){
flt->header.next=gc_free42;
gc_free42=flh.header.next;
}
}
}

void gc_mark42(T42*o){
se_gc_check_id(o,42);
{if(((gc42*)o)->header.flag==FSOH_UNMARKED){
((gc42*)o)->header.flag=FSOH_MARKED;
if(NULL!=o->_storage/*1*/)gc_mark29((o->_storage/*1*/));
}
}}

void gc_align_mark42(fsoc*c,gc42*p){
gc42*b=((gc42*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store42)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T42*o=(&(p->object));
((gc42*)o)->header.flag=FSOH_MARKED;
if(NULL!=o->_storage/*1*/)gc_mark29((o->_storage/*1*/));
}
}
}
fsoc H42={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark42,
(void(*)(mch*))gc_sweep42},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc42))-1)};

T42*new42(void){
gc42*n;
fsoc*c;
if(store_left42>1){
store_left42--;
n=store42++;
}
else if(gc_free42!=NULL){
n=gc_free42;
gc_free42=n->header.next;
}
else if(store_left42==1){
store_left42=0;
store_chunk42->header.state_type=FSO_USED_CHUNK;
n=store42++;
}
else{
c=gc_fsoc_get1();
if(gc_free42!=NULL){
n=gc_free42;
gc_free42=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk42=c;
*store_chunk42=H42;
store42=((gc42*)(&(store_chunk42->first_object)));
store_left42=H42.count_minus_one;
n=store42++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M42;
return((T42*)n);
}

void gc_sweep39(fsoc*c){
gc39*o1,*o2,*flt,flh;
o1=((gc39*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store39;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
}
else{
o1->header.next=gc_free39;
gc_free39=o1;
}
}
}
else{
int dead=1;
flh.header.next=NULL;
flt=&flh;
o2=o1+c->count_minus_one;
for(;o1<=o2;o2--){
if((o2->header.flag)==FSOH_MARKED){
o2->header.flag=FSOH_UNMARKED;
dead=0;}
else{
flt->header.next=o2;
flt=o2;
}
}
if (dead){
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
else if(flh.header.next!=NULL){
flt->header.next=gc_free39;
gc_free39=flh.header.next;
}
}
}

void gc_mark39(T39*o){
se_gc_check_id(o,39);
{if(((gc39*)o)->header.flag==FSOH_UNMARKED){
((gc39*)o)->header.flag=FSOH_MARKED;
if(NULL!=o->_buffer/*12*/)gc_mark9((o->_buffer/*12*/));
if(NULL!=o->_path/*1*/)gc_mark7((T7*)(o->_path/*1*/));
}
}}

void gc_align_mark39(fsoc*c,gc39*p){
gc39*b=((gc39*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store39)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T39*o=(&(p->object));
((gc39*)o)->header.flag=FSOH_MARKED;
if(NULL!=o->_buffer/*12*/)gc_mark9((o->_buffer/*12*/));
if(NULL!=o->_path/*1*/)gc_mark7((T7*)(o->_path/*1*/));
}
}
}
fsoc H39={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark39,
(void(*)(mch*))gc_sweep39},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc39))-1)};

T39*new39(void){
gc39*n;
fsoc*c;
if(store_left39>1){
store_left39--;
n=store39++;
}
else if(gc_free39!=NULL){
n=gc_free39;
gc_free39=n->header.next;
}
else if(store_left39==1){
store_left39=0;
store_chunk39->header.state_type=FSO_USED_CHUNK;
n=store39++;
}
else{
c=gc_fsoc_get1();
if(gc_free39!=NULL){
n=gc_free39;
gc_free39=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk39=c;
*store_chunk39=H39;
store39=((gc39*)(&(store_chunk39->first_object)));
store_left39=H39.count_minus_one;
n=store39++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M39;
return((T39*)n);
}

void gc_mark29(T29 o){
{rsoh*h=((rsoh*)o)-1;
 if((h->header.magic_flag)==RSOH_UNMARKED){
    h->header.magic_flag=RSOH_MARKED;
    {T0* e;
T0**p=((void*)(o+((((h->header.size)-sizeof(rsoh))/sizeof(e))-1)));
for(;((void*)p)>=((void*)o);p--){
e=*p;
if(NULL!=e)gc_mark7((T7*)(e));
}}}}
}

T29 new29(unsigned int size){
size=(size*sizeof(T0*))+sizeof(rsoh);
if((size%sizeof(double))!=0)size+=(sizeof(double)-(size%sizeof(double)));
if (size<=(na_env29.store_left)){
rsoh*r=na_env29.store;
na_env29.store_left-=size;
if(na_env29.store_left>sizeof(rsoh)){
r->header.size=size;
na_env29.store=((rsoh*)(((char*)(na_env29.store))+size));
}
else {
r->header.size=size+na_env29.store_left;
na_env29.store_left=0;
}
(r->header.magic_flag)=RSOH_UNMARKED;
((void)memset((r+1),0,r->header.size-sizeof(rsoh)));
return((T29)(r+1));
}
return((T29)new_na(&na_env29,size));
}

void gc_sweep7(fsoc*c){
gc7*o1,*o2,*flt,flh;
o1=((gc7*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store7;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
}
else{
o1->header.next=gc_free7;
gc_free7=o1;
}
}
}
else{
int dead=1;
flh.header.next=NULL;
flt=&flh;
o2=o1+c->count_minus_one;
for(;o1<=o2;o2--){
if((o2->header.flag)==FSOH_MARKED){
o2->header.flag=FSOH_UNMARKED;
dead=0;}
else{
flt->header.next=o2;
flt=o2;
}
}
if (dead){
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
else if(flh.header.next!=NULL){
flt->header.next=gc_free7;
gc_free7=flh.header.next;
}
}
}

void gc_mark7(T7*o){
se_gc_check_id(o,7);
{if(((gc7*)o)->header.flag==FSOH_UNMARKED){
((gc7*)o)->header.flag=FSOH_MARKED;
if(NULL!=o->_storage/*1*/)gc_mark9((o->_storage/*1*/));
}
}}

void gc_align_mark7(fsoc*c,gc7*p){
gc7*b=((gc7*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store7)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T7*o=(&(p->object));
((gc7*)o)->header.flag=FSOH_MARKED;
if(NULL!=o->_storage/*1*/)gc_mark9((o->_storage/*1*/));
}
}
}
fsoc H7={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark7,
(void(*)(mch*))gc_sweep7},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc7))-1)};

T7*new7(void){
gc7*n;
fsoc*c;
if(store_left7>1){
store_left7--;
n=store7++;
}
else if(gc_free7!=NULL){
n=gc_free7;
gc_free7=n->header.next;
}
else if(store_left7==1){
store_left7=0;
store_chunk7->header.state_type=FSO_USED_CHUNK;
n=store7++;
}
else{
c=gc_fsoc_get1();
if(gc_free7!=NULL){
n=gc_free7;
gc_free7=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk7=c;
*store_chunk7=H7;
store7=((gc7*)(&(store_chunk7->first_object)));
store_left7=H7.count_minus_one;
n=store7++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M7;
return((T7*)n);
}

void gc_mark9(T9 o){
(((rsoh*)o)-1)->header.magic_flag=RSOH_MARKED;
}

T9 new9(unsigned int size){
size=(size*sizeof(T3))+sizeof(rsoh);
if((size%sizeof(double))!=0)size+=(sizeof(double)-(size%sizeof(double)));
if (size<=(na_env9.store_left)){
rsoh*r=na_env9.store;
na_env9.store_left-=size;
if(na_env9.store_left>sizeof(rsoh)){
r->header.size=size;
na_env9.store=((rsoh*)(((char*)(na_env9.store))+size));
}
else {
r->header.size=size+na_env9.store_left;
na_env9.store_left=0;
}
(r->header.magic_flag)=RSOH_UNMARKED;
((void)memset((r+1),0,r->header.size-sizeof(rsoh)));
return((T9)(r+1));
}
return((T9)new_na(&na_env9,size));
}

void gc_sweep16(fsoc*c){
gc16*o1,*o2,*flt,flh;
o1=((gc16*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store16;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
}
else{
o1->header.next=gc_free16;
gc_free16=o1;
}
}
}
else{
int dead=1;
flh.header.next=NULL;
flt=&flh;
o2=o1+c->count_minus_one;
for(;o1<=o2;o2--){
if((o2->header.flag)==FSOH_MARKED){
o2->header.flag=FSOH_UNMARKED;
dead=0;}
else{
flt->header.next=o2;
flt=o2;
}
}
if (dead){
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
else if(flh.header.next!=NULL){
flt->header.next=gc_free16;
gc_free16=flh.header.next;
}
}
}

void gc_mark16(T16*o){
se_gc_check_id(o,16);
{if(((gc16*)o)->header.flag==FSOH_UNMARKED){
((gc16*)o)->header.flag=FSOH_MARKED;
if(NULL!=o->_rules/*1*/)gc_mark22((T22*)(o->_rules/*1*/));
}
}}

void gc_align_mark16(fsoc*c,gc16*p){
gc16*b=((gc16*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store16)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T16*o=(&(p->object));
((gc16*)o)->header.flag=FSOH_MARKED;
if(NULL!=o->_rules/*1*/)gc_mark22((T22*)(o->_rules/*1*/));
}
}
}
fsoc H16={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark16,
(void(*)(mch*))gc_sweep16},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc16))-1)};

T16*new16(void){
gc16*n;
fsoc*c;
if(store_left16>1){
store_left16--;
n=store16++;
}
else if(gc_free16!=NULL){
n=gc_free16;
gc_free16=n->header.next;
}
else if(store_left16==1){
store_left16=0;
store_chunk16->header.state_type=FSO_USED_CHUNK;
n=store16++;
}
else{
c=gc_fsoc_get1();
if(gc_free16!=NULL){
n=gc_free16;
gc_free16=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk16=c;
*store_chunk16=H16;
store16=((gc16*)(&(store_chunk16->first_object)));
store_left16=H16.count_minus_one;
n=store16++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M16;
return((T16*)n);
}

void gc_sweep22(fsoc*c){
gc22*o1,*o2,*flt,flh;
o1=((gc22*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store22;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
}
else{
o1->header.next=gc_free22;
gc_free22=o1;
}
}
}
else{
int dead=1;
flh.header.next=NULL;
flt=&flh;
o2=o1+c->count_minus_one;
for(;o1<=o2;o2--){
if((o2->header.flag)==FSOH_MARKED){
o2->header.flag=FSOH_UNMARKED;
dead=0;}
else{
flt->header.next=o2;
flt=o2;
}
}
if (dead){
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
else if(flh.header.next!=NULL){
flt->header.next=gc_free22;
gc_free22=flh.header.next;
}
}
}

void gc_mark22(T22*o){
se_gc_check_id(o,22);
{if(((gc22*)o)->header.flag==FSOH_UNMARKED){
((gc22*)o)->header.flag=FSOH_MARKED;
if(NULL!=o->_storage/*1*/)gc_mark29((o->_storage/*1*/));
}
}}

void gc_align_mark22(fsoc*c,gc22*p){
gc22*b=((gc22*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store22)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T22*o=(&(p->object));
((gc22*)o)->header.flag=FSOH_MARKED;
if(NULL!=o->_storage/*1*/)gc_mark29((o->_storage/*1*/));
}
}
}
fsoc H22={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark22,
(void(*)(mch*))gc_sweep22},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc22))-1)};

T22*new22(void){
gc22*n;
fsoc*c;
if(store_left22>1){
store_left22--;
n=store22++;
}
else if(gc_free22!=NULL){
n=gc_free22;
gc_free22=n->header.next;
}
else if(store_left22==1){
store_left22=0;
store_chunk22->header.state_type=FSO_USED_CHUNK;
n=store22++;
}
else{
c=gc_fsoc_get1();
if(gc_free22!=NULL){
n=gc_free22;
gc_free22=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk22=c;
*store_chunk22=H22;
store22=((gc22*)(&(store_chunk22->first_object)));
store_left22=H22.count_minus_one;
n=store22++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M22;
return((T22*)n);
}

void gc_sweep12(fsoc*c){
gc12*o1,*o2,*flt,flh;
o1=((gc12*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store12;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
}
else{
o1->header.next=gc_free12;
gc_free12=o1;
}
}
}
else{
int dead=1;
flh.header.next=NULL;
flt=&flh;
o2=o1+c->count_minus_one;
for(;o1<=o2;o2--){
if((o2->header.flag)==FSOH_MARKED){
o2->header.flag=FSOH_UNMARKED;
dead=0;}
else{
flt->header.next=o2;
flt=o2;
}
}
if (dead){
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
else if(flh.header.next!=NULL){
flt->header.next=gc_free12;
gc_free12=flh.header.next;
}
}
}

void gc_mark12(T12*o){
se_gc_check_id(o,12);
{if(((gc12*)o)->header.flag==FSOH_UNMARKED){
((gc12*)o)->header.flag=FSOH_MARKED;
if(NULL!=o->_db/*5*/)gc_mark30((T30*)(o->_db/*5*/));
if(NULL!=o->_tok/*1*/)gc_mark38((T38*)(o->_tok/*1*/));
}
}}

void gc_align_mark12(fsoc*c,gc12*p){
gc12*b=((gc12*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store12)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T12*o=(&(p->object));
((gc12*)o)->header.flag=FSOH_MARKED;
if(NULL!=o->_db/*5*/)gc_mark30((T30*)(o->_db/*5*/));
if(NULL!=o->_tok/*1*/)gc_mark38((T38*)(o->_tok/*1*/));
}
}
}
fsoc H12={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark12,
(void(*)(mch*))gc_sweep12},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc12))-1)};

T12*new12(void){
gc12*n;
fsoc*c;
if(store_left12>1){
store_left12--;
n=store12++;
}
else if(gc_free12!=NULL){
n=gc_free12;
gc_free12=n->header.next;
}
else if(store_left12==1){
store_left12=0;
store_chunk12->header.state_type=FSO_USED_CHUNK;
n=store12++;
}
else{
c=gc_fsoc_get1();
if(gc_free12!=NULL){
n=gc_free12;
gc_free12=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk12=c;
*store_chunk12=H12;
store12=((gc12*)(&(store_chunk12->first_object)));
store_left12=H12.count_minus_one;
n=store12++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M12;
return((T12*)n);
}

void gc_mark45(T45 o){
(((rsoh*)o)-1)->header.magic_flag=RSOH_MARKED;
}

T45 new45(unsigned int size){
size=(size*sizeof(T2))+sizeof(rsoh);
if((size%sizeof(double))!=0)size+=(sizeof(double)-(size%sizeof(double)));
if (size<=(na_env45.store_left)){
rsoh*r=na_env45.store;
na_env45.store_left-=size;
if(na_env45.store_left>sizeof(rsoh)){
r->header.size=size;
na_env45.store=((rsoh*)(((char*)(na_env45.store))+size));
}
else {
r->header.size=size+na_env45.store_left;
na_env45.store_left=0;
}
(r->header.magic_flag)=RSOH_UNMARKED;
((void)memset((r+1),0,r->header.size-sizeof(rsoh)));
return((T45)(r+1));
}
return((T45)new_na(&na_env45,size));
}

#ifdef __cplusplus
}
#endif
