(a) The given code was tested on Mac OS X 10.4.10 using gcc 4.0.1. Below are
the runtimes:

DYN undefined, no optimizations:
User: 0m0.387s

DYN undefined, O2 optimizations:
User: 0m0.028s

DYN defined, no optimizations:
User: 0m4.634s

DYN defined, O2 optimizations:
User: 0m4.255s

Notice that allocating dynamic memory is much slower than allocating automatic 
memory (4.634s vs 0.387s, almost 10x slower). This is most likely because
allocating dynamic memory needs a system call; using strace under Linux I saw
that the brk() system call was being called multiple times. The context-
switching involved introduces overhead and thus makes it run slower. In
addition, with automatic memory allocation where the variables are allocated on
the stack, most compilers do not ``zero out'' the stack upon exiting a block of
code, but instead simply move the stack pointer. Thus, when the next iteration
of the for-loop comes around, the array for ip is ``already there'' so to speak.

Using the O2 optimization flag, the running time of the program using automatic
memory allocation was greatly improved (0.028s vs 0.387s, almost 13x faster).
Examining the assembly code generated by g++, it seems that the code for the
for-loop was not even generated, hence the speed increase. With dynamic memory
allocation, the speed increase was not so pronounced. The compiler was not able
to optimize as much in this case, probably because it is hard to detect during
compile time if a pointer is not used from anywhere else in the program. Thus
g++ ended up generating the code for the for-loop and the code for all the 
memory allocation. However g++ was still able to optimize parts of the code, and
the speed did decrease from 4.634s to 4.255s.

(b) Zero was used instead of NULL to initialize pointer ip since NULL is
defined in stdlib.h, and would need to be included if we wanted to use NULL
(sample code does not #include <stdlib.h>). This would result in our executable
being larger since we have included a lot of extra symbols.

(c) Calling ``delete'' with an address of 0 does not produce an error, because
that is the behaviour specified in the official C++ standard.

In basic.stc.dynamic.deallocation 3.7.3.2/3:
``If the value of the first argument is a null pointer value, the call to the
deallocation function has no effect.''
